<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>DRONE WAR - 드론 워 | 레트로 액션 생존 게임</title>

    <!-- SEO Meta Tags -->
    <meta name="description" content="레트로 픽셀아트와 뱀파이어 서바이버류가 만난 드론 격투 액션 게임. 6가지 드론으로 스토리 모드와 무한 모드에서 생존하세요!">
    <meta name="keywords" content="드론게임, 뱀서류, 레트로게임, 생존게임, 브라우저게임, HTML5게임, 픽셀아트, 드론전쟁, 액션게임">
    <meta name="author" content="DRONE WAR">
    <meta name="theme-color" content="#1a1a2e">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="DRONE WAR">

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="game">
    <meta property="og:title" content="DRONE WAR - 드론 워">
    <meta property="og:description" content="레트로 픽셀아트와 뱀파이어 서바이버류가 만난 드론 격투 액션 게임">
    <meta property="og:image" content="assets/menu_bg.png">
    <meta property="og:url" content="">
    <meta property="og:site_name" content="DRONE WAR">
    <meta property="og:locale" content="ko_KR">

    <!-- Twitter -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="DRONE WAR - 드론 워">
    <meta name="twitter:description" content="레트로 픽셀아트 × 뱀파이어 서바이버류 드론 액션">
    <meta name="twitter:image" content="assets/menu_bg.png">

    <!-- Game-specific -->
    <meta name="game:genre" content="Action, Survival, Shooter">
    <meta name="game:platform" content="Web, Mobile">
    <meta name="game:release_date" content="2025">

    <!-- Toss Apps-in-Toss Integration -->
    <!-- SDK를 webpack 번들에서 로드 -->
    <script src="sdk-bundle.js"></script>
    <script src="toss-integration.js" defer></script>

    <style>
        @font-face {
            font-family: 'DungGeunMo';
            src: url('assets/fonts/DungGeunMo.woff2') format('woff2'),
                url('assets/fonts/DungGeunMo.woff') format('woff'),
                url('assets/fonts/DungGeunMo.eot') format('embedded-opentype');
            font-weight: normal;
            font-style: normal;
            font-display: swap;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            background: #1a1a2e;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'DungGeunMo', 'Arial', sans-serif;
            overflow: hidden;
            touch-action: none;
        }

        #gameContainer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #0f3460;
            border: none;
        }

        canvas {
            display: block;
            background: #0f3460;
            width: 100%;
            height: 100%;
            touch-action: none;
        }

        #ui {
            position: absolute;
            top: 40px;
            left: 10px;
            color: white;
            font-size: 18px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            z-index: 10;
            min-width: 200px;
        }

        #timeUI {
            position: absolute;
            top: 165px;
            left: 10px;
            color: white;
            font-size: 20px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            z-index: 10;
        }

        #homeButton {
            position: absolute;
            bottom: 30px;
            left: 10px;
            width: 50px;
            height: 50px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #4ecca3;
            border-radius: 8px;
            cursor: pointer;
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 10;
            transition: all 0.3s;
        }

        /* 일시정지 아이콘 (||) */
        #homeButton::before {
            content: '';
            position: absolute;
            width: 6px;
            height: 24px;
            background: #4ecca3;
            border-radius: 2px;
            left: 14px;
        }

        #homeButton::after {
            content: '';
            position: absolute;
            width: 6px;
            height: 24px;
            background: #4ecca3;
            border-radius: 2px;
            right: 14px;
        }

        #homeButton:hover {
            background: rgba(78, 204, 163, 0.2);
            transform: scale(1.05);
        }

        #homeButton:active {
            transform: scale(0.95);
        }

        #ultimateButton {
            position: absolute;
            bottom: 30px;
            right: 10px;
            width: 70px;
            height: 70px;
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.3), rgba(255, 193, 7, 0.5));
            border: 3px solid #ffd700;
            border-radius: 50%;
            cursor: pointer;
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 10;
            transition: all 0.3s;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
        }

        #ultimateButton img {
            width: 45px;
            height: 45px;
            pointer-events: none;
            filter: drop-shadow(2px 2px 4px rgba(0, 0, 0, 0.5));
        }

        #ultimateButton:hover {
            transform: scale(1.1);
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.8);
        }

        #ultimateButton:active {
            transform: scale(0.95);
        }

        #ultimateButton.ready {
            animation: pulse 1.5s infinite;
        }

        #ultimateButton.cooldown {
            opacity: 0.3;
            cursor: not-allowed;
            border-color: #666;
            background: rgba(100, 100, 100, 0.3);
        }

        @keyframes pulse {

            0%,
            100% {
                box-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
            }

            50% {
                box-shadow: 0 0 40px rgba(255, 215, 0, 1);
            }
        }

        #ultimateCooldown {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 20px;
            font-weight: bold;
            color: white;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }

        .stat-bar {
            margin: 5px 0;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .bar-container {
            flex: 1;
            height: 28px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            overflow: hidden;
            position: relative;
        }

        .bar-fill {
            height: 100%;
            transition: width 0.3s ease;
            border-radius: 8px;
        }

        .hp-bar {
            background: linear-gradient(90deg, #e94560, #ff6b6b);
        }

        .xp-bar {
            background: linear-gradient(90deg, #4ecca3, #5eead4);
        }

        .bar-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 14px;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
        }

        .stat-label {
            min-width: 60px;
            font-weight: bold;
        }

        #goldUI {
            position: absolute;
            top: 130px;
            left: 10px;
            color: #ffd700;
            font-size: 20px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            z-index: 10;
        }

        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 30px 40px;
            border-radius: 0;
            text-align: center;
            color: white;
            display: none;
            z-index: 20;
            max-width: 95%;
            min-width: 320px;
            width: 90%;
            border: 4px solid #e94560;
            box-shadow: 6px 6px 0px rgba(0, 0, 0, 0.7),
                0 0 60px rgba(233, 69, 96, 0.5),
                0 0 100px rgba(233, 69, 96, 0.3);
        }

        #gameOver h1 {
            color: #e94560;
            margin-bottom: 20px;
            font-size: 36px;
        }

        #gameOver button {
            margin-top: 20px;
            padding: 18px 50px;
            font-size: 22px;
            background: #e94560;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            margin: 10px 5px;
        }

        #gameOver button:active {
            background: #ff6b6b;
            transform: scale(0.95);
        }

        #levelUp {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 20px;
            border-radius: 0;
            text-align: center;
            color: white;
            display: none;
            z-index: 2000;
            max-width: 95%;
            min-width: 320px;
            max-height: 90vh;
            overflow-y: auto;
            border: 4px solid #4ecca3;
            box-shadow: 6px 6px 0px rgba(0, 0, 0, 0.7),
                0 0 60px rgba(78, 204, 163, 0.5),
                0 0 100px rgba(78, 204, 163, 0.3);
            animation: levelUpGlow 2s ease-in-out infinite alternate;
        }

        @keyframes levelUpGlow {
            0% {
                box-shadow: 6px 6px 0px rgba(0, 0, 0, 0.7),
                    0 0 60px rgba(78, 204, 163, 0.5),
                    0 0 100px rgba(78, 204, 163, 0.3);
            }

            100% {
                box-shadow: 6px 6px 0px rgba(0, 0, 0, 0.7),
                    0 0 80px rgba(78, 204, 163, 0.8),
                    0 0 140px rgba(78, 204, 163, 0.6);
            }
        }

        #levelUp h2 {
            color: #4ecca3;
            margin-bottom: 15px;
            font-size: 28px;
        }

        #upgradeOptions {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        @keyframes cardFlip {
            0% {
                transform: perspective(1000px) rotateY(90deg);
                opacity: 0;
            }

            100% {
                transform: perspective(1000px) rotateY(0deg);
                opacity: 1;
            }
        }

        @keyframes modalFadeIn {
            0% {
                opacity: 0;
            }

            100% {
                opacity: 1;
            }
        }

        @keyframes cardPopIn {
            0% {
                transform: scale(0.5);
                opacity: 0;
            }

            60% {
                transform: scale(1.1);
            }

            100% {
                transform: scale(1);
                opacity: 1;
            }
        }

        .gacha-result-card {
            animation: cardPopIn 0.5s ease-out, cardFlip 0.8s ease-out 0.3s;
        }

        .upgrade {
            background: #16213e;
            padding: 20px 24px;
            margin: 8px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            border: 2px solid #4ecca3;
            position: relative;
            transform-origin: center;
            min-width: 280px;
            font-size: 16px;
        }

        .upgrade.common {
            border-color: #9ca3af;
            box-shadow: 0 0 12px rgba(156, 163, 175, 0.5),
                0 0 25px rgba(156, 163, 175, 0.2),
                4px 4px 0px rgba(0, 0, 0, 0.5);
            animation: cardFlip 0.3s ease-out;
        }

        .upgrade.uncommon {
            border-color: #10b981;
            box-shadow: 0 0 18px rgba(16, 185, 129, 0.7),
                0 0 35px rgba(16, 185, 129, 0.3),
                4px 4px 0px rgba(0, 0, 0, 0.5);
            animation: cardFlip 0.3s ease-out;
        }

        .upgrade.rare {
            border-color: #3b82f6;
            box-shadow: 0 0 22px rgba(59, 130, 246, 0.8),
                0 0 45px rgba(59, 130, 246, 0.4),
                4px 4px 0px rgba(0, 0, 0, 0.5);
            animation: cardFlip 0.3s ease-out, glowRare 2s ease-in-out infinite;
        }

        .upgrade.epic {
            border-color: #a855f7;
            box-shadow: 0 0 28px rgba(168, 85, 247, 0.9),
                0 0 55px rgba(168, 85, 247, 0.5),
                4px 4px 0px rgba(0, 0, 0, 0.5);
            animation: cardFlip 0.3s ease-out, glowEpic 2s ease-in-out infinite;
        }

        .upgrade.legend {
            border-color: #f59e0b;
            box-shadow: 0 0 35px rgba(245, 158, 11, 1.0),
                0 0 65px rgba(245, 158, 11, 0.6),
                0 0 90px rgba(245, 158, 11, 0.3),
                4px 4px 0px rgba(0, 0, 0, 0.5);
            animation: cardFlip 0.3s ease-out, glowLegend 2s ease-in-out infinite;
        }

        /* Hover 효과 - 후광 강화 */
        .upgrade.common:hover {
            box-shadow: 0 0 20px rgba(156, 163, 175, 0.7),
                0 0 40px rgba(156, 163, 175, 0.3),
                4px 4px 0px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
        }

        .upgrade.uncommon:hover {
            box-shadow: 0 0 28px rgba(16, 185, 129, 0.9),
                0 0 50px rgba(16, 185, 129, 0.5),
                4px 4px 0px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
        }

        .upgrade.rare:hover {
            box-shadow: 0 0 35px rgba(59, 130, 246, 1.0),
                0 0 60px rgba(59, 130, 246, 0.6),
                4px 4px 0px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
        }

        .upgrade.epic:hover {
            box-shadow: 0 0 42px rgba(168, 85, 247, 1.0),
                0 0 70px rgba(168, 85, 247, 0.7),
                4px 4px 0px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
        }

        .upgrade.legend:hover {
            box-shadow: 0 0 50px rgba(245, 158, 11, 1.0),
                0 0 85px rgba(245, 158, 11, 0.8),
                0 0 120px rgba(245, 158, 11, 0.5),
                4px 4px 0px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
        }

        .upgrade.common:nth-child(1) {
            animation-delay: 0s;
        }

        .upgrade.common:nth-child(2) {
            animation-delay: 0.1s;
        }

        .upgrade.common:nth-child(3) {
            animation-delay: 0.2s;
        }

        .upgrade.uncommon:nth-child(1) {
            animation-delay: 0s;
        }

        .upgrade.uncommon:nth-child(2) {
            animation-delay: 0.1s;
        }

        .upgrade.uncommon:nth-child(3) {
            animation-delay: 0.2s;
        }

        .upgrade.rare:nth-child(1) {
            animation-delay: 0s, 0s;
        }

        .upgrade.rare:nth-child(2) {
            animation-delay: 0.1s, 0s;
        }

        .upgrade.rare:nth-child(3) {
            animation-delay: 0.2s, 0s;
        }

        .upgrade.epic:nth-child(1) {
            animation-delay: 0s, 0s;
        }

        .upgrade.epic:nth-child(2) {
            animation-delay: 0.1s, 0s;
        }

        .upgrade.epic:nth-child(3) {
            animation-delay: 0.2s, 0s;
        }

        .upgrade.legend:nth-child(1) {
            animation-delay: 0s, 0s;
        }

        .upgrade.legend:nth-child(2) {
            animation-delay: 0.1s, 0s;
        }

        .upgrade.legend:nth-child(3) {
            animation-delay: 0.2s, 0s;
        }

        @keyframes glowRare {

            0%,
            100% {
                box-shadow: 0 0 20px rgba(59, 130, 246, 0.6);
            }

            50% {
                box-shadow: 0 0 35px rgba(59, 130, 246, 0.9);
            }
        }

        @keyframes glowEpic {

            0%,
            100% {
                box-shadow: 0 0 20px rgba(168, 85, 247, 0.7);
            }

            50% {
                box-shadow: 0 0 35px rgba(168, 85, 247, 1);
            }
        }

        @keyframes glowLegend {

            0%,
            100% {
                box-shadow: 0 0 20px rgba(245, 158, 11, 0.8);
            }

            50% {
                box-shadow: 0 0 40px rgba(245, 158, 11, 1);
            }
        }

        .upgrade-rarity {
            position: absolute;
            top: 5px;
            right: 8px;
            font-size: 12px;
            font-weight: bold;
            opacity: 0.7;
        }

        .upgrade.common .upgrade-rarity {
            color: #9ca3af;
        }

        .upgrade.uncommon .upgrade-rarity {
            color: #10b981;
        }

        .upgrade.rare .upgrade-rarity {
            color: #3b82f6;
        }

        .upgrade.epic .upgrade-rarity {
            color: #a855f7;
        }

        .upgrade.legend .upgrade-rarity {
            color: #f59e0b;
        }

        .upgrade:active {
            background: #1a1a2e;
            transform: scale(0.95);
        }

        .upgrade strong {
            display: block;
            margin-bottom: 8px;
            color: #4ecca3;
            font-size: 18px;
        }

        #loadingScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #000000;
            z-index: 50;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        #loadingScreen::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: url('assets/menu_bg.png');
            background-position: center;
            background-repeat: no-repeat;
            background-size: cover;
            z-index: 0;
        }

        #loadingScreen::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(180deg, rgba(0, 0, 0, 0.7) 0%, rgba(0, 0, 0, 0.9) 100%);
            z-index: 1;
        }

        .loading-content {
            position: relative;
            z-index: 2;
            text-align: center;
        }

        .loading-title {
            font-size: 72px;
            font-weight: bold;
            color: #4ecca3;
            text-shadow: 0 0 20px rgba(78, 204, 163, 0.8),
                0 0 40px rgba(78, 204, 163, 0.6),
                4px 4px 8px rgba(0, 0, 0, 0.8);
            margin-bottom: 30px;
            letter-spacing: 8px;
        }

        .loading-text {
            font-size: 24px;
            color: #fff;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }

        .loading-bar-container {
            width: 400px;
            height: 20px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid #4ecca3;
            border-radius: 10px;
            overflow: hidden;
            margin: 0 auto 15px;
        }

        .loading-bar {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #4ecca3 0%, #2ecc71 100%);
            transition: width 0.3s ease;
            box-shadow: 0 0 10px rgba(78, 204, 163, 0.8);
        }

        .loading-progress {
            font-size: 18px;
            color: #4ecca3;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }

        #mainMenu {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #000000;
            z-index: 30;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        #mainMenu::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: url('assets/menu_bg.png');
            background-position: center;
            background-repeat: no-repeat;
            background-size: cover;
            z-index: 0;
        }

        #mainMenu::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(180deg, rgba(26, 11, 41, 0.5) 0%, rgba(15, 8, 28, 0.7) 100%);
            z-index: 1;
        }

        .menu-content {
            text-align: center;
            z-index: 2;
            animation: fadeInUp 0.8s ease-out;
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .menu-title {
            margin-bottom: 10px;
            font-size: 120px;
            color: #4ecca3;
            text-shadow: 0 0 20px rgba(78, 204, 163, 0.8),
                0 0 40px rgba(78, 204, 163, 0.6),
                0 0 60px rgba(78, 204, 163, 0.4),
                4px 4px 8px rgba(0, 0, 0, 0.8);
            letter-spacing: 8px;
            font-weight: bold;
        }

        .menu-subtitle {
            font-size: 16px;
            color: #c4a7d4;
            text-shadow: 0 0 10px rgba(196, 167, 212, 0.6),
                1px 1px 4px rgba(0, 0, 0, 0.9);
            margin-bottom: 40px;
            letter-spacing: 2px;
            font-family: 'DungGeunMo', 'Georgia', serif;
        }

        .menu-buttons {
            display: flex;
            flex-direction: column;
            gap: 15px;
            align-items: center;
        }

        .menu-button {
            padding: 15px 60px;
            font-size: 20px;
            background: transparent;
            color: #4ecca3;
            border: 3px solid #4ecca3;
            border-radius: 0;
            cursor: pointer;
            transition: all 0.1s;
            font-weight: bold;
            text-shadow: 2px 2px 0px rgba(0, 0, 0, 0.8);
            box-shadow: 4px 4px 0px rgba(0, 0, 0, 0.5);
            min-width: 240px;
            letter-spacing: 2px;
            image-rendering: pixelated;
            font-family: 'DungGeunMo', monospace;
        }

        .menu-button:hover {
            background: rgba(78, 204, 163, 0.2);
            border-color: #5eead4;
            color: #5eead4;
            box-shadow: 6px 6px 0px rgba(0, 0, 0, 0.6);
            transform: translate(-2px, -2px);
        }

        .menu-button:active {
            transform: translate(2px, 2px);
            box-shadow: 2px 2px 0px rgba(0, 0, 0, 0.4);
        }


        .menu-icon-buttons {
            display: flex;
            gap: 15px;
            margin-top: 20px;
        }

        .menu-icon-button {
            width: 64px;
            height: 64px;
            padding: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0;
            background: linear-gradient(135deg, #2d2d44 0%, #1a1a2e 100%);
            border: 4px solid #4ecca3;
            border-radius: 0;
            cursor: pointer;
            transition: all 0.1s;
            image-rendering: pixelated;
            box-shadow: 4px 4px 0px rgba(0, 0, 0, 0.6),
                inset 2px 2px 0px rgba(255, 255, 255, 0.1);
            position: relative;
        }

        .menu-icon-button {
            font-size: 32px;
        }

        .menu-icon-button::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            background: transparent;
            border: 2px solid rgba(78, 204, 163, 0.3);
            border-radius: 0;
        }

        .menu-icon-button:hover {
            background: linear-gradient(135deg, #3a3a50 0%, #252541 100%);
            border-color: #5eead4;
            box-shadow: 6px 6px 0px rgba(0, 0, 0, 0.7),
                inset 2px 2px 0px rgba(255, 255, 255, 0.2);
            transform: translate(-2px, -2px);
        }

        .menu-icon-button:active {
            transform: translate(2px, 2px);
            box-shadow: 2px 2px 0px rgba(0, 0, 0, 0.5),
                inset 1px 1px 0px rgba(255, 255, 255, 0.1);
        }

        @media (max-width: 480px) {
            .loading-title {
                font-size: 48px;
                letter-spacing: 4px;
            }

            .loading-text {
                font-size: 18px;
            }

            .loading-bar-container {
                width: 300px;
            }

            #goldUI {
                top: 120px;
            }

            .menu-title {
                font-size: 48px;
                letter-spacing: 4px;
            }

            .menu-subtitle {
                font-size: 14px;
            }

            .menu-button {
                padding: 16px 50px;
                font-size: 22px;
                min-width: 240px;
            }

            .menu-icon-button {
                width: 72px;
                height: 72px;
                font-size: 36px;
            }
        }

        #startScreen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            color: white;
            z-index: 20;
            max-width: 90%;
            display: none;
        }

        #startScreen h1 {
            color: #4ecca3;
            margin-bottom: 20px;
            font-size: 32px;
        }

        #startScreen p {
            margin: 8px 0;
            color: #aaa;
            font-size: 14px;
        }

        .best-records {
            background: rgba(78, 204, 163, 0.1);
            border: 2px solid #4ecca3;
            border-radius: 10px;
            padding: 15px;
            margin: 20px 0;
        }

        .best-records h3 {
            color: #4ecca3;
            margin-bottom: 10px;
            font-size: 18px;
        }

        .record-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            color: #fff;
            font-size: 14px;
        }

        .record-label {
            color: #aaa;
        }

        .record-value {
            color: #ffd700;
            font-weight: bold;
        }

        #startScreen button {
            margin-top: 20px;
            padding: 18px 50px;
            font-size: 22px;
            background: #4ecca3;
            color: #1a1a2e;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
        }

        #startScreen button:active {
            background: #5eead4;
            transform: scale(0.95);
        }

        .start-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .icon-button {
            width: 50px;
            height: 50px;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            background: rgba(255, 255, 255, 0.1);
        }

        #shopScreen,
        #settingsScreen,
        #inventoryScreen,
        #gachaScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #000000;
            color: white;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 40px 20px;
            z-index: 35;
            overflow-y: auto;
        }

        #shopScreen::before,
        #settingsScreen::before,
        #inventoryScreen::before,
        #gachaScreen::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: url('assets/menu_bg.png');
            background-position: center;
            background-repeat: no-repeat;
            background-size: cover;
            z-index: 0;
        }

        #shopScreen::after,
        #settingsScreen::after,
        #inventoryScreen::after,
        #gachaScreen::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(180deg, rgba(26, 11, 41, 0.5) 0%, rgba(15, 8, 28, 0.7) 100%);
            z-index: 1;
        }

        #shopScreen>*,
        #settingsScreen>*,
        #inventoryScreen>*,
        #gachaScreen>* {
            position: relative;
            z-index: 2;
        }

        #shopScreen h1,
        #settingsScreen h1,
        #inventoryScreen h1,
        #gachaScreen h1 {
            color: #4ecca3;
            text-shadow: 0 0 20px rgba(78, 204, 163, 0.8),
                0 0 40px rgba(78, 204, 163, 0.6),
                4px 4px 8px rgba(0, 0, 0, 0.8);
            margin-bottom: 30px;
            font-size: 48px;
            letter-spacing: 4px;
            font-weight: bold;
            text-align: center;
        }

        .gold-display {
            color: #ffd700;
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 20px;
            position: relative;
            z-index: 10;
        }

        .character-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin: 20px 0;
            position: relative;
            z-index: 10;
        }

        @media (max-width: 480px) {
            .character-grid {
                gap: 10px;
            }

            .character-card {
                padding: 12px;
            }

            .character-icon {
                font-size: 36px;
            }

            .character-name {
                font-size: 14px;
            }

            .character-stats {
                font-size: 11px;
            }

            .character-price {
                font-size: 14px;
            }
        }

        .character-card {
            background: linear-gradient(135deg, rgba(59, 7, 100, 0.6), rgba(88, 28, 135, 0.4));
            padding: 12px;
            border-radius: 10px;
            border: 2px solid rgba(168, 85, 247, 0.5);
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 2px 8px rgba(88, 28, 135, 0.3);
            position: relative;
        }

        .character-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 5px 20px rgba(168, 85, 247, 0.5);
            border-color: rgba(168, 85, 247, 0.8);
        }

        .character-card.locked {
            opacity: 0.5;
            border-color: #666;
        }

        .character-card.selected {
            border-color: #ffd700;
            box-shadow: 0 0 25px rgba(255, 215, 0, 0.7);
            background: linear-gradient(135deg, rgba(100, 50, 150, 0.7), rgba(120, 60, 180, 0.5));
        }

        .character-icon {
            font-size: 40px;
            margin-bottom: 8px;
        }

        .character-name {
            font-weight: bold;
            margin-bottom: 5px;
            font-size: 14px;
        }

        .character-stats {
            font-size: 10px;
            color: #aaa;
            margin: 3px 0;
        }

        .character-info-btn {
            position: absolute;
            top: 8px;
            right: 8px;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: transparent;
            color: rgba(78, 204, 163, 1);
            border: 2px solid rgba(78, 204, 163, 1);
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
            z-index: 10;
        }

        .character-info-btn:hover {
            background: rgba(78, 204, 163, 0.15);
            color: #fff;
            border-color: #fff;
            transform: scale(1.15);
            box-shadow: 0 0 12px rgba(78, 204, 163, 0.6);
        }

        /* 캐릭터 상세 모달 */
        .character-lore-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            z-index: 10000;
            justify-content: center;
            align-items: center;
            animation: fadeIn 0.3s ease;
        }

        .character-lore-content {
            background: linear-gradient(135deg, rgba(26, 26, 46, 0.98), rgba(59, 7, 100, 0.95));
            border: 3px solid rgba(168, 85, 247, 0.8);
            border-radius: 15px;
            padding: 30px;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            position: relative;
            box-shadow: 0 10px 50px rgba(168, 85, 247, 0.5);
            animation: slideIn 0.3s ease;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }

        @keyframes slideIn {
            from {
                transform: translateY(-30px);
                opacity: 0;
            }

            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .character-lore-close {
            position: absolute;
            top: 15px;
            right: 15px;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: rgba(255, 51, 51, 0.8);
            color: white;
            border: none;
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
        }

        .character-lore-close:hover {
            background: rgba(255, 51, 51, 1);
            transform: rotate(90deg);
            box-shadow: 0 0 15px rgba(255, 51, 51, 0.8);
        }

        .character-lore-header {
            display: flex;
            align-items: center;
            gap: 20px;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid rgba(168, 85, 247, 0.5);
        }

        .character-lore-icon {
            width: 80px;
            height: 80px;
            border-radius: 10px;
            background: rgba(168, 85, 247, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            border: 2px solid rgba(168, 85, 247, 0.5);
        }

        .character-lore-icon img {
            width: 64px;
            height: 64px;
            image-rendering: pixelated;
        }

        .character-lore-title {
            flex: 1;
        }

        .character-lore-name {
            font-size: 24px;
            font-weight: bold;
            color: #ffd700;
            margin-bottom: 5px;
        }

        .character-lore-stats {
            font-size: 12px;
            color: #aaa;
        }

        .character-lore-ultimate {
            background: rgba(255, 215, 0, 0.1);
            border-left: 4px solid #ffd700;
            padding: 15px;
            margin: 15px 0;
            border-radius: 5px;
        }

        .character-lore-ultimate-title {
            font-size: 14px;
            font-weight: bold;
            color: #ffd700;
            margin-bottom: 8px;
        }

        .character-lore-ultimate-desc {
            font-size: 13px;
            line-height: 1.6;
            color: #fff;
        }

        .character-lore-description {
            font-size: 14px;
            line-height: 1.8;
            color: #ddd;
            white-space: pre-line;
        }

        .character-price {
            color: #ffd700;
            font-weight: bold;
            margin-top: 8px;
            font-size: 13px;
        }

        /* 게임 테마 모달 (사이버펑크 스타일) */
        .toss-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(15, 8, 28, 0.9);
            z-index: 10001;
            justify-content: center;
            align-items: center;
            animation: tossModalFadeIn 0.3s ease;
            backdrop-filter: blur(8px);
        }

        .toss-modal.show {
            display: flex;
        }

        @keyframes tossModalFadeIn {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }

        .toss-modal-content {
            background: linear-gradient(135deg, rgba(26, 26, 46, 0.98), rgba(59, 7, 100, 0.95));
            border: 3px solid #4ecca3;
            border-radius: 4px;
            padding: 0;
            max-width: 340px;
            width: 85%;
            overflow: hidden;
            box-shadow: 0 0 30px rgba(78, 204, 163, 0.5),
                6px 6px 0px rgba(0, 0, 0, 0.6);
            animation: tossModalSlideUp 0.3s ease;
        }

        @keyframes tossModalSlideUp {
            from {
                transform: translateY(30px) scale(0.95);
                opacity: 0;
            }

            to {
                transform: translateY(0) scale(1);
                opacity: 1;
            }
        }

        .toss-modal-header {
            padding: 24px 24px 12px 24px;
            text-align: center;
            border-bottom: 2px solid rgba(78, 204, 163, 0.3);
        }

        .toss-modal-title {
            font-size: 20px;
            font-weight: bold;
            color: #4ecca3;
            margin: 0;
            line-height: 1.4;
            text-shadow: 0 0 10px rgba(78, 204, 163, 0.6),
                2px 2px 0px rgba(0, 0, 0, 0.8);
        }

        .toss-modal-body {
            padding: 20px 24px 24px 24px;
            text-align: center;
        }

        .toss-modal-message {
            font-size: 15px;
            color: #c4a7d4;
            line-height: 1.7;
            margin: 0;
            white-space: pre-line;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
        }

        .toss-modal-buttons {
            display: flex;
            flex-direction: column;
            gap: 12px;
            padding: 0 20px 20px 20px;
        }

        .toss-modal-button {
            width: 100%;
            padding: 14px 20px;
            border: 3px solid #4ecca3;
            border-radius: 0;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.1s;
            font-family: 'DungGeunMo', 'Arial', sans-serif;
            text-shadow: 2px 2px 0px rgba(0, 0, 0, 0.8);
            box-shadow: 4px 4px 0px rgba(0, 0, 0, 0.5);
            position: relative;
        }

        .toss-modal-button.primary {
            background: #4ecca3;
            color: #0f081c;
        }

        .toss-modal-button.primary:hover {
            background: #5eead4;
            box-shadow: 0 0 20px rgba(78, 204, 163, 0.6),
                4px 4px 0px rgba(0, 0, 0, 0.5);
            transform: translate(-2px, -2px);
        }

        .toss-modal-button.primary:active {
            transform: translate(2px, 2px);
            box-shadow: 2px 2px 0px rgba(0, 0, 0, 0.5);
        }

        .toss-modal-button.secondary {
            background: transparent;
            color: #4ecca3;
        }

        .toss-modal-button.secondary:hover {
            background: rgba(78, 204, 163, 0.2);
            box-shadow: 0 0 15px rgba(78, 204, 163, 0.4),
                4px 4px 0px rgba(0, 0, 0, 0.5);
            transform: translate(-2px, -2px);
        }

        .toss-modal-button.secondary:active {
            transform: translate(2px, 2px);
            box-shadow: 2px 2px 0px rgba(0, 0, 0, 0.5);
        }

        .toss-modal-button.danger {
            background: transparent;
            color: #ff6b6b;
            border-color: #ff6b6b;
        }

        .toss-modal-button.danger:hover {
            background: rgba(255, 107, 107, 0.2);
            box-shadow: 0 0 15px rgba(255, 107, 107, 0.4),
                4px 4px 0px rgba(0, 0, 0, 0.5);
            transform: translate(-2px, -2px);
        }

        .toss-modal-button.danger:active {
            transform: translate(2px, 2px);
            box-shadow: 2px 2px 0px rgba(0, 0, 0, 0.5);
        }

        /* 아이템 카드 스타일 */
        .item-card {
            background: linear-gradient(135deg, rgba(59, 7, 100, 0.6), rgba(88, 28, 135, 0.4));
            padding: 12px;
            padding-bottom: 38px;
            border-radius: 10px;
            border: 2px solid rgba(168, 85, 247, 0.5);
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 2px 8px rgba(88, 28, 135, 0.3);
            position: relative;
            min-height: 165px;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
        }

        .item-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(168, 85, 247, 0.5);
        }

        .item-card.equipped {
            border-color: #ffd700;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.6);
        }

        .item-card.common {
            border-color: #9ca3af;
            box-shadow: 0 0 12px rgba(156, 163, 175, 0.5), 0 0 25px rgba(156, 163, 175, 0.2);
        }

        .item-card.uncommon {
            border-color: #10b981;
            box-shadow: 0 0 18px rgba(16, 185, 129, 0.7), 0 0 35px rgba(16, 185, 129, 0.3);
        }

        .item-card.rare {
            border-color: #3b82f6;
            box-shadow: 0 0 22px rgba(59, 130, 246, 0.8), 0 0 45px rgba(59, 130, 246, 0.4);
        }

        .item-card.epic {
            border-color: #a855f7;
            box-shadow: 0 0 28px rgba(168, 85, 247, 0.9), 0 0 55px rgba(168, 85, 247, 0.5);
        }

        .item-card.legend {
            border-color: #f59e0b;
            box-shadow: 0 0 35px rgba(245, 158, 11, 1.0), 0 0 70px rgba(245, 158, 11, 0.6);
        }

        .item-icon {
            font-size: 36px;
            margin: 6px 0;
        }

        .equipped-slot .item-icon {
            font-size: 32px;
        }

        .item-name {
            font-weight: bold;
            margin-bottom: 6px;
            font-size: 14px;
            color: #e8d5f2;
        }

        .equipped-slot .item-name {
            font-size: 13px;
        }

        .item-rarity {
            font-size: 12px;
            margin-bottom: 6px;
            font-weight: bold;
        }

        .equipped-slot .item-rarity {
            font-size: 11px;
        }

        .equipped-slot .item-effect {
            font-size: 10px;
        }

        /* 모바일 화면에서 슬롯 크기 조정 */
        @media (max-width: 600px) {
            .equipped-slot {
                width: 100px;
                height: 140px;
                padding: 6px;
            }

            .equipped-slot .item-icon {
                font-size: 26px;
            }

            .equipped-slot .item-name {
                font-size: 11px;
            }

            .equipped-slot .item-rarity {
                font-size: 9px;
            }

            .equipped-slot .item-effect {
                font-size: 8px;
            }

            #equippedSlots {
                gap: 8px !important;
            }
        }

        .item-rarity.common {
            color: #9ca3af;
        }

        .item-rarity.uncommon {
            color: #10b981;
        }

        .item-rarity.rare {
            color: #3b82f6;
        }

        .item-rarity.epic {
            color: #a855f7;
        }

        .item-rarity.legend {
            color: #f59e0b;
        }

        .item-effect {
            font-size: 11px;
            color: #aaa;
            line-height: 1.4;
        }

        .equipped-slot {
            width: 130px;
            height: 170px;
            background: rgba(0, 0, 0, 0.3);
            border: 2px dashed #666;
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: #666;
            font-size: 12px;
            position: relative;
            padding: 10px;
        }

        .equipped-slot.filled {
            border: 2px solid #ffd700;
            background: linear-gradient(135deg, rgba(59, 7, 100, 0.6), rgba(88, 28, 135, 0.4));
        }

        .equipped-slot.filled.common {
            border-color: #9ca3af;
            box-shadow: 0 0 12px rgba(156, 163, 175, 0.5), 0 0 25px rgba(156, 163, 175, 0.2);
        }

        .equipped-slot.filled.uncommon {
            border-color: #10b981;
            box-shadow: 0 0 18px rgba(16, 185, 129, 0.7), 0 0 35px rgba(16, 185, 129, 0.3);
        }

        .equipped-slot.filled.rare {
            border-color: #3b82f6;
            box-shadow: 0 0 22px rgba(59, 130, 246, 0.8), 0 0 45px rgba(59, 130, 246, 0.4);
        }

        .equipped-slot.filled.epic {
            border-color: #a855f7;
            box-shadow: 0 0 28px rgba(168, 85, 247, 0.9), 0 0 55px rgba(168, 85, 247, 0.5);
        }

        .equipped-slot.filled.legend {
            border-color: #f59e0b;
            box-shadow: 0 0 35px rgba(245, 158, 11, 1.0), 0 0 70px rgba(245, 158, 11, 0.6);
        }

        .unequip-btn {
            position: absolute;
            top: 5px;
            right: 5px;
            width: 24px;
            height: 24px;
            background: rgba(233, 69, 96, 0.8);
            border: none;
            border-radius: 50%;
            color: white;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.3s;
            z-index: 10;
        }

        .unequip-btn:hover {
            background: rgba(233, 69, 96, 1);
        }

        .sell-btn {
            position: absolute;
            bottom: 8px;
            left: 8px;
            right: 8px;
            padding: 6px 8px;
            background: rgba(255, 193, 7, 0.9);
            border: none;
            border-radius: 5px;
            color: #1a1a2e;
            cursor: pointer;
            font-size: 11px;
            font-weight: bold;
            transition: all 0.3s;
            z-index: 10;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .sell-btn:hover {
            background: rgba(255, 193, 7, 1);
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(255, 193, 7, 0.5);
        }

        .close-button {
            background: linear-gradient(135deg, rgba(88, 28, 135, 0.9), rgba(59, 7, 100, 0.9));
            color: #e8d5f2;
            border: 2px solid rgba(168, 85, 247, 0.6);
            padding: 14px 40px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 20px;
            margin-top: 20px;
            font-weight: bold;
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.8);
            box-shadow: 0 4px 15px rgba(88, 28, 135, 0.4);
            transition: all 0.3s;
        }

        .close-button:hover {
            background: linear-gradient(135deg, rgba(109, 40, 217, 0.9), rgba(88, 28, 135, 0.9));
            border-color: rgba(168, 85, 247, 0.9);
            box-shadow: 0 6px 20px rgba(168, 85, 247, 0.6);
            transform: translateY(-2px);
        }

        .close-button:active {
            transform: translateY(0);
            box-shadow: 0 2px 10px rgba(88, 28, 135, 0.6);
        }

        /* 볼륨 슬라이더 스타일 */
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            height: 8px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 5px;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #4ecca3;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.2s;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            background: #5eead4;
            transform: scale(1.1);
        }

        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #4ecca3;
            border-radius: 50%;
            cursor: pointer;
            border: none;
            transition: all 0.2s;
        }

        input[type="range"]::-moz-range-thumb:hover {
            background: #5eead4;
            transform: scale(1.1);
        }

        #modeSelectScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #000000;
            color: white;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 40px 20px;
            z-index: 35;
        }

        #modeSelectScreen::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: url('assets/menu_bg.png');
            background-position: center;
            background-repeat: no-repeat;
            background-size: cover;
            z-index: 0;
        }

        #modeSelectScreen::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(180deg, rgba(26, 11, 41, 0.5) 0%, rgba(15, 8, 28, 0.7) 100%);
            z-index: 1;
        }

        #modeSelectScreen>* {
            position: relative;
            z-index: 2;
        }

        #modeSelectScreen h1 {
            color: #4ecca3;
            text-shadow: 0 0 20px rgba(78, 204, 163, 0.8),
                0 0 40px rgba(78, 204, 163, 0.6),
                4px 4px 8px rgba(0, 0, 0, 0.8);
            margin-bottom: 30px;
            font-size: 48px;
            letter-spacing: 4px;
            font-weight: bold;
            text-align: center;
        }

        .mode-buttons {
            display: flex;
            gap: 20px;
            margin: 0 auto 20px auto;
            width: 100%;
            max-width: 800px;
            justify-content: center;
        }

        .mode-button {
            flex: 1;
            padding: 30px 20px;
            background: linear-gradient(135deg, rgba(59, 7, 100, 0.6), rgba(88, 28, 135, 0.4));
            border: 3px solid rgba(168, 85, 247, 0.5);
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
            min-height: 200px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        .mode-button:hover {
            transform: translateY(-5px);
            box-shadow: 0 5px 20px rgba(168, 85, 247, 0.5);
            border-color: rgba(168, 85, 247, 0.8);
        }

        .mode-icon {
            font-size: 64px;
            margin-bottom: 15px;
        }

        .mode-name {
            font-size: 24px;
            font-weight: bold;
            color: #e8d5f2;
            margin-bottom: 10px;
            white-space: nowrap;
        }

        .mode-desc {
            font-size: 14px;
            color: #aaa;
        }

        #stageSelectScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #000000;
            color: white;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 40px 20px;
            z-index: 35;
            overflow-y: auto;
        }

        #stageSelectScreen::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: url('assets/menu_bg.png');
            background-position: center;
            background-repeat: no-repeat;
            background-size: cover;
            z-index: 0;
        }

        #stageSelectScreen::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(180deg, rgba(26, 11, 41, 0.5) 0%, rgba(15, 8, 28, 0.7) 100%);
            z-index: 1;
        }

        #stageSelectScreen>* {
            position: relative;
            z-index: 2;
        }

        #stageSelectScreen h1 {
            color: #4ecca3;
            text-shadow: 0 0 20px rgba(78, 204, 163, 0.8),
                0 0 40px rgba(78, 204, 163, 0.6),
                4px 4px 8px rgba(0, 0, 0, 0.8);
            margin-bottom: 30px;
            font-size: 48px;
            letter-spacing: 4px;
            font-weight: bold;
            text-align: center;
        }

        .stage-carousel-container {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 30px;
            margin: 40px auto;
            width: 100%;
            max-width: 900px;
            position: relative;
            z-index: 10;
        }

        .carousel-arrow {
            cursor: pointer;
            transition: all 0.3s;
            font-size: 72px;
            color: #4ecca3;
            text-shadow: 0 0 15px rgba(78, 204, 163, 0.7),
                3px 3px 6px rgba(0, 0, 0, 0.9);
            user-select: none;
            line-height: 1;
        }

        .carousel-arrow:hover {
            color: #5fffd4;
            text-shadow: 0 0 25px rgba(78, 204, 163, 1),
                3px 3px 6px rgba(0, 0, 0, 0.9);
            transform: scale(1.2);
        }

        .carousel-arrow:active {
            transform: scale(0.85);
        }

        .carousel-arrow.disabled {
            opacity: 0.2;
            cursor: not-allowed;
            pointer-events: none;
        }

        .stage-card {
            background: linear-gradient(135deg, rgba(59, 7, 100, 0.8), rgba(88, 28, 135, 0.6));
            padding: 20px;
            border-radius: 12px;
            border: 2px solid rgba(168, 85, 247, 0.6);
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(88, 28, 135, 0.4);
            text-align: center;
            width: 220px;
            min-height: 200px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        .stage-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 25px rgba(168, 85, 247, 0.6);
            border-color: rgba(168, 85, 247, 0.9);
        }

        .stage-card.locked {
            opacity: 0.5;
            cursor: not-allowed;
            border-color: #666;
        }

        .stage-card.locked:hover {
            transform: none;
            box-shadow: 0 4px 15px rgba(88, 28, 135, 0.4);
        }

        .stage-icon {
            width: 80px;
            height: 80px;
            margin-bottom: 15px;
            image-rendering: pixelated;
            object-fit: contain;
        }

        .stage-name {
            font-weight: bold;
            font-size: 20px;
            margin-bottom: 8px;
            color: #e8d5f2;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }

        .stage-number {
            font-size: 14px;
            color: #4ecca3;
            margin-bottom: 12px;
            font-weight: bold;
        }

        /* 모바일 대응 */
        @media (max-width: 768px) {
            .stage-carousel-container {
                gap: 15px;
            }

            .carousel-arrow {
                font-size: 60px;
            }

            .stage-card {
                width: 200px;
                min-height: 180px;
                padding: 18px;
            }

            .stage-icon {
                width: 70px;
                height: 70px;
            }

            .stage-name {
                font-size: 18px;
            }
        }

        #confirmModal {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 25px;
            border-radius: 15px;
            color: white;
            display: none;
            z-index: 30;
            min-width: 350px;
            max-width: 90%;
            max-height: 85vh;
            overflow-y: auto;
            border: 2px solid #4ecca3;
            text-align: left;
        }

        #confirmModal h3 {
            color: #4ecca3;
            margin-bottom: 15px;
            font-size: 22px;
            text-align: center;
            text-shadow: 0 0 10px rgba(78, 204, 163, 0.6);
        }

        .pause-stats-section {
            margin: 15px 0;
            padding: 12px;
            background: rgba(78, 204, 163, 0.1);
            border-left: 3px solid #4ecca3;
            border-radius: 5px;
        }

        .pause-stats-title {
            color: #4ecca3;
            font-size: 15px;
            font-weight: bold;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .pause-stat-item {
            color: #ddd;
            font-size: 13px;
            margin: 4px 0;
            padding-left: 8px;
        }

        .pause-stat-value {
            color: #ffd700;
            font-weight: bold;
        }

        .modal-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
        }

        .modal-btn {
            padding: 12px 30px;
            font-size: 16px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
        }

        .modal-btn-yes {
            background: #e94560;
            color: white;
        }

        .modal-btn-yes:active {
            background: #ff6b6b;
            transform: scale(0.95);
        }

        .modal-btn-no {
            background: #4ecca3;
            color: #1a1a2e;
        }

        .modal-btn-no:active {
            background: #5eead4;
            transform: scale(0.95);
        }

        /* 캐릭터 설명 모달 */
        #characterDescModal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            padding: 20px;
        }

        #characterDescModal .modal-content {
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            padding: 30px;
            border-radius: 15px;
            max-width: 500px;
            width: 100%;
            border: 2px solid #4ecca3;
            box-shadow: 0 0 30px rgba(78, 204, 163, 0.5);
        }

        #characterDescModal h2 {
            color: #4ecca3;
            margin-bottom: 20px;
            font-size: 24px;
            text-align: center;
        }

        #characterDescModal .desc-text {
            color: #ddd;
            line-height: 1.8;
            white-space: pre-line;
            margin-bottom: 20px;
            font-size: 14px;
        }

        #characterDescModal button {
            width: 100%;
            padding: 12px;
            background: #4ecca3;
            color: #1a1a2e;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
        }

        #characterDescModal button:hover {
            background: #5eead4;
            transform: scale(1.05);
        }
    </style>
</head>

<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>

        <div id="ui">
            <div class="stat-bar">
                <span class="stat-label">HP</span>
                <div class="bar-container">
                    <div class="bar-fill hp-bar" id="hpBar" style="width: 100%"></div>
                    <div class="bar-text"><span id="hp">500</span>/<span id="maxHp">500</span></div>
                </div>
            </div>
            <div class="stat-bar">
                <span class="stat-label">Lv.<span id="level">1</span></span>
                <div class="bar-container">
                    <div class="bar-fill xp-bar" id="xpBar" style="width: 0%"></div>
                    <div class="bar-text"><span id="xp">0</span>/<span id="xpNeeded">10</span></div>
                </div>
            </div>
        </div>

        <div id="timeUI" onclick="handleBossCheatTap()" style="cursor: pointer; user-select: none;">
            시간: <span id="time">0</span>s
        </div>

        <div id="goldUI">
            스크랩: <span id="goldAmount">0</span>
        </div>

        <div id="fpsCounter"
            style="position: absolute; top: 10px; right: 10px; color: #4ecca3; font-size: 14px; text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8); z-index: 10; display: none;">
            FPS: <span id="fpsValue">60</span>
        </div>

        <div id="homeButton" onclick="showConfirmModal()"></div>

        <div id="ultimateButton" onclick="useUltimate()">
            <img src="assets/Thunder.png" alt="Ultimate" />
            <div id="ultimateCooldown"></div>
        </div>

        <div id="confirmModal">
            <h3>게임 일시정지</h3>
            <div id="pauseStatsContainer"></div>
            <div class="modal-buttons">
                <button class="modal-btn modal-btn-no" onclick="closeConfirmModal()">계속하기</button>
                <button class="modal-btn modal-btn-yes" onclick="confirmGoHome()">메인 메뉴로</button>
            </div>
        </div>

        <!-- 에너지 부족 모달 -->
        <div id="energyDepletedModal"
            style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0, 0, 0, 0.95); padding: 30px; border-radius: 15px; text-align: center; color: white; display: none; z-index: 35; min-width: 300px; border: 2px solid #ff6b6b;">
            <!-- X 닫기 버튼 -->
            <button onclick="closeEnergyModal()"
                style="position: absolute; right: 10px; top: 10px; background: transparent; border: none; color: #aaa; font-size: 24px; cursor: pointer; width: 30px; height: 30px; line-height: 24px; padding: 0; transition: color 0.2s;"
                onmouseover="this.style.color='#fff'" onmouseout="this.style.color='#aaa'">×</button>

            <h3 style="color: #ff6b6b; margin-bottom: 20px; font-size: 20px;">에너지 부족</h3>
            <p style="margin-bottom: 25px; color: #aaa; font-size: 14px;">에너지가 부족합니다!<br>친구 초대하거나 광고를 보고 에너지를 충전하세요!</p>
            <div class="modal-buttons">
                <button class="modal-btn modal-btn-yes" onclick="inviteFriendsFromModal()">친구 초대</button>
                <button class="modal-btn modal-btn-no" onclick="watchAdForEnergy()" style="background: #ffa502;">광고 보고
                    충전</button>
            </div>
        </div>

        <div id="unlockModal"
            style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0, 0, 0, 0.95); padding: 30px; border-radius: 15px; text-align: center; color: white; display: none; z-index: 30; min-width: 300px; border: 2px solid #4ecca3;">
            <h3 style="color: #4ecca3; margin-bottom: 20px; font-size: 20px;">캐릭터 해금</h3>
            <p id="unlockModalText" style="margin-bottom: 25px; color: #aaa; font-size: 14px;"></p>
            <div class="modal-buttons">
                <button class="modal-btn modal-btn-yes" onclick="confirmUnlock()">예</button>
                <button class="modal-btn modal-btn-no" onclick="closeUnlockModal()">아니오</button>
            </div>
        </div>

        <div id="upgradeModal"
            style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0, 0, 0, 0.95); padding: 30px; border-radius: 15px; text-align: center; color: white; display: none; z-index: 40; min-width: 300px; border: 2px solid #4ecca3;">
            <h3 style="color: #4ecca3; margin-bottom: 20px; font-size: 20px;">캐릭터 강화</h3>
            <p id="upgradeModalText" style="margin-bottom: 25px; color: #aaa; font-size: 14px;"></p>
            <div class="modal-buttons">
                <button class="modal-btn modal-btn-yes" onclick="confirmUpgrade()">예</button>
                <button class="modal-btn modal-btn-no" onclick="closeUpgradeModal()">아니오</button>
            </div>
        </div>

        <!-- 디버그 패널 (개발자용) -->
        <div id="debugPanel"
            style="position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0, 0, 0, 0.98); padding: 25px; border-radius: 15px; color: white; display: none; z-index: 99999; min-width: 320px; max-width: 90vw; max-height: 90vh; overflow-y: auto; border: 3px solid #3182F6; font-family: 'Courier New', monospace;">
            <!-- X 닫기 버튼 -->
            <button onclick="closeDebugPanel()"
                style="position: absolute; right: 10px; top: 10px; background: transparent; border: none; color: #aaa; font-size: 24px; cursor: pointer; width: 30px; height: 30px; line-height: 24px; padding: 0; transition: color 0.2s;"
                onmouseover="this.style.color='#fff'" onmouseout="this.style.color='#aaa'">×</button>

            <h3 style="color: #3182F6; margin-bottom: 20px; font-size: 18px; text-align: center;">🔧 디버그 정보</h3>

            <div id="debugContent" style="font-size: 13px; line-height: 1.8; text-align: left;">
                <div style="margin-bottom: 15px;">
                    <div style="color: #ffa502; font-weight: bold; margin-bottom: 8px;">📱 환경 정보</div>
                    <div id="debugEnv" style="padding-left: 10px; color: #ddd;"></div>
                </div>

                <div style="margin-bottom: 15px;">
                    <div style="color: #4ecca3; font-weight: bold; margin-bottom: 8px;">✅ SDK 가용성</div>
                    <div id="debugSDK" style="padding-left: 10px; color: #ddd;"></div>
                </div>

                <div style="margin-bottom: 15px;">
                    <div style="color: #ff6b6b; font-weight: bold; margin-bottom: 8px;">🔍 상세 정보</div>
                    <div id="debugDetails" style="padding-left: 10px; color: #ddd; font-size: 11px;"></div>
                </div>
            </div>

            <button onclick="refreshDebugInfo()"
                style="width: 100%; padding: 12px; background: #3182F6; color: white; border: none; border-radius: 8px; font-size: 14px; cursor: pointer; margin-top: 15px; font-weight: bold;">
                🔄 새로고침
            </button>
        </div>

        <div id="loadingScreen">
            <div class="loading-content">
                <h1 class="loading-title">DRONE WAR</h1>
                <p class="loading-subtitle"
                    style="margin-top: 10px; font-size: 24px; color: #ff3333; font-weight: bold;">드론 워</p>
                <p class="loading-text">로딩중...</p>
                <div class="loading-bar-container">
                    <div class="loading-bar" id="loadingBar"></div>
                </div>
                <p class="loading-progress" id="loadingProgress">0%</p>
            </div>
        </div>

        <!-- 에너지 표시 (모든 화면 좌측 상단 고정, 인게임 제외) -->
        <div id="heartDisplay"
            style="position: fixed; top: 50px; left: 20px; color: white; font-size: 18px; z-index: 1000; display: none; text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);">
            <div style="display: flex; align-items: center; gap: 5px; margin-bottom: 5px;">
                <span style="font-size: 14px; color: #4ecca3; font-weight: bold;">에너지:</span>
                <div id="heartIcons" style="display: flex; gap: 3px;"></div>
            </div>
            <div id="heartTimer" style="font-size: 12px; color: #fff;"></div>
            <div id="supplyTicketDisplay" style="font-size: 14px; color: #ffd700; font-weight: bold; margin-top: 5px;">
                보급권: 0장</div>
            <div id="goldDisplayMenu"
                style="font-size: 14px; color: #ffd700; font-weight: bold; margin-top: 5px; display: flex; align-items: center; gap: 5px;">
                <img src="assets/Gear.png" style="width: 16px; height: 16px; image-rendering: pixelated;" />
                <span id="currentGoldMenu">0</span>
            </div>
        </div>

        <div id="mainMenu">
            <!-- 연령 등급 (우측 상단) -->
            <div style="position: absolute; top: 40px; right: 20px; z-index: 10;">
                <img src="assets/age-rating.png" style="width: 80px; height: auto;" alt="전체이용가">
            </div>
            <div class="menu-content">
                <h1 class="menu-title" id="gameTitle" onclick="handleTitleTap()">DRONE WAR</h1>
                <p class="menu-subtitle" style="font-size: 28px; color: #ff3333; font-weight: bold; margin-top: 10px;">
                    드론 워</p>
                <div class="menu-buttons">
                    <button class="menu-button" id="startGameButton" onclick="tryStartGame()">게임 시작</button>
                    <button class="menu-button" onclick="openInventoryFromMenu()">정비소</button>
                    <button class="menu-button" onclick="openShopFromMenu()">드론 변경</button>
                </div>
                <div
                    style="display: flex; gap: 15px; justify-content: center; margin-top: 15px; width: 240px; margin-left: auto; margin-right: auto;">
                    <button class="menu-icon-button" onclick="openTossLeaderboard()" style="flex: 1; width: auto;">
                        <img src="assets/trophy.png" style="width: 48px; height: 48px; image-rendering: pixelated;"
                            alt="리더보드">
                    </button>
                    <button class="menu-icon-button" onclick="openSettingsFromMenu()" style="flex: 1; width: auto;">
                        <img src="assets/Gear.png" style="width: 48px; height: 48px; image-rendering: pixelated;"
                            alt="설정">
                    </button>
                </div>
            </div>
        </div>

        <div id="modeSelectScreen">
            <div style="text-align: center; max-width: 800px; width: 100%;">
                <h1>모드 선택</h1>
                <div class="mode-buttons">
                    <div class="mode-button" onclick="selectMode('story')">
                        <img src="assets/Book.png"
                            style="width: 64px; height: 64px; margin-bottom: 10px; image-rendering: pixelated;" />
                        <div class="mode-name">스토리</div>
                        <div class="mode-desc">스테이지를 클리어하며<br>보스를 처치하세요</div>
                    </div>
                    <div class="mode-button" onclick="selectMode('endless')">
                        <img src="assets/infinite-icon.png"
                            style="width: 64px; height: 64px; margin-bottom: 10px; image-rendering: pixelated;" />
                        <div class="mode-name">무한</div>
                        <div class="mode-desc">끝없이 밀려오는 적들을<br>얼마나 버틸 수 있을까?</div>
                    </div>
                </div>
                <button class="close-button" onclick="closeModeSelect()">뒤로 가기</button>
            </div>
        </div>

        <div id="stageSelectScreen">
            <div style="text-align: center; max-width: 900px; width: 100%;">
                <h1>스테이지 선택</h1>
                <div class="stage-carousel-container">
                    <div class="carousel-arrow" id="prevStageArrow" onclick="prevStageCarousel()">◀</div>
                    <div id="stageCardContainer"></div>
                    <div class="carousel-arrow" id="nextStageArrow" onclick="nextStageCarousel()">▶</div>
                </div>
                <button class="close-button" onclick="closeStageSelect()">뒤로 가기</button>
            </div>
        </div>

        <div id="startScreen">
            <h1>DRONE WAR</h1>
            <p style="margin-top: 10px; font-size: 26px; color: #ff3333; font-weight: bold;">드론 워</p>
            <p style="margin-top: 20px;">PC: WASD 또는 화살표 키로 이동</p>
            <p>모바일: 화면을 터치하여 이동</p>
            <p>자동으로 적 드론을 공격합니다</p>
            <p>레벨업하면서 더 강해지세요!</p>

            <div class="best-records">
                <h3>개인 최고기록</h3>
                <div class="record-item">
                    <span class="record-label">⏱️ 최고 생존시간</span>
                    <span class="record-value"><span id="bestTimeDisplay">0</span>초</span>
                </div>
                <div class="record-item">
                    <span class="record-label">💥 최다 격추</span>
                    <span class="record-value"><span id="bestKillsDisplay">0</span>대</span>
                </div>
            </div>

            <div class="start-buttons">
                <button onclick="startGame()">게임 시작</button>
                <button class="icon-button" onclick="openShop()">드론 변경</button>
                <button class="icon-button" onclick="openSettingsFromMenu()">설정</button>
            </div>
        </div>

        <div id="shopScreen">
            <div style="text-align: center; max-width: 800px; width: 100%;">
                <h1>드론 변경</h1>
                <div class="gold-display" style="text-align: center;">보유 스크랩: <span id="shopGold">0</span></div>
                <div class="character-grid" id="characterGrid"></div>
                <button class="close-button" onclick="closeShop()">닫기</button>
            </div>
        </div>

        <!-- 캐릭터 상세 정보 모달 -->
        <div id="characterLoreModal" class="character-lore-modal" onclick="closeCharacterLore(event)">
            <div class="character-lore-content" onclick="event.stopPropagation()">
                <button class="character-lore-close" onclick="closeCharacterLore()">×</button>
                <div class="character-lore-header">
                    <div class="character-lore-icon" id="loreCharacterIcon"></div>
                    <div class="character-lore-title">
                        <div class="character-lore-name" id="loreCharacterName"></div>
                        <div class="character-lore-stats" id="loreCharacterStats"></div>
                    </div>
                </div>
                <div class="character-lore-ultimate">
                    <div class="character-lore-ultimate-title" id="loreUltimateTitle">필살기</div>
                    <div class="character-lore-ultimate-desc" id="loreUltimateDesc"></div>
                </div>
                <div class="character-lore-description" id="loreCharacterDesc"></div>
            </div>
        </div>

        <!-- Toss 스타일 모달 -->
        <div id="tossModal" class="toss-modal" onclick="closeTossModal(event)">
            <div class="toss-modal-content" onclick="event.stopPropagation()">
                <div class="toss-modal-header">
                    <h2 class="toss-modal-title" id="tossModalTitle"></h2>
                </div>
                <div class="toss-modal-body">
                    <p class="toss-modal-message" id="tossModalMessage"></p>
                </div>
                <div class="toss-modal-buttons" id="tossModalButtons">
                    <!-- 버튼들이 동적으로 추가됨 -->
                </div>
            </div>
        </div>

        <div id="settingsScreen">
            <div style="text-align: center; max-width: 500px; width: 100%;">
                <h1 id="settingsTitle" onclick="handleCheatTap()" style="cursor: pointer; user-select: none;">설정</h1>

                <div style="margin: 20px 0;">
                    <div style="margin-bottom: 25px;">
                        <label style="display: block; margin-bottom: 8px; font-size: 16px;">
                            마스터 볼륨: <span id="masterVolumeValue">100</span>%
                        </label>
                        <input type="range" id="masterVolumeSlider" min="0" max="100" value="100"
                            style="width: 100%; cursor: pointer;" oninput="handleVolumeChange('master', this.value)"
                            onchange="handleVolumeChange('master', this.value)">
                    </div>

                    <div style="margin-bottom: 25px;">
                        <label style="display: block; margin-bottom: 8px; font-size: 16px;">
                            배경음악: <span id="musicVolumeValue">100</span>%
                        </label>
                        <input type="range" id="musicVolumeSlider" min="0" max="100" value="100"
                            style="width: 100%; cursor: pointer;" oninput="handleVolumeChange('music', this.value)"
                            onchange="handleVolumeChange('music', this.value)">
                    </div>

                    <div style="margin-bottom: 25px;">
                        <label style="display: block; margin-bottom: 8px; font-size: 16px;">
                            효과음: <span id="sfxVolumeValue">100</span>%
                        </label>
                        <input type="range" id="sfxVolumeSlider" min="0" max="100" value="100"
                            style="width: 100%; cursor: pointer;" oninput="handleVolumeChange('sfx', this.value)"
                            onchange="handleVolumeChange('sfx', this.value)">
                    </div>
                </div>

                <button class="close-button" onclick="closeSettings()">닫기</button>
            </div>
        </div>

        <!-- 인벤토리 화면 -->
        <div id="inventoryScreen">
            <div style="text-align: center; max-width: 800px; width: 100%; padding: 10px 0;">
                <!-- 장착 슬롯 -->
                <div style="margin: 12px 0;">
                    <h3 style="color: #4ecca3; margin-bottom: 12px; font-size: 18px;">장착 중인 아이템</h3>
                    <div id="equippedSlots"
                        style="display: flex; gap: 12px; justify-content: center; flex-wrap: nowrap; margin-bottom: 15px;">
                    </div>
                </div>

                <!-- 인벤토리 -->
                <div style="margin-bottom: 15px;">
                    <h3 style="color: #4ecca3; margin-bottom: 12px; font-size: 18px;">보유 아이템 (<span
                            id="inventoryCount">0</span>/50)</h3>
                    <div id="inventoryGrid"
                        style="display: grid; grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); gap: 10px; max-height: 280px; overflow-y: auto; padding: 10px; background: rgba(0,0,0,0.3); border-radius: 10px;">
                    </div>
                </div>

                <!-- 보급 버튼 -->
                <div style="text-align: center; margin-bottom: 15px;">
                    <button id="gachaButtonInventory" onclick="performGachaInInventory()"
                        style="padding: 16px 40px; font-size: 18px; background: linear-gradient(135deg, #4ecca3, #2ecc71); color: #1a1a2e; border: none; border-radius: 12px; cursor: pointer; font-weight: bold; transition: all 0.3s; box-shadow: 0 5px 15px rgba(78, 204, 163, 0.4);">
                        보급받기
                    </button>
                    <!-- 보급 결과 -->
                    <div id="gachaResultInventory"
                        style="display: none; margin-top: 20px; padding: 20px; background: rgba(0,0,0,0.5); border-radius: 10px;">
                    </div>
                </div>

                <button class="close-button" onclick="closeInventory()">닫기</button>
            </div>
        </div>

        <!-- 뽑기 결과 팝업 -->
        <div id="gachaResultModal"
            style="display: none; position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: rgba(0, 0, 0, 0.9); z-index: 50; justify-content: center; align-items: center;">
            <div id="gachaResultCard"
                style="position: relative; max-width: 400px; width: 90%; padding: 40px; background: linear-gradient(135deg, #1a1a2e, #16213e); border-radius: 20px; text-align: center;">
                <!-- 내용은 JavaScript로 동적 생성 -->
            </div>
        </div>

        <div id="gameOver">
            <h1>게임 오버</h1>
            <p>생존 시간: <span id="finalTime">0</span>초</p>
            <p>격추한 드론: <span id="finalKills">0</span>대</p>
            <p>획득 스크랩: <span id="finalGold">0</span></p>

            <button onclick="restartGame()">다시 시작</button>
            <button onclick="goToMainMenu()" style="background: #4ecca3;">메인 메뉴</button>
            <!-- 보상형 광고 부활 버튼 -->
            <button id="reviveButton" onclick="watchAdToRevive()"
                style="background: #ff6b6b; color: white; margin: 10px auto; width: fit-content; display: none;">
                광고보고 부활
            </button>
        </div>

        <div id="levelUp">
            <h2>레벨 업! 업그레이드를 선택하세요</h2>
            <div id="upgradeOptions"></div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // 드론 스프라이트시트 로드 (캐릭터별)
        const droneSprites = {};
        const droneIds = ['default', 'warrior', 'mage', 'archer', 'tank', 'ninja'];
        const droneFiles = ['assets/drone_spritesheet.png', 'assets/SP-02.png', 'assets/SP-03.png', 'assets/SP-04.png', 'assets/SP-05.png', 'assets/SP-06.png'];

        droneIds.forEach((id, index) => {
            const sprite = new Image();
            sprite.src = droneFiles[index];
            sprite.onload = () => {
                console.log(`${droneFiles[index]} loaded successfully`);
            };
            sprite.onerror = () => {
                console.error(`Failed to load ${droneFiles[index]}`);
            };
            droneSprites[id] = sprite;
        });

        // 기본 드론 스프라이트 (하위 호환성)
        const droneSprite = droneSprites['default'];
        let droneSpriteLoaded = true;

        // 적 스프라이트 로드 - 새로운 우주선 스프라이트
        // 스테이지별 적 스프라이트 로드
        const enemySprites = {};
        const enemySpriteLoaded = {};

        // 스테이지 1 적 스프라이트
        for (let i = 1; i <= 3; i++) {
            for (let j = 1; j <= 3; j++) {
                const key = `stage${i}_enemy${j}`;
                enemySprites[key] = new Image();
                enemySprites[key].src = `assets/Stage${i}Enemy${j}.png`;
                enemySpriteLoaded[key] = false;
                enemySprites[key].onload = () => {
                    enemySpriteLoaded[key] = true;
                    console.log(`Stage${i}Enemy${j}.png loaded successfully`);
                };
                enemySprites[key].onerror = () => {
                    console.error(`Failed to load Stage${i}Enemy${j}.png`);
                };
            }
        }

        // 하위 호환성을 위한 참조 (Stage1 적들)
        const enemySprite = enemySprites['stage1_enemy1'];
        const enemyPurpleSprite = enemySprites['stage1_enemy2'];
        const enemy2Sprite = enemySprites['stage1_enemy3'];

        // 보스 스프라이트 로드
        const bossSprites = {};
        const bossSpriteLoaded = {};
        for (let i = 1; i <= 3; i++) {
            const key = `stage${i}`;
            bossSprites[key] = new Image();
            bossSprites[key].src = `assets/Stage${i}Boss.png`;
            bossSpriteLoaded[key] = false;
            bossSprites[key].onload = () => {
                bossSpriteLoaded[key] = true;
                console.log(`Stage${i}Boss.png loaded successfully`);
            };
            bossSprites[key].onerror = () => {
                console.error(`Failed to load Stage${i}Boss.png`);
            };
        }

        // 하위 호환성을 위한 참조
        const bossSprite = bossSprites['stage1'];

        // 배경 이미지 로드 (스테이지별)
        const backgroundSprites = {};
        const stage1Background = new Image();
        stage1Background.src = 'assets/Stage1Background.png';
        stage1Background.onload = () => {
            console.log('Stage1Background.png loaded successfully');
        };
        stage1Background.onerror = () => {
            console.error('Failed to load Stage1Background.png');
        };
        backgroundSprites[1] = stage1Background;

        const stage2Background = new Image();
        stage2Background.src = 'assets/Stage2Background.png';
        stage2Background.onload = () => {
            console.log('Stage2Background.png loaded successfully');
        };
        stage2Background.onerror = () => {
            console.error('Failed to load Stage2Background.png');
        };
        backgroundSprites[2] = stage2Background;

        const stage3Background = new Image();
        stage3Background.src = 'assets/Stage3Background.png';
        stage3Background.onload = () => {
            console.log('Stage3Background.png loaded successfully');
        };
        stage3Background.onerror = () => {
            console.error('Failed to load Stage3Background.png');
        };
        backgroundSprites[3] = stage3Background;

        // 기본 배경 스프라이트 (하위 호환성)
        const backgroundSprite = stage1Background;
        let backgroundSpriteLoaded = true;

        // XP 아이콘 로드 (경험치 오브용)
        const xpSprite = new Image();
        xpSprite.src = 'assets/XP.png';
        let xpSpriteLoaded = false;
        xpSprite.onload = () => {
            xpSpriteLoaded = true;
            console.log('XP.png loaded successfully');
        };
        xpSprite.onerror = () => {
            console.error('Failed to load XP.png');
        };

        // 기어 아이콘 로드 (골드 오브용)
        const gearSprite = new Image();
        gearSprite.src = 'assets/Gear.png';
        let gearSpriteLoaded = false;
        gearSprite.onload = () => {
            gearSpriteLoaded = true;
            console.log('Gear.png loaded successfully');
        };
        gearSprite.onerror = () => {
            console.error('Failed to load Gear.png');
        };

        // 총알 스프라이트 로드
        const bulletSprite = new Image();
        bulletSprite.src = 'assets/Bullet.png';
        let bulletSpriteLoaded = false;
        bulletSprite.onload = () => {
            bulletSpriteLoaded = true;
            console.log('Bullet.png loaded successfully');
        };
        bulletSprite.onerror = () => {
            console.error('Failed to load Bullet.png');
        };

        // 유도탄 스프라이트 로드
        const guidedMissileSprite = new Image();
        guidedMissileSprite.src = 'assets/guidedMissile.png';
        let guidedMissileSpriteLoaded = false;
        guidedMissileSprite.onload = () => {
            guidedMissileSpriteLoaded = true;
            console.log('guidedMissile.png loaded successfully');
        };
        guidedMissileSprite.onerror = () => {
            console.error('Failed to load guidedMissile.png');
        };

        // 적 투사체 스프라이트 로드
        const enemyBallSprite = new Image();
        enemyBallSprite.src = 'assets/EnemyBall.png';
        let enemyBallSpriteLoaded = false;
        enemyBallSprite.onload = () => {
            enemyBallSpriteLoaded = true;
            console.log('EnemyBall.png loaded successfully');
        };
        enemyBallSprite.onerror = () => {
            console.error('Failed to load EnemyBall.png');
        };

        // 미니 드론 스프라이트 로드
        const miniDroneSprite = new Image();
        miniDroneSprite.src = 'assets/minidrone.png';
        let miniDroneSpriteLoaded = false;
        miniDroneSprite.onload = () => {
            miniDroneSpriteLoaded = true;
            console.log('minidrone.png loaded successfully');
        };
        miniDroneSprite.onerror = () => {
            console.error('Failed to load minidrone.png');
        };

        // 배경 스크롤 변수
        let backgroundY1 = 0;
        let backgroundY2 = 0;
        let backgroundScrollSpeed = 1; // 배경 스크롤 속도

        // 애니메이션 변수 (30FPS = 33.33ms마다 프레임 전환)
        let animationFrame = 0;
        let animationTimer = 0;
        const animationFrameCount = 4;
        const animationSpeed = 33.33; // 30 FPS
        const frameWidth = 64;
        const frameHeight = 64;

        // 유틸리티 함수: 점에서 선분까지의 최단 거리 계산
        function pointToLineDistance(px, py, x1, y1, x2, y2) {
            const A = px - x1;
            const B = py - y1;
            const C = x2 - x1;
            const D = y2 - y1;

            const dot = A * C + B * D;
            const lenSq = C * C + D * D;
            let param = -1;

            if (lenSq !== 0) {
                param = dot / lenSq;
            }

            let xx, yy;

            if (param < 0) {
                xx = x1;
                yy = y1;
            } else if (param > 1) {
                xx = x2;
                yy = y2;
            } else {
                xx = x1 + param * C;
                yy = y1 + param * D;
            }

            const dx = px - xx;
            const dy = py - yy;
            return Math.sqrt(dx * dx + dy * dy);
        }

        function resizeCanvas() {
            const containerWidth = window.innerWidth;
            const containerHeight = window.innerHeight;
            const dpr = window.devicePixelRatio || 1;

            canvas.width = containerWidth * dpr;
            canvas.height = containerHeight * dpr;
            canvas.style.width = containerWidth + 'px';
            canvas.style.height = containerHeight + 'px';

            ctx.scale(dpr, dpr);
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        let gameStarted = false;
        let gameRunning = false;
        let gameLoopId = 0;  // 게임 루프 중복 실행 방지용 ID
        let settingsOpenedFrom = 'menu';  // 설정을 어디서 열었는지 추적 ('menu' 또는 'game')
        let isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        let sizeScale = isMobile ? 1.56 : 1.95;  // 적 크기 30% 증가 (모바일 1.56배, PC 1.95배)
        let playerSizeScale = isMobile ? 2.25 : 3.375;  // 플레이어 크기 1.5배 증가 (모바일 2.25배, PC 3.375배)

        // 화면 흔들림 변수
        let shakeIntensity = 0;  // 현재 흔들림 강도
        let shakeX = 0;          // X축 흔들림 오프셋
        let shakeY = 0;          // Y축 흔들림 오프셋

        const player = {
            x: 0,
            y: 0,
            size: 8,  // 히트박스는 작게 고정 (시각적 크기와 분리)
            visualSize: 8 * playerSizeScale,  // 시각적 표시 크기 (실제 보이는 크기)
            speed: 4.5,
            hp: 200,  // 60% 감소 (500 → 200)
            maxHp: 200,  // 60% 감소 (500 → 200)
            xp: 0,
            level: 1,
            xpNeeded: 10
        };

        // Spatial Hash Grid for collision optimization
        class SpatialGrid {
            constructor(cellSize = 100) {
                this.cellSize = cellSize;
                this.grid = new Map();
            }

            clear() {
                this.grid.clear();
            }

            getKey(x, y) {
                const cellX = Math.floor(x / this.cellSize);
                const cellY = Math.floor(y / this.cellSize);
                return `${cellX},${cellY}`;
            }

            insert(obj) {
                const key = this.getKey(obj.x, obj.y);
                if (!this.grid.has(key)) {
                    this.grid.set(key, []);
                }
                this.grid.get(key).push(obj);
            }

            getNearby(x, y, range = 1) {
                const nearby = [];
                const centerCellX = Math.floor(x / this.cellSize);
                const centerCellY = Math.floor(y / this.cellSize);

                for (let dx = -range; dx <= range; dx++) {
                    for (let dy = -range; dy <= range; dy++) {
                        const key = `${centerCellX + dx},${centerCellY + dy}`;
                        const cell = this.grid.get(key);
                        if (cell) {
                            nearby.push(...cell);
                        }
                    }
                }
                return nearby;
            }
        }

        const enemyGrid = new SpatialGrid(150);

        // Object Pool for performance
        class ObjectPool {
            constructor(createFn, resetFn, initialSize = 50) {
                this.createFn = createFn;
                this.resetFn = resetFn;
                this.pool = [];
                this.active = [];

                // Pre-allocate objects
                for (let i = 0; i < initialSize; i++) {
                    this.pool.push(createFn());
                }
            }

            get(...args) {
                let obj;
                if (this.pool.length > 0) {
                    obj = this.pool.pop();
                } else {
                    obj = this.createFn();
                }
                this.resetFn(obj, ...args);
                this.active.push(obj);
                return obj;
            }

            release(obj) {
                const index = this.active.indexOf(obj);
                if (index > -1) {
                    this.active.splice(index, 1);
                    this.pool.push(obj);
                }
            }

            clear() {
                this.pool.push(...this.active);
                this.active = [];
            }
        }

        // Projectile pool
        const projectilePool = new ObjectPool(
            () => ({ x: 0, y: 0, vx: 0, vy: 0, size: 5, damage: 0, piercing: 0, hitCount: 0 }),
            (obj, x, y, vx, vy, damage, piercing) => {
                obj.x = x;
                obj.y = y;
                obj.vx = vx;
                obj.vy = vy;
                obj.damage = damage;
                obj.piercing = piercing;
                obj.hitCount = 0;
            },
            100
        );

        const keys = {};
        const enemies = [];
        const projectiles = [];
        const missiles = [];
        const lightnings = [];
        const enemyProjectiles = [];
        const xpOrbs = [];
        const goldOrbs = [];
        const meleeWeapons = [];

        // 모바일 성능 최적화: 파티클 최대 개수 제한
        const MAX_PROJECTILES = 150;
        const MAX_MISSILES = 30;
        const MAX_LIGHTNINGS = 10;
        const MAX_ENEMY_PROJECTILES = 100;
        const MAX_XP_ORBS = 300;  // 3배 증가 (100 → 300) - 아이템이 더 오래 유지됨
        const MAX_GOLD_ORBS = 150;  // 3배 증가 (50 → 150) - 아이템이 더 오래 유지됨

        let kills = 0;
        let gameTime = 0;
        let lastTime = Date.now();
        let shootTimer = 0;
        const shootCooldown = 350;

        let totalGold = 0;
        let currentGold = 0;

        // 개인 최고기록
        let bestTime = 0;
        let bestKills = 0;

        // 오디오 설정
        let masterVolume = 1.0;
        let musicVolume = 0.3;  // 배경음악 30%
        let sfxVolume = 0.8;    // 효과음 80% (Web Audio API에서 증폭)

        // Web Audio API for SFX and BGM volume control
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();

        // GainNode for music volume control (모바일 호환)
        const musicGainNode = audioContext.createGain();
        musicGainNode.connect(audioContext.destination);
        musicGainNode.gain.value = 1.0;

        function playSFX(type) {
            if (sfxVolume === 0 || masterVolume === 0) return;

            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            const volume = masterVolume * sfxVolume * 0.5;  // 효과음 증폭
            gainNode.gain.setValueAtTime(volume, audioContext.currentTime);

            switch (type) {
                case 'hit':
                    oscillator.type = 'square';
                    oscillator.frequency.setValueAtTime(200, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(50, audioContext.currentTime + 0.1);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.1);
                    break;

                case 'shoot':
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(440, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(220, audioContext.currentTime + 0.05);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.05);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.05);
                    break;

                case 'levelup':
                    // upgrade.wav 파일 재생
                    upgradeSfx.volume = volume;
                    upgradeSfx.currentTime = 0; // 처음부터 재생
                    upgradeSfx.play().catch(err => console.warn('레벨업 사운드 재생 실패:', err));
                    return; // oscillator 사용 안 함

                case 'bossdeath':
                    oscillator.type = 'sawtooth';
                    oscillator.frequency.setValueAtTime(200, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(50, audioContext.currentTime + 0.5);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.5);
                    break;

                case 'explosion':
                    const noise = audioContext.createBufferSource();
                    const bufferSize = audioContext.sampleRate * 0.2;
                    const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
                    const data = buffer.getChannelData(0);
                    for (let i = 0; i < bufferSize; i++) {
                        data[i] = Math.random() * 2 - 1;
                    }
                    noise.buffer = buffer;
                    noise.connect(gainNode);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                    noise.start(audioContext.currentTime);
                    noise.stop(audioContext.currentTime + 0.2);
                    break;
            }
        }

        // BGM 로드 (각 BGM마다 독립적인 GainNode로 충돌 방지)
        const mainBgm = new Audio('assets/bgm/MainBgm.mp3');
        mainBgm.loop = true;
        mainBgm.preload = 'auto';
        const mainBgmGain = audioContext.createGain();
        const mainBgmSource = audioContext.createMediaElementSource(mainBgm);
        mainBgmSource.connect(mainBgmGain);
        mainBgmGain.connect(audioContext.destination);

        const stage1Bgm = new Audio('assets/bgm/Stage1Bgm.mp3');
        stage1Bgm.loop = true;
        stage1Bgm.preload = 'auto';
        const stage1BgmGain = audioContext.createGain();
        const stage1BgmSource = audioContext.createMediaElementSource(stage1Bgm);
        stage1BgmSource.connect(stage1BgmGain);
        stage1BgmGain.connect(audioContext.destination);

        const stage2Bgm = new Audio('assets/bgm/Stage2Bgm.mp3');
        stage2Bgm.loop = true;
        stage2Bgm.preload = 'auto';
        const stage2BgmGain = audioContext.createGain();
        const stage2BgmSource = audioContext.createMediaElementSource(stage2Bgm);
        stage2BgmSource.connect(stage2BgmGain);
        stage2BgmGain.connect(audioContext.destination);

        const stage3Bgm = new Audio('assets/bgm/Stage3Bgm.mp3');
        stage3Bgm.loop = true;
        stage3Bgm.preload = 'auto';
        const stage3BgmGain = audioContext.createGain();
        const stage3BgmSource = audioContext.createMediaElementSource(stage3Bgm);
        stage3BgmSource.connect(stage3BgmGain);
        stage3BgmGain.connect(audioContext.destination);

        // 레벨업 SFX 로드
        const upgradeSfx = new Audio('assets/bgm/upgrade.wav');
        upgradeSfx.preload = 'auto';

        // BGM GainNode 맵핑
        const bgmGainMap = new Map([
            [mainBgm, mainBgmGain],
            [stage1Bgm, stage1BgmGain],
            [stage2Bgm, stage2BgmGain],
            [stage3Bgm, stage3BgmGain]
        ]);

        const bossExplosionSound = new Audio('assets/bgm/403296__lilmati__retro-explosion-04.wav');
        bossExplosionSound.volume = masterVolume * sfxVolume;

        const ultimateSound = new Audio('assets/bgm/459150__lilmati__retro-underwater-explosion.wav');
        ultimateSound.volume = masterVolume * sfxVolume;

        let currentBgm = null;

        // ==================== 에너지 시스템 ====================
        class HeartSystem {
            constructor(userKey) {
                this.userKey = userKey;
                this.maxHearts = 5;
                this.recoveryTimeMs = 30 * 60 * 1000; // 30분
                this.costPerGame = 1;
                this.storageKey = `hearts_${userKey}`;
                this.data = this.load();
                this.startRecoveryTimer();
            }

            load() {
                try {
                    const stored = localStorage.getItem(this.storageKey);
                    if (stored) {
                        const data = JSON.parse(stored);
                        // 경과 시간만큼 에너지 회복
                        this.recoverHearts(data);
                        return data;
                    }
                } catch (error) {
                    console.error('에너지 로드 실패:', error);
                }

                // 기본값: 최대 에너지로 시작
                return {
                    hearts: this.maxHearts,
                    lastRecoveryTime: Date.now()
                };
            }

            save() {
                try {
                    localStorage.setItem(this.storageKey, JSON.stringify(this.data));
                } catch (error) {
                    console.error('에너지 저장 실패:', error);
                }
            }

            recoverHearts(data) {
                if (data.hearts >= this.maxHearts) {
                    data.lastRecoveryTime = Date.now();
                    return;
                }

                const elapsed = Date.now() - data.lastRecoveryTime;
                const recoveredCount = Math.floor(elapsed / this.recoveryTimeMs);

                if (recoveredCount > 0) {
                    data.hearts = Math.min(this.maxHearts, data.hearts + recoveredCount);
                    data.lastRecoveryTime += recoveredCount * this.recoveryTimeMs;
                }
            }

            getHearts() {
                return this.data.hearts;
            }

            hasHeart() {
                return this.data.hearts > 0;
            }

            useHeart() {
                if (!this.hasHeart()) {
                    return false;
                }

                this.data.hearts--;

                // 첫 에너지 사용 시 회복 타이머 시작
                if (this.data.hearts === this.maxHearts - 1) {
                    this.data.lastRecoveryTime = Date.now();
                }

                this.save();
                this.notifyUpdate();
                return true;
            }

            addHearts(amount) {
                this.data.hearts = Math.min(this.maxHearts, this.data.hearts + amount);
                this.save();
                this.notifyUpdate();
                console.log(`✅ 에너지 ${amount}개 충전됨! 현재: ${this.data.hearts}/${this.maxHearts}`);
            }

            getTimeUntilNextHeart() {
                if (this.data.hearts >= this.maxHearts) {
                    return 0;
                }

                const elapsed = Date.now() - this.data.lastRecoveryTime;
                const remaining = this.recoveryTimeMs - (elapsed % this.recoveryTimeMs);
                return remaining;
            }

            formatTime(ms) {
                const minutes = Math.floor(ms / 60000);
                const seconds = Math.floor((ms % 60000) / 1000);
                return `${minutes}:${seconds.toString().padStart(2, '0')}`;
            }

            startRecoveryTimer() {
                setInterval(() => {
                    if (this.data.hearts < this.maxHearts) {
                        this.recoverHearts(this.data);
                        this.save();
                        this.notifyUpdate();
                    }
                }, 1000); // 1초마다 체크
            }

            notifyUpdate() {
                // UI 업데이트 이벤트 발생
                window.dispatchEvent(new CustomEvent('heartsUpdated', {
                    detail: {
                        hearts: this.data.hearts,
                        max: this.maxHearts,
                        timeUntilNext: this.getTimeUntilNextHeart()
                    }
                }));
            }

            reset() {
                this.data = {
                    hearts: this.maxHearts,
                    lastRecoveryTime: Date.now()
                };
                this.save();
                this.notifyUpdate();
            }
        }

        // 전역 에너지 시스템 (초기화는 나중에)
        let heartSystem = null;

        // ==================== 게임 상수 정의 ====================
        const GAME_CONSTANTS = {
            // 필살기 쿨다운 및 지속시간
            ULTIMATE_COOLDOWN: 30000,           // 30초
            VIPER_STUN_DURATION: 4000,          // 4초
            FALCON_SHIELD_DURATION: 10000,      // 10초
            CRANE_CLONE_DURATION: 7000,         // 7초
            RHINO_WAVE_DELAY: 500,              // 0.5초
            RHINO_MAX_WAVES: 3,
            SPECTER_PULL_DURATION: 3000,        // 3초
            SPECTER_COMPRESS_DURATION: 1000,    // 1초
            SPECTER_RADIUS: 400,
            PHANTOM_LASER_DURATION: 3000,       // 3초
            PHANTOM_COOLDOWN: 35000,            // 35초

            // 캐릭터 가격
            CHAR_PRICE_FALCON: 10000,
            CHAR_PRICE_CRANE: 15000,
            CHAR_PRICE_RHINO: 20000,
            CHAR_PRICE_SPECTER: 25000,
            CHAR_PRICE_PHANTOM: 30000,

            // 강화 시스템
            UPGRADE_BASE_COST: 1000,
            UPGRADE_COST_MULTIPLIER: 1.5,
            UPGRADE_STAT_MULTIPLIER: 0.1,       // 레벨당 10% 증가
            MAX_UPGRADE_LEVEL: 9,
        };

        // 캐릭터 이미지 매핑 (중복 제거)
        const CHARACTER_IMAGE_PATHS = {
            'default': 'assets/NormalDrone.png',
            'warrior': 'assets/SP-02.png',
            'mage': 'assets/SP-03.png',
            'archer': 'assets/SP-04.png',
            'tank': 'assets/SP-05.png',
            'ninja': 'assets/SP-06.png'
        };

        // 캐릭터 이미지 가져오기 헬퍼 함수
        function getCharacterImagePath(charId) {
            return CHARACTER_IMAGE_PATHS[charId] || null;
        }

        const characters = [
            {
                id: 'default',
                name: 'SP-01 Viper',
                icon: '🛩️',
                unlocked: true,
                price: 0,
                upgradeLevel: 0,
                stats: { hp: 200, speed: 4.5, damage: 30 },
                ultimate: '플라즈마 폭풍: 4초간 모든 적 스턴',
                description: '【기원】\n세계 연합군이 최초로 양산한 1세대 전투 드론입니다. 수많은 전장에서 검증된 균형잡힌 설계로 "전장의 만능 해결사"라 불립니다.\n\n【전술 특성】\n안정적인 기동성과 화력의 조화. 어떤 상황에서도 믿을 수 있는 범용성이 강점입니다.\n\n【필살기: 플라즈마 폭풍】\n고전압 플라즈마 에너지를 방출하여 4초간 주변 모든 적의 전자 시스템을 무력화시킵니다.'
            },
            {
                id: 'warrior',
                name: 'SP-02 Falcon',
                icon: '✈️',
                unlocked: false,
                price: GAME_CONSTANTS.CHAR_PRICE_FALCON,
                upgradeLevel: 0,
                stats: { hp: 250, speed: 4.5, damage: 40 },
                ultimate: '철벽 보호막: 10초간 무적 상태',
                description: '【기원】\n독일 특수부대 GSG-9와 공동 개발한 중거리 타격 전문 드론. "철의 독수리"라는 코드네임으로 유럽 전선을 지켜냈습니다.\n\n【전술 특성】\n강화된 장갑과 화력으로 중거리에서 압도적인 화력 투사가 가능합니다. 방어와 공격의 균형이 뛰어납니다.\n\n【필살기: 철벽 보호막】\n10초간 완전한 무적 상태가 됩니다. 어떤 공격도 통하지 않는 절대 방어 시스템을 전개하여 최전방에서 버텨냅니다.'
            },
            {
                id: 'mage',
                name: 'SP-03 Crane',
                icon: '🛫',
                unlocked: false,
                price: GAME_CONSTANTS.CHAR_PRICE_CRANE,
                upgradeLevel: 0,
                stats: { hp: 300, speed: 4.5, damage: 50 },
                ultimate: '홀로그램 클론: 7초간 분신 생성',
                description: '【기원】\n미국 국방부 첨단연구계획국(DARPA)에서 극비리에 개발한 차세대 전자전 드론. 홀로그램 기술과 EMP 무기를 탑재하여 "전장의 환영"이라 불립니다.\n\n【전술 특성】\n최첨단 기술의 집약체. 낮은 내구도를 압도적 화력과 전술적 기만으로 보완합니다. 고숙련 파일럿에게 추천됩니다.\n\n【필살기: 홀로그램 클론】\n홀로그램 분신을 7초간 생성하여 일시적으로 두 배의 화력을 발휘합니다. 분신도 동일한 공격 능력을 가지고 있어 화력이 2배로 증가합니다.'
            },
            {
                id: 'archer',
                name: 'SP-04 Rhino',
                icon: '🚁',
                unlocked: false,
                price: GAME_CONSTANTS.CHAR_PRICE_RHINO,
                upgradeLevel: 0,
                stats: { hp: 350, speed: 4.5, damage: 35 },
                ultimate: '방사형 폭발: 360° 직선 공격 3회 (즉사)',
                description: '【기원】\n러시아 군사기술연구소에서 개발한 중화력 폭격 드론. 시베리아 작전에서 단 1기로 적 부대 전체를 섬멸하며 "붉은 심판자"라는 전설을 만들었습니다.\n\n【전술 특성】\n폭발 무기 전문가들이 설계한 파괴의 예술품. 한 번의 공격으로 전장의 판도를 뒤집는 압도적 파괴력이 특징입니다.\n\n【필살기: 방사형 폭발】\n360도 전방향으로 3차례의 직선 폭격을 발사합니다. 범위 내 모든 적은 회피 불가능한 즉사 판정을 받게 됩니다.'
            },
            {
                id: 'tank',
                name: 'SP-05 Specter',
                icon: '🚀',
                unlocked: false,
                price: GAME_CONSTANTS.CHAR_PRICE_SPECTER,
                upgradeLevel: 0,
                stats: { hp: 400, speed: 4.5, damage: 25 },
                ultimate: '중력 붕괴: 전방에 중력장 발사 후 폭발',
                description: '【기원】\n프랑스 우주항공연구소(CNES)가 우주 전쟁을 대비해 개발한 실험형 중력 제어 드론. 블랙홀 이론을 무기화한 인류 최초의 중력병기로 "어비스"라 명명되었습니다.\n\n【전술 특성】\n압도적인 방어력으로 최전방을 담당합니다. 적의 공격을 받아내며 아군을 지키는 불굴의 요새입니다.\n\n【필살기: 중력 붕괴】\n인공 중력장을 전방으로 발사하여 적들을 한 곳으로 끌어당긴 후, 중력을 반전시켜 강력한 폭발로 섬멸합니다. 과학이 만든 블랙홀입니다.'
            },
            {
                id: 'ninja',
                name: 'SP-06 Phantom',
                icon: '🛸',
                unlocked: false,
                price: GAME_CONSTANTS.CHAR_PRICE_PHANTOM,
                upgradeLevel: 0,
                stats: { hp: 450, speed: 4.5, damage: 45 },
                ultimate: '쌍검 레이저: 3초간 회전 레이저',
                description: '【기원】\n일본 방위성 특수기술연구본부가 닌자의 전술을 AI에 학습시켜 탄생시킨 암살 전문 드론. 400년 전통의 인술(忍術)과 최첨단 기술의 융합체로 "무음의 사신"이라 두려움의 대상입니다.\n\n【전술 특성】\n최소한의 장갑으로 극한의 기동성을 확보. 빠른 공격과 회피로 적을 농락하는 고난이도 기체입니다.\n\n【필살기: 쌍검 레이저】\n드론 주변에 쌍검 형태의 고출력 레이저가 3초간 회전하며 접근하는 모든 적을 단숨에 베어버립니다. 피할 수 없는 일격필살의 검무입니다.'
            }
        ];

        // ==================== 아이템 시스템 ====================

        // 아이템 등급별 확률 및 효과 배율
        const ITEM_RARITY = {
            common: { name: '일반', color: '#9ca3af', chance: 0.50, multiplier: 1.0 },
            uncommon: { name: '고급', color: '#10b981', chance: 0.30, multiplier: 1.3 },
            rare: { name: '희귀', color: '#3b82f6', chance: 0.15, multiplier: 1.6 },
            epic: { name: '영웅', color: '#a855f7', chance: 0.04, multiplier: 2.0 },
            legend: { name: '전설', color: '#f59e0b', chance: 0.01, multiplier: 3.0 }
        };

        // 아이템 데이터베이스 (기획서 기반 35종)
        const ITEMS_DATABASE = [
            // 공격 계열 (10종)
            { id: 'aim_computer', name: '조준 컴퓨터', category: 'attack', icon: 'assets/item/조준 컴퓨터.png', baseEffect: { projectileDamage: 0.15 }, desc: '투사체 데미지 +{value}%' },
            { id: 'high_explosive', name: '고폭탄두', category: 'attack', icon: 'assets/item/고폭탄두.png', baseEffect: { missileDamage: 0.20 }, desc: '미사일 데미지 +{value}%' },
            { id: 'emp_amplifier', name: 'EMP 증폭기', category: 'attack', icon: 'assets/item/EMP 증폭기.png', baseEffect: { empRange: 0.25 }, desc: 'EMP 범위 +{value}%' },
            { id: 'satellite_module', name: '위성 강화 모듈', category: 'attack', icon: 'assets/item/위성 강화 모듈.png', baseEffect: { satelliteDamage: 0.30 }, desc: '위성 공격 데미지 +{value}%' },
            { id: 'multi_launcher', name: '다연장 로켓', category: 'attack', icon: 'assets/item/다연장 로켓.png', baseEffect: { projectileCount: 1 }, desc: '투사체 개수 +{value}' },
            { id: 'guidance_system', name: '유도 시스템', category: 'attack', icon: 'assets/item/유도 시스템.png', baseEffect: { missilePiercing: 1 }, desc: '미사일 관통 +{value}' },
            { id: 'pierce_warhead', name: '관통 탄두', category: 'attack', icon: 'assets/item/관통 탄두.png', baseEffect: { projectilePiercing: 1 }, desc: '투사체 관통 +{value}' },
            { id: 'combat_ai', name: '전투 AI 칩셋', category: 'attack', icon: 'assets/item/전투 AI 칩셋.png', baseEffect: { allDamage: 0.10 }, desc: '전체 데미지 +{value}%' },
            { id: 'overcharge_battery', name: '과충전 배터리', category: 'attack', icon: 'assets/item/과충전 배터리.png', baseEffect: { attackSpeed: 0.15 }, desc: '공격 속도 +{value}%' },
            { id: 'plasma_core', name: '플라즈마 코어', category: 'attack', icon: 'assets/item/플라즈마 코어.png', baseEffect: { critChance: 0.10 }, desc: '크리티컬 확률 +{value}%' },

            // 방어 계열 (6종)
            { id: 'titanium_armor', name: '티타늄 장갑', category: 'defense', icon: 'assets/item/티타늄 장갑.png', baseEffect: { maxHp: 0.30 }, desc: '최대 HP +{value}%' },
            { id: 'nano_repair', name: '나노 수리 모듈', category: 'defense', icon: 'assets/item/나노 수리 모듈.png', baseEffect: { hpRegen: 0.5 }, desc: 'HP 재생 +{value}/초' },
            { id: 'active_defense', name: '능동 방어 체계', category: 'defense', icon: 'assets/item/능동 방어 체계.png', baseEffect: { dodgeChance: 0.05 }, desc: '피격 회피 {value}%' },
            { id: 'energy_shield', name: '에너지 실드', category: 'defense', icon: 'assets/item/에너지 실드.png', baseEffect: { damageReduction: 0.10 }, desc: '데미지 감소 -{value}%' },
            { id: 'emergency_repair', name: '응급 수리 키트', category: 'defense', icon: 'assets/item/응급 수리 키트.png', baseEffect: { healOnXp: 0.50 }, desc: 'HP 회복 속도 +{value}%' },
            { id: 'regenerative_hull', name: '재생형 외장', category: 'defense', icon: 'assets/item/재생형 외장.png', baseEffect: { periodicHeal: 2 }, desc: '5초마다 HP +{value}' },

            // 특수 계열 (9종)
            { id: 'magnet_generator', name: '자기장 생성기', category: 'special', icon: 'assets/item/자기장 생성기.png', baseEffect: { xpRange: 0.30 }, desc: '경험치 수집 범위 +{value}%' },
            { id: 'scrap_magnet', name: '스크랩 자석', category: 'special', icon: 'assets/item/스크랩 자석.png', baseEffect: { goldGain: 0.25 }, desc: '스크랩 획득 +{value}%' },
            { id: 'tactical_radar', name: '전술 레이더', category: 'special', icon: 'assets/item/전술 레이더.png', baseEffect: { xpRange: 0.20 }, desc: '경험치 수집 범위 +{value}%' },
            { id: 'overclock_chip', name: '오버클럭 칩', category: 'special', icon: 'assets/item/오버클럭 칩.png', baseEffect: { xpGain: 0.15 }, desc: '경험치 획득 +{value}%' },
            { id: 'lucky_charm', name: '행운의 부적', category: 'special', icon: 'assets/item/행운의 부적.png', baseEffect: { goldGain: 0.30 }, desc: '스크랩 획득 +{value}%' },
            { id: 'combat_recorder', name: '전투 기록 장치', category: 'special', icon: 'assets/item/전투 기록 장치.png', baseEffect: { xpGain: 0.20 }, desc: '경험치 획득 +{value}%' },
            { id: 'quantum_processor', name: '양자 프로세서', category: 'special', icon: 'assets/item/양자 프로세서.png', baseEffect: { upgradeChoice: 1 }, desc: '레벨업 선택지 +{value}' },
            { id: 'escape_device', name: '긴급 탈출 장치', category: 'special', icon: 'assets/item/긴급 탈출 장치.png', baseEffect: { revive: 1 }, desc: '부활 {value}회' },
            { id: 'time_distortion', name: '시간 왜곡 장치', category: 'special', icon: 'assets/item/시간 왜곡 장치.png', baseEffect: { cooldownReduction: 0.10 }, desc: '모든 쿨타임 -{value}%' }
        ];

        // 아이템 아이콘 렌더링 헬퍼 함수
        function renderItemIcon(icon, size = '48px') {
            // 이미지 경로인지 확인 (.png, .jpg, .jpeg 등)
            if (icon && (icon.includes('.png') || icon.includes('.jpg') || icon.includes('.jpeg') || icon.includes('.gif'))) {
                return `<img src="${icon}" style="width: ${size}; height: ${size}; object-fit: contain;" alt="item icon" />`;
            }
            // 이모지인 경우
            return `<div style="font-size: ${size};">${icon}</div>`;
        }

        // 아이템 인스턴스 생성 함수
        function createItemInstance(itemId, rarity) {
            const template = ITEMS_DATABASE.find(i => i.id === itemId);
            if (!template) return null;

            const rarityData = ITEM_RARITY[rarity];
            const instance = {
                id: `${itemId}_${Date.now()}_${Math.random()}`,  // 고유 ID
                templateId: itemId,
                name: template.name,
                category: template.category,
                icon: template.icon,
                rarity: rarity,
                rarityName: rarityData.name,
                rarityColor: rarityData.color,
                multiplier: rarityData.multiplier,
                baseEffect: { ...template.baseEffect },
                desc: template.desc,
                equipped: false
            };

            return instance;
        }

        // 아이템 시스템 상태
        let inventory = [];  // 보유 아이템
        let equippedItems = [null, null, null];  // 장착된 아이템 (최대 3개)
        let gachaTickets = 0;  // 보급권 개수

        // 로컬스토리지 키
        // 현재 userKey 가져오기 헬퍼 함수
        function getCurrentUserKey() {
            if (heartSystem && heartSystem.userKey) {
                return heartSystem.userKey;
            }
            if (window.tossIntegration && window.tossIntegration.userKey) {
                return window.tossIntegration.userKey;
            }
            return localStorage.getItem('test_user_key') || 'default';
        }

        // userKey 기반 스토리지 키 생성 함수
        function getStorageKeys(userKey) {
            const key = userKey || 'default';
            return {
                inventory: `dronewar_inventory_${key}`,
                equipped: `dronewar_equipped_${key}`,
                tickets: `dronewar_supply_tickets_${key}`,
                totalGold: `dronewar_total_gold_${key}`,
                characters: `dronewar_characters_${key}`,
                stages: `dronewar_stages_${key}`,
                firstPlay: `dronewar_first_play_${key}`,
                lastLogin: `dronewar_last_login_${key}`,
                loginStreak: `dronewar_login_streak_${key}`
            };
        }

        // 현재 스토리지 키 가져오기 헬퍼 함수
        function getCurrentStorageKeys() {
            return getStorageKeys(getCurrentUserKey());
        }

        // 기본 STORAGE_KEYS (나중에 userKey로 업데이트됨)
        let STORAGE_KEYS = getStorageKeys('default');

        let selectedCharacter = 'default';
        let selectedStage = 1;
        let gameMode = 'story';  // 'story' or 'endless'
        let bossSpawned = false;
        let boss = null;
        let lastBossSpawnTime = -1;  // 마지막 보스 스폰 시간 (무한 모드용)

        // 필살기 시스템 변수
        let ultimateReady = true;
        let ultimateCooldown = GAME_CONSTANTS.ULTIMATE_COOLDOWN;
        let ultimateTimer = 0;
        let pendingUnlockCharacter = null; // 해금 대기 중인 캐릭터
        let pendingUpgradeCharacter = null; // 강화 대기 중인 캐릭터

        // Falcon 필살기: 무적 보호막
        let invincible = false;
        let invincibleTimer = 0;
        let invincibleDuration = GAME_CONSTANTS.FALCON_SHIELD_DURATION;

        // Crane 필살기: 분신
        let hasClone = false;
        let cloneTimer = 0;
        let cloneDuration = GAME_CONSTANTS.CRANE_CLONE_DURATION;
        let cloneX = 0;
        let cloneY = 0;

        // Rhino 필살기: 360도 직선 공격 (3 waves)
        let radialBlastActive = false;
        let radialBlastWaveCount = 0; // 현재 발사한 wave 수
        let radialBlastMaxWaves = GAME_CONSTANTS.RHINO_MAX_WAVES;
        let radialBlastWaveDelay = GAME_CONSTANTS.RHINO_WAVE_DELAY;
        let radialBlastWaveTimer = 0;
        let radialBlastProjectiles = []; // 필살기 전용 투사체 배열

        // Specter 필살기: 중력 붕괴
        let gravityCollapseActive = false;
        let gravityCollapsePhase = 0; // 0: 대기, 1: 끌어당김, 2: 압축, 3: 폭발
        let gravityCollapseTimer = 0;
        let gravityCollapsePullDuration = GAME_CONSTANTS.SPECTER_PULL_DURATION;
        let gravityCollapseCompressDuration = GAME_CONSTANTS.SPECTER_COMPRESS_DURATION;
        let gravityCollapseRadius = GAME_CONSTANTS.SPECTER_RADIUS;
        let gravityCollapseX = 0;
        let gravityCollapseY = 0;

        // Phantom 필살기: 쌍검 회전 레이저
        let dualLaserActive = false;
        let dualLaserTimer = 0;
        let dualLaserDuration = GAME_CONSTANTS.PHANTOM_LASER_DURATION;
        let dualLaser1Angle = 0; // 레이저 1 (시계방향)
        let dualLaser2Angle = 0; // 레이저 2 (반시계방향)
        let dualLaserHitEnemies = new Set(); // 중복 타격 방지

        // 보스 사망 애니메이션 변수
        let bossDeathAnimation = false;
        let bossDeathTimer = 0;
        let bossDeathDuration = 4500; // 4.5초 동안 폭발
        let bossDeathFlashTimer = 0;
        let dyingBoss = null; // 죽어가는 보스 저장

        // 스테이지 데이터 (스토리 모드용)
        const stages = [
            {
                id: 1,
                name: '파괴된 도시',
                description: '적들의 첫 번째 공격이 시작되는 곳\n3분 안에 보스를 처치하세요',
                unlocked: true,
                spawnRate: 0.004,  // 초반 스폰율 조정 (적당한 난이도)
                enemyTypes: {
                    // 시간대별로 동적 변경 (getEnemyTypeForStage 함수 참조)
                    melee: 1.0,
                    purple: 0.0,
                    ranged: 0.0
                },
                bossTime: 180000  // 3분 (180초)으로 단축
            },
            {
                id: 2,
                name: '사막 점거지',
                description: '더 강력한 적들이 출현하는 전장\n향상된 드론들을 상대하세요',
                unlocked: false,
                spawnRate: 0.0045,  // Stage 2 스폰율 감소 (0.006 → 0.0045)
                enemyTypes: {
                    melee: 0.7,
                    purple: 0.3,
                    ranged: 0.0
                },
                bossTime: 180000
            },
            {
                id: 3,
                name: '최종장',
                description: '모든 종류의 적이 동시에 공격해옵니다\n최후의 보스를 격파하세요',
                unlocked: false,
                spawnRate: 0.005,  // Stage 3 스폰율 감소 (0.007 → 0.005)
                enemyTypes: {
                    melee: 0.5,
                    purple: 0.3,
                    ranged: 0.2
                },
                bossTime: 180000
            }
        ];

        // 무한 모드 설정
        const endlessMode = {
            name: '무한 생존',
            description: '끝없이 몰려오는 적들',
            spawnRate: 0.004,  // 무한모드 출현율 증가 (0.003 → 0.004)
            enemyTypes: {
                melee: 0.5,
                purple: 0.3,
                ranged: 0.2
            }
        };

        let weaponDamage = 30;
        let weaponSpeed = 350;
        let projectileSpeed = 5;
        let projectileCount = 1;
        let projectilePiercing = 0;

        let hasMissile = false;
        let missileCount = 0;
        let missileDamage = 25;
        let missileSpeed = 4;
        let missilePiercing = 0;  // 미사일 관통 횟수
        let missileTimer = 0;
        const missileCooldown = 1500;

        // EMP 파장 공격 (기존 근접무기)
        let hasEMP = false;
        let empDamage = 30;
        let empTimer = 0;
        let empCooldown = 2000;  // 3000 -> 2000 (50% 향상)
        let empRadius = 200;  // 100 -> 200 (100% 향상)
        let empWaves = [];  // EMP 파장 효과

        // 위성 지원 공격 (기존 lightning)
        let hasSatellite = false;
        let satelliteDamage = 40;
        let satelliteTimer = 0;
        let satelliteCooldown = 2500;

        // 기존 위성무기 변수는 제거
        let meleeCount = 0;
        let meleeDamage = 0;
        let meleeOrbitRadius = 0;
        let meleeRotation = 0;
        let meleeRotationSpeed = 0.008;

        // 미니 드론 시스템
        let miniDrones = [];
        let miniDroneRotation = 0;
        let miniDroneRotationSpeed = 0.02;
        let miniDroneOrbitRadius = 80;
        let miniDroneDamage = 15;
        let miniDroneShootTimer = 0;
        let miniDroneShootCooldown = 500;

        let magnetRange = 150;  // 50% 증가 (100 → 150) - 자석 효과 강화

        // 아이템 특수 효과 변수들
        let itemBonuses = {
            critChance: 0,
            critDamage: 0,
            dodgeChance: 0,
            damageReduction: 0,
            xpGain: 0,
            goldGain: 0,
            healOnXp: 0,
            hpRegen: 0,
            periodicHeal: 0,
            revive: 0,
            upgradeChoice: 0,
            miniDrone: 0,
            enemySlowdown: 0
        };
        let lastPeriodicHealTime = 0;

        let isPlayerHit = false;
        let hitFlashTime = 0;
        let shakeOffsetX = 0;
        let shakeOffsetY = 0;

        let touchActive = false;
        let lastTouchX = 0;
        let lastTouchY = 0;

        function handleTouchStart(e) {
            if (!gameRunning) return;
            e.preventDefault();

            // AudioContext 활성화 (첫 터치 시)
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }

            const touch = e.touches[0];
            lastTouchX = touch.clientX;
            lastTouchY = touch.clientY;
            touchActive = true;
        }

        function handleTouchMove(e) {
            if (!gameRunning || !touchActive) return;
            e.preventDefault();
            const touch = e.touches[0];

            const deltaX = touch.clientX - lastTouchX;
            const deltaY = touch.clientY - lastTouchY;

            player.x += deltaX;
            player.y += deltaY;

            player.x = Math.max(player.visualSize, Math.min(window.innerWidth - player.visualSize, player.x));
            player.y = Math.max(player.visualSize, Math.min(window.innerHeight - player.visualSize, player.y));

            lastTouchX = touch.clientX;
            lastTouchY = touch.clientY;
        }

        function handleTouchEnd(e) {
            e.preventDefault();
            touchActive = false;
        }

        // BGM 재생 함수
        function playBgm(bgm) {
            if (currentBgm === bgm && !currentBgm.paused) return;

            // AudioContext 활성화 (모바일 호환)
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }

            // 모든 BGM의 GainNode를 0으로 설정하고 정지
            bgmGainMap.forEach((gainNode, audio) => {
                gainNode.gain.value = 0;
                if (audio !== bgm) {
                    audio.pause();
                    audio.currentTime = 0;
                }
            });

            // 새 BGM의 GainNode를 올바른 볼륨으로 설정하고 재생
            currentBgm = bgm;
            const bgmGain = bgmGainMap.get(bgm);
            if (bgmGain) {
                bgmGain.gain.value = masterVolume * musicVolume;
            }

            currentBgm.play().catch(err => {
                console.log('BGM autoplay prevented:', err);
            });
        }

        // BGM 정지 함수
        function stopBgm() {
            if (currentBgm) {
                currentBgm.pause();
                currentBgm.currentTime = 0;
            }
        }

        // 광고 재생 중 오디오 일시정지 (Toss 가이드라인)
        function pauseAllAudio() {
            // BGM 정지
            if (currentBgm && !currentBgm.paused) {
                currentBgm.pause();
                console.log('🔇 광고 재생 중 - BGM 일시정지');
            }
            // Web Audio API (SFX) 정지
            if (audioContext && audioContext.state === 'running') {
                audioContext.suspend().then(() => {
                    console.log('🔇 AudioContext suspended');
                }).catch(err => {
                    console.log('AudioContext suspend failed:', err);
                });
            }
        }

        // 광고 종료 후 오디오 재개 (Toss 가이드라인)
        function resumeAllAudio() {
            // BGM 재개
            if (currentBgm && currentBgm.paused) {
                currentBgm.play().catch(err => {
                    console.log('BGM resume failed:', err);
                });
                console.log('🔊 광고 종료 - BGM 재개');
            }
            // Web Audio API (SFX) 재개
            if (audioContext && audioContext.state === 'suspended') {
                audioContext.resume().then(() => {
                    console.log('🔊 AudioContext resumed');
                }).catch(err => {
                    console.log('AudioContext resume failed:', err);
                });
            }
        }

        // 전역으로 노출 (toss-integration.js에서 사용)
        window.pauseAllAudio = pauseAllAudio;
        window.resumeAllAudio = resumeAllAudio;

        canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
        canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
        canvas.addEventListener('touchend', handleTouchEnd, { passive: false });

        window.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;

            // 스테이지 선택 화면에서 좌우 방향키로 스테이지 넘기기
            if (document.getElementById('stageSelectScreen').style.display === 'flex') {
                if (e.key === 'ArrowLeft') {
                    prevStageCarousel();
                    e.preventDefault();
                } else if (e.key === 'ArrowRight') {
                    nextStageCarousel();
                    e.preventDefault();
                } else if (e.key === 'Enter') {
                    // 엔터키로 현재 스테이지 선택
                    const stage = stages[currentStageIndex];
                    if (stage.unlocked) {
                        selectStage(stage.id);
                    }
                    e.preventDefault();
                }
            }

            // 개발자 치트키: 1번 키로 4분 59초로 스킵
            if (e.key === '1' && gameRunning && gameMode === 'story') {
                gameTime = 299000; // 4분 59초 (299초)
                console.log('치트 활성화: 4분 59초로 스킵');
            }

            // 개발자 치트키: 2번 키로 메인 메뉴에서 모든 스테이지/캐릭터 해금
            if (e.key === '2' && !gameStarted && document.getElementById('mainMenu').style.display !== 'none') {
                // 모든 캐릭터 해금
                characters.forEach(char => {
                    char.unlocked = true;
                });
                // 모든 스테이지 해금
                stages.forEach(stage => {
                    stage.unlocked = true;
                });
                // 골드 추가
                totalGold += 10000;
                console.log('치트 활성화: 모든 캐릭터/스테이지 해금, 골드 +10000');
                showTossModal({
                    title: '치트 활성화!',
                    message: '모든 캐릭터와 스테이지가 해금되었습니다.\n스크랩 +10,000',
                    buttons: [{ text: '확인', color: 'primary' }]
                });
            }
        });

        window.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
        });

        function initMeleeWeapons() {
            meleeWeapons.length = 0;
            for (let i = 0; i < meleeCount; i++) {
                meleeWeapons.push({
                    angle: (Math.PI * 2 / meleeCount) * i,
                    size: 12 * sizeScale
                });
            }
        }

        // 에너지 UI 표시 여부 제어 (인게임 제외)
        function updateHeartDisplayVisibility() {
            const heartDisplay = document.getElementById('heartDisplay');
            if (!heartDisplay) return;

            // 확인 모달(홈 버튼)이 떠있으면 숨김
            const confirmModal = document.getElementById('confirmModal');
            const isConfirmModalVisible = confirmModal && confirmModal.style.display === 'block';

            // 에너지 부족 모달이 떠있으면 숨김
            const energyModal = document.getElementById('energyDepletedModal');
            const isEnergyModalVisible = energyModal && energyModal.style.display === 'block';

            // 레벨업 창이 떠있으면 숨김
            const levelUpScreen = document.getElementById('levelUp');
            const isLevelUpVisible = levelUpScreen && levelUpScreen.style.display === 'block';

            // 게임 오버 체크
            const gameOverScreen = document.getElementById('gameOver');
            const isGameOver = gameOverScreen && gameOverScreen.style.display === 'block';

            // 게임이 실행 중이거나 확인 모달이 떠있거나 레벨업 중이면 숨김
            // 게임 오버 시에는 표시
            if ((gameStarted && gameRunning) || isConfirmModalVisible || isEnergyModalVisible || isLevelUpVisible) {
                heartDisplay.style.display = 'none';
            } else {
                heartDisplay.style.display = 'block';
            }
        }

        // 에너지 UI 업데이트
        function updateHeartUI() {
            if (!heartSystem) return;

            const hearts = heartSystem.getHearts();
            const maxHearts = heartSystem.maxHearts;
            const timeUntilNext = heartSystem.getTimeUntilNextHeart();

            // 에너지 아이콘 업데이트 (Thunder.png 사용)
            const heartIcons = document.getElementById('heartIcons');
            if (heartIcons) {
                heartIcons.innerHTML = '';
                for (let i = 0; i < maxHearts; i++) {
                    const img = document.createElement('img');
                    img.src = 'assets/Thunder.png';
                    img.style.cssText = `
                        width: 24px;
                        height: 24px;
                        image-rendering: pixelated;
                        opacity: ${i < hearts ? '1' : '0.3'};
                        filter: ${i < hearts ? 'none' : 'grayscale(100%)'};
                    `;
                    heartIcons.appendChild(img);
                }
            }

            // 회복 타이머
            const heartTimer = document.getElementById('heartTimer');
            if (heartTimer) {
                if (hearts < maxHearts && timeUntilNext > 0) {
                    heartTimer.textContent = `다음 회복: ${heartSystem.formatTime(timeUntilNext)}`;
                } else {
                    heartTimer.textContent = '';
                }
            }

            // 보급권 개수 업데이트
            updateSupplyTicketDisplay();

            // 친구 초대 버튼 표시/숨김
            const inviteButton = document.getElementById('inviteFriendsButton');
            const startButton = document.getElementById('startGameButton');
            if (hearts === 0) {
                if (inviteButton) inviteButton.style.display = 'block';
                if (startButton) startButton.style.opacity = '0.5';
            } else {
                if (inviteButton) inviteButton.style.display = 'none';
                if (startButton) startButton.style.opacity = '1';
            }

            // 표시 여부 업데이트
            updateHeartDisplayVisibility();
        }

        // 게임 시작 시도 (에너지 체크만, 소모는 인게임 진입 시)
        function tryStartGame() {
            if (!heartSystem) {
                // 에너지 시스템 없으면 바로 시작 (fallback)
                startGame();
                return;
            }

            if (!heartSystem.hasHeart()) {
                // 에너지 부족 모달 표시
                document.getElementById('energyDepletedModal').style.display = 'block';
                updateHeartDisplayVisibility(); // 에너지 UI 숨김
                return;
            }

            // 에너지 체크만 하고 게임 시작 (소모는 initGame에서)
            startGame();
        }

        // 친구 초대하고 에너지 받기
        function inviteFriendsForHearts() {
            if (!window.tossIntegration) {
                showTossModal({
                    title: 'Toss 연동 필요',
                    message: 'Toss 앱에서 실행 시\n친구 초대 기능을 사용할 수 있습니다.',
                    buttons: [{ text: '확인', color: 'secondary' }]
                });
                return;
            }

            // SDK 가용성 체크
            if (!window.tossIntegration.isInviteFriendsAvailable()) {
                const envInfo = window.tossIntegration.getEnvironmentInfo();
                console.warn('⚠️ 친구 초대 SDK 없음:', envInfo);
                showTossModal({
                    title: '친구 초대를 사용할 수 없습니다',
                    message: 'Toss 앱 버전이 낮거나\nSDK가 로드되지 않았습니다.\n\n환경: ' + envInfo.env + '\n버전: ' + envInfo.tossVersion,
                    buttons: [{ text: '확인', color: 'secondary' }]
                });
                return;
            }

            window.tossIntegration.inviteFriends((rewardAmount) => {
                // 에너지 충전
                if (heartSystem) {
                    heartSystem.addHearts(rewardAmount);
                    showTossModal({
                        title: '친구 초대 성공!',
                        message: `에너지 ${rewardAmount}개를 받았습니다! 🎉`,
                        buttons: [{ text: '확인', color: 'primary' }]
                    });
                }
            });
        }

        // 에너지 부족 모달에서 친구 초대
        function inviteFriendsFromModal() {
            // 모달 닫기
            closeEnergyModal();

            // 친구 초대 실행
            if (!window.tossIntegration) {
                showTossModal({
                    title: 'Toss 연동 필요',
                    message: 'Toss 앱에서 실행 시\n친구 초대 기능을 사용할 수 있습니다.',
                    buttons: [{ text: '확인', color: 'secondary' }]
                });
                return;
            }

            // SDK 가용성 체크
            if (!window.tossIntegration.isInviteFriendsAvailable()) {
                const envInfo = window.tossIntegration.getEnvironmentInfo();
                console.warn('⚠️ 친구 초대 SDK 없음:', envInfo);
                showTossModal({
                    title: '친구 초대를 사용할 수 없습니다',
                    message: 'Toss 앱 버전이 낮거나\nSDK가 로드되지 않았습니다.\n\n환경: ' + envInfo.env + '\n버전: ' + envInfo.tossVersion,
                    buttons: [{ text: '확인', color: 'secondary' }]
                });
                return;
            }

            window.tossIntegration.inviteFriends((rewardAmount) => {
                // 에너지 충전
                if (heartSystem) {
                    heartSystem.addHearts(rewardAmount);
                    showTossModal({
                        title: '친구 초대 성공!',
                        message: `에너지 ${rewardAmount}개를 받았습니다! 🎉`,
                        buttons: [{ text: '확인', color: 'primary' }]
                    });
                }
            });
        }

        // 에너지 부족 모달 닫기
        function closeEnergyModal() {
            document.getElementById('energyDepletedModal').style.display = 'none';
            updateHeartDisplayVisibility(); // 에너지 UI 다시 표시
        }

        // 광고 보고 에너지 받기
        async function watchAdForEnergy() {
            if (!window.tossIntegration) {
                showTossModal({
                    title: 'Toss 연동 필요',
                    message: 'Toss 앱에서 실행 시\n광고 시청 기능을 사용할 수 있습니다.',
                    buttons: [{ text: '확인', color: 'secondary' }]
                });
                return;
            }

            // SDK 가용성 체크
            if (!window.tossIntegration.isAdAvailable()) {
                const envInfo = window.tossIntegration.getEnvironmentInfo();
                console.warn('⚠️ 광고 SDK 없음:', envInfo);
                showTossModal({
                    title: '광고를 사용할 수 없습니다',
                    message: 'Toss 앱 버전이 낮거나\nSDK가 로드되지 않았습니다.\n\n환경: ' + envInfo.env + '\n버전: ' + envInfo.tossVersion,
                    buttons: [{ text: '확인', color: 'secondary' }]
                });
                return;
            }

            // 광고 표시 및 보상 처리 (에너지 충전용 광고 ID)
            const success = await window.tossIntegration.showRewardedAd('ait.live.93f320e4e9504159', (reward) => {
                console.log('✅ 에너지 광고 보상 획득:', reward);

                // 에너지 충전 (1개)
                const rewardAmount = 1;
                if (heartSystem && heartSystem.addHearts) {
                    heartSystem.addHearts(rewardAmount);

                    // 모달 닫기
                    closeEnergyModal();

                    // 성공 알림
                    showTossModal({
                        title: '광고 시청 완료!',
                        message: `에너지 ${rewardAmount}개를 받았습니다! ⚡`,
                        buttons: [{ text: '확인', color: 'primary' }]
                    });

                    console.log('🎁 광고 시청으로 에너지 충전 완료');
                }
            });

            if (!success) {
                console.error('광고 표시 실패');
                showTossModal({
                    title: '광고 로딩 실패',
                    message: '광고를 불러오는데 실패했습니다.\n잠시 후 다시 시도해주세요.',
                    buttons: [{ text: '확인', color: 'danger' }]
                });
            }
        }

        function startGame() {
            document.getElementById('mainMenu').style.display = 'none';
            document.getElementById('modeSelectScreen').style.display = 'flex';
            // 메인 BGM 계속 재생 (게임 시작 시에 전환)
        }

        function selectMode(mode) {
            gameMode = mode;
            document.getElementById('modeSelectScreen').style.display = 'none';

            if (mode === 'story') {
                // 스토리 모드: 스테이지 선택
                document.getElementById('stageSelectScreen').style.display = 'flex';
                renderStages();
            } else {
                // 무한 모드: 바로 게임 시작
                startEndlessMode();
            }
        }

        function closeModeSelect() {
            document.getElementById('modeSelectScreen').style.display = 'none';
            document.getElementById('mainMenu').style.display = 'flex';
        }

        // ============================================
        // 스테이지 캐러셀 시스템
        // ============================================

        // 상수 정의
        const CAROUSEL_ELEMENTS = {
            CONTAINER: 'stageCardContainer',
            PREV_ARROW: 'prevStageArrow',
            NEXT_ARROW: 'nextStageArrow'
        };

        const CAROUSEL_CLASSES = {
            DISABLED: 'disabled',
            LOCKED: 'locked',
            CARD: 'stage-card'
        };

        const CAROUSEL_STYLES = {
            LOCKED_TEXT: 'color: #ff6b6b; margin-top: 10px; font-size: 14px;'
        };

        // 현재 선택된 스테이지 인덱스
        let currentStageIndex = 0;

        /**
         * 스테이지 선택 캐러셀 초기화
         */
        function renderStages() {
            currentStageIndex = 0;
            updateStageCarousel();
        }

        /**
         * 스테이지 카드 HTML 생성
         * @param {Object} stage - 스테이지 객체
         * @returns {string} 카드 HTML
         */
        function createStageCardHTML(stage) {
            const lockedBadge = stage.unlocked
                ? ''
                : `<div style="${CAROUSEL_STYLES.LOCKED_TEXT}"><img src="assets/lock.png" style="width: 16px; height: 16px; vertical-align: middle; image-rendering: pixelated;"> 잠김</div>`;

            return `
                <div class="stage-number">Stage ${stage.id}</div>
                <img src="assets/Stage${stage.id}Icon.png" class="stage-icon" alt="${stage.name}">
                <div class="stage-name">${stage.name}</div>
                ${lockedBadge}
            `;
        }

        /**
         * 스테이지 카드 생성 및 이벤트 바인딩
         * @param {Object} stage - 스테이지 객체
         * @returns {HTMLElement} 생성된 카드 엘리먼트
         */
        function createStageCard(stage) {
            const card = document.createElement('div');
            card.className = CAROUSEL_CLASSES.CARD;

            if (!stage.unlocked) {
                card.classList.add(CAROUSEL_CLASSES.LOCKED);
            }

            card.innerHTML = createStageCardHTML(stage);

            if (stage.unlocked) {
                card.onclick = () => selectStage(stage.id);
            }

            return card;
        }

        /**
         * 캐러셀 화살표 상태 업데이트
         */
        function updateCarouselArrows() {
            const prevArrow = document.getElementById(CAROUSEL_ELEMENTS.PREV_ARROW);
            const nextArrow = document.getElementById(CAROUSEL_ELEMENTS.NEXT_ARROW);

            const isFirstStage = currentStageIndex === 0;
            const isLastStage = currentStageIndex === stages.length - 1;

            prevArrow.classList.toggle(CAROUSEL_CLASSES.DISABLED, isFirstStage);
            nextArrow.classList.toggle(CAROUSEL_CLASSES.DISABLED, isLastStage);
        }

        /**
         * 스테이지 캐러셀 업데이트 (카드와 화살표)
         */
        function updateStageCarousel() {
            const container = document.getElementById(CAROUSEL_ELEMENTS.CONTAINER);
            const stage = stages[currentStageIndex];

            container.innerHTML = '';
            container.appendChild(createStageCard(stage));

            updateCarouselArrows();
        }

        /**
         * 캐러셀 이동 함수 (공통 로직)
         * @param {number} direction - 이동 방향 (-1: 이전, +1: 다음)
         */
        function moveCarousel(direction) {
            const newIndex = currentStageIndex + direction;
            const isValidMove = newIndex >= 0 && newIndex < stages.length;

            if (isValidMove) {
                currentStageIndex = newIndex;
                updateStageCarousel();
                playSFX('shoot');
            }
        }

        /**
         * 이전 스테이지로 이동
         */
        function prevStageCarousel() {
            moveCarousel(-1);
        }

        /**
         * 다음 스테이지로 이동
         */
        function nextStageCarousel() {
            moveCarousel(1);
        }

        function selectStage(stageId) {
            selectedStage = stageId;
            document.getElementById('stageSelectScreen').style.display = 'none';
            initGame();
        }

        function startEndlessMode() {
            selectedStage = null;  // 무한 모드는 스테이지 없음
            initGame();
        }

        function initGame() {
            // 에너지 소모 (실제 인게임 진입 시)
            if (heartSystem && heartSystem.hasHeart()) {
                heartSystem.useHeart();
                console.log('✅ 에너지 소모 - 게임 시작');
            }

            // 부활용 광고 미리 로드
            if (window.tossIntegration && window.tossIntegration.isAdAvailable()) {
                window.tossIntegration.loadRewardedAd('ait.live.a1e634d55d5046db');  // 부활용
                window.tossIntegration.loadRewardedAd('ait.live.2b98ee996c124825');  // 게임 종료용
                console.log('📥 광고 미리 로드 시작 (부활 + 게임 종료)');
            }

            // AudioContext 재개 (모바일 브라우저 호환성)
            if (audioContext.state === 'suspended') {
                audioContext.resume().then(() => {
                    console.log('AudioContext resumed');
                });
            }

            // 모든 모달 닫기
            document.getElementById('upgradeModal').style.display = 'none';
            document.getElementById('unlockModal').style.display = 'none';
            document.getElementById('confirmModal').style.display = 'none';

            document.getElementById('homeButton').style.display = 'flex';
            document.getElementById('ultimateButton').style.display = 'flex';

            // 에너지 UI 즉시 숨김 (인게임)
            const heartDisplay = document.getElementById('heartDisplay');
            if (heartDisplay) heartDisplay.style.display = 'none';

            // 키 입력 및 터치 초기화
            Object.keys(keys).forEach(key => keys[key] = false);
            touchActive = false;

            const char = characters.find(c => c.id === selectedCharacter);
            const upgradedStats = getUpgradedStats(char.stats, char.upgradeLevel);

            // 플레이어 초기화
            player.maxHp = upgradedStats.hp;
            player.hp = upgradedStats.hp;
            player.speed = upgradedStats.speed;
            console.log('initGame: player.speed set to', player.speed);
            player.x = window.innerWidth / 2;
            player.y = window.innerHeight / 2;
            player.xp = 0;
            player.level = 1;
            player.xpNeeded = 10;

            // 배열 초기화
            enemies.length = 0;
            projectiles.length = 0;
            missiles.length = 0;
            lightnings.length = 0;
            enemyProjectiles.length = 0;
            xpOrbs.length = 0;
            goldOrbs.length = 0;
            meleeWeapons.length = 0;

            // 게임 상태 초기화
            kills = 0;
            gameTime = 0;
            shootTimer = 0;
            missileTimer = 0;
            currentGold = 0;
            gameStarted = true;
            gameRunning = true;
            bossSpawned = false;
            boss = null;
            lastBossSpawnTime = -1;
            canRevive = true;  // 부활 기회 초기화

            // 필살기 초기화
            ultimateReady = true;
            ultimateTimer = 0;
            updateUltimateButton();

            // Falcon & Crane 필살기 초기화
            invincible = false;
            invincibleTimer = 0;
            hasClone = false;
            cloneTimer = 0;

            // Rhino 필살기 초기화
            radialBlastActive = false;
            radialBlastWaveCount = 0;
            radialBlastWaveTimer = 0;
            radialBlastProjectiles = [];

            // Specter 필살기 초기화
            gravityCollapseActive = false;
            gravityCollapsePhase = 0;
            gravityCollapseTimer = 0;

            // Phantom 필살기 초기화
            dualLaserActive = false;
            dualLaserTimer = 0;
            dualLaser1Angle = 0;
            dualLaser2Angle = 0;
            dualLaserHitEnemies = new Set();

            // 무기 스탯 초기화
            weaponDamage = upgradedStats.damage;
            weaponSpeed = 350;
            projectileSpeed = 5;
            projectileCount = 1;
            projectilePiercing = 0;

            hasMissile = false;
            missileCount = 0;
            missileDamage = 25;
            missileSpeed = 4;
            missilePiercing = 0;

            // EMP 파장 초기화
            hasEMP = false;
            empDamage = 30;
            empTimer = 0;
            empCooldown = 2000;  // 3000 -> 2000 (50% 향상)
            empRadius = 200;  // 100 -> 200 (100% 향상)
            empWaves.length = 0;

            // 미니 드론 초기화
            miniDrones.length = 0;
            miniDroneRotation = 0;
            miniDroneShootTimer = 0;

            // 위성 지원 초기화
            hasSatellite = false;
            satelliteDamage = 40;
            satelliteTimer = 0;
            satelliteCooldown = 2500;

            // 기존 위성무기 변수 (제거 예정, 호환성 유지)
            meleeCount = 0;
            meleeDamage = 0;
            meleeOrbitRadius = 0;
            meleeRotation = 0;

            magnetRange = 100;

            isPlayerHit = false;

            // 배경 스크롤 초기화
            backgroundY1 = 0;
            backgroundY2 = -window.innerHeight;
            hitFlashTime = 0;

            lastTime = Date.now();
            updateGoldUI();

            // 장착된 아이템 효과 적용
            applyEquipmentEffects();

            // 스테이지별 BGM 재생
            if (gameMode === 'story') {
                if (selectedStage === 1) {
                    playBgm(stage1Bgm);
                } else if (selectedStage === 2) {
                    playBgm(stage2Bgm);
                } else if (selectedStage === 3) {
                    playBgm(stage3Bgm);
                }
            } else {
                // 무한 모드는 스테이지 1 BGM 사용
                playBgm(stage1Bgm);
            }

            // 초기 적 스폰 (게임 시작 즉시 적 등장)
            const initialEnemyCount = isMobile ? 3 : 5;  // 모바일 3마리, PC 5마리
            for (let i = 0; i < initialEnemyCount; i++) {
                spawnEnemy();
            }
            console.log(`✅ 초기 적 ${initialEnemyCount}마리 스폰 완료`);

            // 새로운 게임 루프 시작 (이전 루프는 자동으로 중단됨)
            gameLoopId++;
            console.log('Starting new game loop with ID:', gameLoopId);
            gameLoop(gameLoopId);
        }

        function closeStageSelect() {
            document.getElementById('stageSelectScreen').style.display = 'none';
            document.getElementById('modeSelectScreen').style.display = 'flex';
        }

        function openShopFromMenu() {
            document.getElementById('mainMenu').style.display = 'none';
            document.getElementById('shopScreen').style.display = 'flex';
            document.getElementById('shopGold').textContent = totalGold;
            updateGoldUI();  // 골드 UI 업데이트
            renderCharacters();
        }

        function openShop() {
            // 게임 중이라면 일시정지
            if (gameRunning) {
                gameRunning = false;
            }
            document.getElementById('shopScreen').style.display = 'flex';
            document.getElementById('shopGold').textContent = totalGold;
            renderCharacters();
        }

        function closeShop() {
            document.getElementById('shopScreen').style.display = 'none';
            updateGoldUI();  // 골드 UI 업데이트
            if (!gameStarted || !gameRunning) {
                // 게임이 시작되지 않았거나 게임 오버 상태면 메인 메뉴로
                document.getElementById('mainMenu').style.display = 'flex';
            } else {
                // 게임 중이었다면 게임 재개
                gameRunning = true;
                lastTime = Date.now();
            }
        }

        function openSettingsFromMenu() {
            settingsOpenedFrom = 'menu';  // 메뉴에서 열었음을 기록
            document.getElementById('mainMenu').style.display = 'none';
            document.getElementById('settingsScreen').style.display = 'flex';
            updateGoldUI();  // 골드 UI 업데이트

            // 현재 볼륨 값으로 슬라이더 설정
            document.getElementById('masterVolumeSlider').value = Math.round(masterVolume * 100);
            document.getElementById('masterVolumeValue').textContent = Math.round(masterVolume * 100);
            document.getElementById('musicVolumeSlider').value = Math.round(musicVolume * 100);
            document.getElementById('musicVolumeValue').textContent = Math.round(musicVolume * 100);
            document.getElementById('sfxVolumeSlider').value = Math.round(sfxVolume * 100);
            document.getElementById('sfxVolumeValue').textContent = Math.round(sfxVolume * 100);
        }

        function openSettings() {
            settingsOpenedFrom = 'game';  // 게임에서 열었음을 기록
            // 게임 중이라면 일시정지
            if (gameRunning) {
                gameRunning = false;
            }
            document.getElementById('settingsScreen').style.display = 'flex';

            // 현재 볼륨 값으로 슬라이더 설정
            document.getElementById('masterVolumeSlider').value = Math.round(masterVolume * 100);
            document.getElementById('masterVolumeValue').textContent = Math.round(masterVolume * 100);
            document.getElementById('musicVolumeSlider').value = Math.round(musicVolume * 100);
            document.getElementById('musicVolumeValue').textContent = Math.round(musicVolume * 100);
            document.getElementById('sfxVolumeSlider').value = Math.round(sfxVolume * 100);
            document.getElementById('sfxVolumeValue').textContent = Math.round(sfxVolume * 100);
        }

        function closeSettings() {
            document.getElementById('settingsScreen').style.display = 'none';
            updateGoldUI();  // 골드 UI 업데이트

            // 설정을 어디서 열었는지에 따라 다르게 처리
            if (settingsOpenedFrom === 'menu') {
                // 메뉴에서 열었으면 메뉴로 돌아감
                document.getElementById('mainMenu').style.display = 'flex';
            } else {
                // 게임에서 열었으면 게임 재개 (단, 특수 상황 제외)
                const levelUpVisible = document.getElementById('levelUp').style.display === 'block';
                const gameOverVisible = document.getElementById('gameOver').style.display === 'block';
                const stageClearVisible = document.getElementById('stageClear').style.display === 'block';

                // 보스 사망 애니메이션, 레벨업, 게임오버, 스테이지 클리어 화면이 없을 때만 재개
                if (!bossDeathAnimation && !levelUpVisible && !gameOverVisible && !stageClearVisible) {
                    gameRunning = true;
                    lastTime = Date.now();
                }
            }
        }

        // 모바일 치트키 시스템 (설정 제목을 5번 연속 탭)
        let cheatTapCount = 0;
        let cheatTapTimer = null;

        function handleCheatTap() {
            cheatTapCount++;

            // 1초 이내에 탭하지 않으면 카운트 리셋
            if (cheatTapTimer) clearTimeout(cheatTapTimer);
            cheatTapTimer = setTimeout(() => {
                cheatTapCount = 0;
            }, 1000);

            // 5번 탭하면 치트 활성화
            if (cheatTapCount >= 5) {
                activateCheat();
                cheatTapCount = 0;
                clearTimeout(cheatTapTimer);
            }
        }

        // ============================================
        // 모바일 보스 치트키 시스템
        // ============================================

        const BOSS_CHEAT = {
            TAP_TIMEOUT: 1000,
            SPAWN_TAP_COUNT: 5,
            KILL_TAP_COUNT: 10,
            FEEDBACK_DURATION: 1000,
            COLORS: {
                SPAWN: '#ff6b6b',
                KILL: '#4CAF50'
            },
            VIBRATION: {
                SPAWN: [100, 50, 100],
                KILL: [200, 100, 200, 100, 200]
            }
        };

        let bossCheatTapCount = 0;
        let bossCheatTapTimer = null;

        /**
         * 시각적 피드백 (색상 변경 및 복원)
         * @param {string} color - 피드백 색상
         */
        function showBossCheatFeedback(color) {
            const timeUI = document.getElementById('timeUI');
            const originalColor = timeUI.style.color;

            timeUI.style.color = color;
            timeUI.style.textShadow = `0 0 10px ${color}`;

            setTimeout(() => {
                timeUI.style.color = originalColor;
                timeUI.style.textShadow = '';
            }, BOSS_CHEAT.FEEDBACK_DURATION);
        }

        /**
         * 햅틱 피드백
         * @param {Array} pattern - 진동 패턴
         */
        function triggerHapticFeedback(pattern) {
            if (navigator.vibrate) {
                navigator.vibrate(pattern);
            }
        }

        /**
         * 화면 흔들림 효과 (iOS에서도 작동)
         * @param {number} intensity - 흔들림 강도 (픽셀)
         */
        function triggerScreenShake(intensity) {
            shakeIntensity = Math.max(shakeIntensity, intensity);
        }

        /**
         * 보스 즉시 소환
         */
        function spawnBossCheat() {
            if (bossSpawned || boss) return;

            const stageId = gameMode === 'story'
                ? selectedStage
                : Math.min(Math.floor(gameTime / 300000) + 1, 3);

            spawnBoss(stageId);

            showBossCheatFeedback(BOSS_CHEAT.COLORS.SPAWN);
            triggerHapticFeedback(BOSS_CHEAT.VIBRATION.SPAWN);
            playSFX('levelup');

            console.log('🎮 보스 치트: 보스 즉시 소환');
        }

        /**
         * 보스 즉시 처치
         */
        function killBossCheat() {
            if (!boss || !enemies.includes(boss)) return;

            // 보스 처치
            boss.hp = 0;
            dropXP(boss.x, boss.y, 200);  // 4배 증가 (50 → 200)
            dropGold(boss.x, boss.y, 500);  // 5배 증가 (100 → 500)

            const index = enemies.indexOf(boss);
            if (index > -1) {
                kills++;
                startBossDeathAnimation(boss);
                enemies.splice(index, 1);
            }

            boss = null;

            showBossCheatFeedback(BOSS_CHEAT.COLORS.KILL);
            triggerHapticFeedback(BOSS_CHEAT.VIBRATION.KILL);
            playSFX('bossdeath');

            console.log('🎮 보스 치트: 보스 즉시 처치');
        }

        /**
         * 보스 치트 탭 핸들러 (시간 UI 클릭)
         */
        function handleBossCheatTap() {
            if (!gameRunning) return;

            bossCheatTapCount++;

            // 타이머 리셋
            if (bossCheatTapTimer) clearTimeout(bossCheatTapTimer);
            bossCheatTapTimer = setTimeout(() => {
                bossCheatTapCount = 0;
            }, BOSS_CHEAT.TAP_TIMEOUT);

            // 5번 탭: 보스 소환
            if (bossCheatTapCount === BOSS_CHEAT.SPAWN_TAP_COUNT) {
                spawnBossCheat();
            }

            // 10번 탭: 보스 처치
            if (bossCheatTapCount >= BOSS_CHEAT.KILL_TAP_COUNT) {
                killBossCheat();
                bossCheatTapCount = 0;
                clearTimeout(bossCheatTapTimer);
            }
        }

        function activateCheat() {
            // 모든 캐릭터 해금
            characters.forEach(char => {
                char.unlocked = true;
            });

            // 모든 스테이지 해금
            stages.forEach(stage => {
                stage.unlocked = true;
            });

            // 골드 100,000 추가
            totalGold += 100000;
            currentGold += 100000;
            updateGoldUI();

            // 보급권 50장 추가
            gachaTickets += 50;
            updateSupplyTicketDisplay();

            // 에너지 최대 충전
            if (heartSystem && heartSystem.addHearts) {
                const maxHearts = heartSystem.maxHearts;
                const currentHearts = heartSystem.getHearts();
                const heartsToAdd = maxHearts - currentHearts;
                if (heartsToAdd > 0) {
                    heartSystem.addHearts(heartsToAdd);
                    console.log(`✅ 에너지 충전: ${currentHearts} → ${maxHearts}`);
                }
            }

            // 모든 변경사항 저장
            saveItemData(); // 보급권 저장
            saveGameProgress(); // 골드/캐릭터/스테이지 저장

            // 게임 중이라면 4분 59초로 스킵
            if (gameRunning && gameMode === 'story') {
                gameTime = 299000; // 4분 59초
            }

            // 시각 피드백
            document.getElementById('settingsTitle').textContent = '치트 활성화! 🎮';
            document.getElementById('settingsTitle').style.color = '#ff6b6b';

            // 햅틱 피드백
            if (navigator.vibrate) {
                navigator.vibrate([50, 50, 50, 50, 50]);
            }

            // 효과음
            playSFX('levelup');

            // 2초 후 원래대로
            setTimeout(() => {
                document.getElementById('settingsTitle').textContent = '설정';
                document.getElementById('settingsTitle').style.color = '';
            }, 2000);

            console.log('🎮 치트 활성화: 모든 캐릭터/스테이지 해금, 골드 +100,000, 보급권 +50');
        }

        // 모바일/토스 인앱 브라우저 호환을 위한 전역 함수
        function handleVolumeChange(type, value) {
            console.log('=== Volume Change Debug ===');
            console.log('Type:', type, 'Value:', value);
            console.log('AudioContext state:', audioContext?.state);
            console.log('Current BGM:', currentBgm);
            console.log('Current BGM paused:', currentBgm?.paused);
            console.log('Current BGM volume before:', currentBgm?.volume);

            // 모바일 브라우저에서 AudioContext 활성화
            if (audioContext && audioContext.state === 'suspended') {
                audioContext.resume().then(() => {
                    console.log('AudioContext resumed successfully');
                });
            }

            // 테스트 사운드 재생으로 오디오 시스템 활성화 (효과음 타입일 때만)
            if (type === 'sfx') {
                playSFX('shoot');
            }

            updateVolume(type, value);

            console.log('Current BGM volume after:', currentBgm?.volume);
            console.log('Master:', masterVolume, 'Music:', musicVolume, 'SFX:', sfxVolume);
        }

        function updateVolume(type, value) {
            const volume = value / 100;

            if (type === 'master') {
                masterVolume = volume;
                document.getElementById('masterVolumeValue').textContent = value;
                localStorage.setItem('masterVolume', volume);

                // 현재 재생 중인 BGM의 GainNode만 업데이트 (모바일 iOS 대응)
                if (currentBgm && bgmGainMap.has(currentBgm)) {
                    const bgmGain = bgmGainMap.get(currentBgm);
                    bgmGain.gain.value = masterVolume * musicVolume;
                }

                // 효과음 객체 볼륨 업데이트
                bossExplosionSound.volume = masterVolume * sfxVolume;
                ultimateSound.volume = masterVolume * sfxVolume;

                console.log('Master volume updated:', masterVolume);

            } else if (type === 'music') {
                musicVolume = volume;
                document.getElementById('musicVolumeValue').textContent = value;
                localStorage.setItem('musicVolume', volume);

                // 현재 재생 중인 BGM의 GainNode만 업데이트 (모바일 iOS 대응)
                if (currentBgm && bgmGainMap.has(currentBgm)) {
                    const bgmGain = bgmGainMap.get(currentBgm);
                    bgmGain.gain.value = masterVolume * musicVolume;
                }

                console.log('Music volume updated:', musicVolume);

            } else if (type === 'sfx') {
                sfxVolume = volume;
                document.getElementById('sfxVolumeValue').textContent = value;
                localStorage.setItem('sfxVolume', volume);

                // 효과음 객체 볼륨 업데이트
                bossExplosionSound.volume = masterVolume * sfxVolume;
                ultimateSound.volume = masterVolume * sfxVolume;

                console.log('SFX volume updated:', sfxVolume);
            }
        }

        function showConfirmModal() {
            if (!gameRunning) return;
            gameRunning = false;

            // 현재 스탯 정보 수집 및 표시
            const statsContainer = document.getElementById('pauseStatsContainer');
            const currentTime = Math.floor(gameTime / 1000);

            let statsHTML = '';

            // 기본 정보
            statsHTML += `
                <div class="pause-stats-section">
                    <div class="pause-stats-title">기본 정보</div>
                    <div class="pause-stat-item">레벨: <span class="pause-stat-value">${player.level}</span></div>
                    <div class="pause-stat-item">HP: <span class="pause-stat-value">${player.hp}/${player.maxHp}</span></div>
                    <div class="pause-stat-item">시간: <span class="pause-stat-value">${currentTime}초</span></div>
                    <div class="pause-stat-item">격추: <span class="pause-stat-value">${kills}대</span></div>
                </div>
            `;

            // 기본 공격
            statsHTML += `
                <div class="pause-stats-section">
                    <div class="pause-stats-title">기본 공격</div>
                    <div class="pause-stat-item">데미지: <span class="pause-stat-value">${weaponDamage}</span></div>
                    <div class="pause-stat-item">연사 속도: <span class="pause-stat-value">${(weaponSpeed / 1000).toFixed(2)}초</span></div>
                    <div class="pause-stat-item">투사체: <span class="pause-stat-value">${projectileCount}개</span> (속도: ${projectileSpeed})</div>
                    <div class="pause-stat-item">관통력: <span class="pause-stat-value">${projectilePiercing}</span></div>
                </div>
            `;

            // 특수 무기 (활성화된 것만 표시)
            const specialWeapons = [];
            if (hasMissile) {
                specialWeapons.push(`미사일: <span class="pause-stat-value">${missileCount}개</span> (데미지: ${missileDamage})`);
            }
            if (hasEMP) {
                specialWeapons.push(`EMP: <span class="pause-stat-value">${empDamage}데미지</span> (${(empCooldown / 1000).toFixed(1)}초 / 범위 ${empRadius})`);
            }
            if (hasSatellite) {
                specialWeapons.push(`위성: <span class="pause-stat-value">${satelliteDamage}데미지</span> (${(satelliteCooldown / 1000).toFixed(1)}초)`);
            }

            if (specialWeapons.length > 0) {
                statsHTML += `
                    <div class="pause-stats-section">
                        <div class="pause-stats-title">특수 무기</div>
                        ${specialWeapons.map(w => `<div class="pause-stat-item">• ${w}</div>`).join('')}
                    </div>
                `;
            }

            // 보조 능력
            statsHTML += `
                <div class="pause-stats-section">
                    <div class="pause-stats-title">보조</div>
                    <div class="pause-stat-item">XP 수집 범위: <span class="pause-stat-value">${magnetRange}</span></div>
                </div>
            `;

            statsContainer.innerHTML = statsHTML;
            document.getElementById('confirmModal').style.display = 'block';
            // 확인 모달 시 에너지 UI 숨김 (게임 중이므로)
            updateHeartDisplayVisibility();
        }

        function closeConfirmModal() {
            document.getElementById('confirmModal').style.display = 'none';
            gameRunning = true;
            lastTime = Date.now();
            // 재개 시 에너지 UI 계속 숨김 (게임 중)
            updateHeartDisplayVisibility();
        }

        function confirmGoHome() {
            document.getElementById('confirmModal').style.display = 'none';
            document.getElementById('homeButton').style.display = 'none';
            goToMainMenu();
        }

        // 강화 비용 계산 함수
        function getUpgradeCost(level) {
            return Math.floor(GAME_CONSTANTS.UPGRADE_BASE_COST * Math.pow(GAME_CONSTANTS.UPGRADE_COST_MULTIPLIER, level));
        }

        // 강화 시 스탯 증가 계산
        function getUpgradedStats(baseStats, level) {
            const multiplier = 1 + (level * GAME_CONSTANTS.UPGRADE_STAT_MULTIPLIER);
            return {
                hp: Math.floor(baseStats.hp * multiplier),
                speed: baseStats.speed,
                damage: Math.floor(baseStats.damage * multiplier)
            };
        }

        // 캐릭터 강화 함수
        function upgradeCharacter(charId) {
            const char = characters.find(c => c.id === charId);
            if (!char || !char.unlocked) return;

            // 최대 강화 레벨 체크
            if (char.upgradeLevel >= GAME_CONSTANTS.MAX_UPGRADE_LEVEL) {
                showTossModal({
                    title: '최대 강화 레벨',
                    message: `이미 최대 강화 레벨입니다!\n(+${GAME_CONSTANTS.MAX_UPGRADE_LEVEL})`,
                    buttons: [{ text: '확인', color: 'secondary' }]
                });
                return;
            }

            // 강화 확인 모달 표시
            showUpgradeModal(char);
        }

        // 강화 모달 관련 함수
        function showUpgradeModal(char) {
            pendingUpgradeCharacter = char;
            const cost = getUpgradeCost(char.upgradeLevel);
            const nextLevel = char.upgradeLevel + 1;
            document.getElementById('upgradeModalText').textContent =
                `${char.name}을(를) +${nextLevel}로 강화하시겠습니까?\n비용: ${cost.toLocaleString()} 스크랩`;
            document.getElementById('upgradeModal').style.display = 'block';
        }

        function closeUpgradeModal() {
            document.getElementById('upgradeModal').style.display = 'none';
            pendingUpgradeCharacter = null;
        }

        // 캐릭터 로어 모달 함수
        function showCharacterLore(char) {
            // 강화된 스탯 계산
            const currentStats = getUpgradedStats(char.stats, char.upgradeLevel);

            // 모달 내용 채우기
            const iconElement = document.getElementById('loreCharacterIcon');
            const imagePath = getCharacterImagePath(char.id);
            if (imagePath) {
                iconElement.innerHTML = `<img src="${imagePath}" alt="${char.name}" />`;
            } else {
                iconElement.innerHTML = `<div style="font-size: 48px;">${char.icon}</div>`;
            }

            document.getElementById('loreCharacterName').textContent = char.name;
            document.getElementById('loreCharacterStats').textContent = `HP: ${currentStats.hp} | 공격력: ${currentStats.damage} | 속도: ${currentStats.speed}`;
            document.getElementById('loreUltimateDesc').textContent = char.ultimate;
            document.getElementById('loreCharacterDesc').textContent = char.description;

            // 모달 표시
            document.getElementById('characterLoreModal').style.display = 'flex';
        }

        function closeCharacterLore(event) {
            // event가 있고, 모달 배경을 클릭한 경우만 닫기 (content 클릭은 무시)
            if (event && event.target.className !== 'character-lore-modal') {
                return;
            }
            document.getElementById('characterLoreModal').style.display = 'none';
        }

        /**
         * Toss 스타일 모달 표시
         * @param {Object} options - 모달 옵션
         * @param {string} options.title - 모달 제목
         * @param {string} options.message - 모달 메시지
         * @param {Array} options.buttons - 버튼 배열 [{text, color, onClick}]
         *   - text: 버튼 텍스트
         *   - color: 'primary' | 'secondary' | 'danger' (기본값: 'primary')
         *   - onClick: 클릭 시 실행할 함수
         */
        function showTossModal(options) {
            const modal = document.getElementById('tossModal');
            const titleEl = document.getElementById('tossModalTitle');
            const messageEl = document.getElementById('tossModalMessage');
            const buttonsEl = document.getElementById('tossModalButtons');

            // 제목과 메시지 설정
            titleEl.textContent = options.title || '';
            messageEl.textContent = options.message || '';

            // 버튼 생성
            buttonsEl.innerHTML = '';
            const buttons = options.buttons || [{ text: '확인', color: 'primary' }];

            buttons.forEach(btn => {
                const button = document.createElement('button');
                button.className = `toss-modal-button ${btn.color || 'primary'}`;
                button.textContent = btn.text;
                button.onclick = () => {
                    if (btn.onClick) {
                        btn.onClick();
                    }
                    closeTossModal();
                };
                buttonsEl.appendChild(button);
            });

            // 모달 표시
            modal.classList.add('show');
        }

        /**
         * Toss 모달 닫기
         */
        function closeTossModal(event) {
            // event가 있고, 모달 배경을 클릭한 경우만 닫기
            if (event && !event.target.classList.contains('toss-modal')) {
                return;
            }
            const modal = document.getElementById('tossModal');
            modal.classList.remove('show');
        }

        // showTossModal을 전역으로 노출 (toss-integration.js에서 사용)
        window.showTossModal = showTossModal;

        function confirmUpgrade() {
            if (!pendingUpgradeCharacter) return;

            const char = pendingUpgradeCharacter;
            const cost = getUpgradeCost(char.upgradeLevel);

            if (totalGold >= cost) {
                totalGold -= cost;
                char.upgradeLevel++;
                document.getElementById('shopGold').textContent = totalGold;
                renderCharacters();
                playSFX('levelup');

                // 게임 진행 상황 저장
                saveGameProgress();
            } else {
                showTossModal({
                    title: '스크랩 부족',
                    message: '스크랩이 부족합니다!\n게임을 플레이해서 스크랩을 모아보세요.',
                    buttons: [{ text: '확인', color: 'danger' }]
                });
            }
            closeUpgradeModal();
        }

        function renderCharacters() {
            const grid = document.getElementById('characterGrid');
            grid.innerHTML = '';

            characters.forEach(char => {
                const card = document.createElement('div');
                card.className = 'character-card';
                if (!char.unlocked) card.classList.add('locked');
                if (char.id === selectedCharacter) card.classList.add('selected');

                // 강화된 스탯 계산
                const currentStats = getUpgradedStats(char.stats, char.upgradeLevel);
                const statsText = `HP: ${currentStats.hp}<br>공격: ${currentStats.damage}`;

                // 필살기 설명 - 카드에서는 제거하고 모달에서만 표시
                const ultimateText = '';

                // 캐릭터 아이콘/이미지 결정
                let iconHtml;
                const imagePath = getCharacterImagePath(char.id);

                if (imagePath) {
                    // SP-02~SP-06: 이미지 사용
                    iconHtml = `<img src="${imagePath}" style="width: 64px; height: 64px; image-rendering: pixelated; margin-bottom: 8px;" />`;
                } else {
                    // 기본 캐릭터: 이모지 사용
                    iconHtml = `<div class="character-icon">${char.icon}</div>`;
                }

                // 강화 레벨 표시
                const upgradeLevelText = char.unlocked && char.upgradeLevel > 0 ?
                    `<div style="color: #ffd700; font-size: 12px; margin-top: 4px;">⭐ +${char.upgradeLevel}</div>` : '';

                // 버튼 영역
                let statusHtml = '';
                if (!char.unlocked) {
                    statusHtml = `<div class="character-price"><img src="assets/lock.png" style="width: 14px; height: 14px; vertical-align: middle; image-rendering: pixelated;"> ${char.price.toLocaleString()} 스크랩</div>`;
                } else {
                    const isSelected = char.id === selectedCharacter;
                    statusHtml = isSelected ?
                        '<div style="color: #ffd700; font-size: 14px; font-weight: bold;">✓ 선택됨</div>' :
                        '<div style="color: #4ecca3; font-size: 12px; opacity: 0.7;">클릭하여 선택</div>';
                }

                // 해금된 캐릭터에게만 강화 버튼 HTML 추가
                let upgradeButtonHtml = '';
                if (char.unlocked) {
                    const isMaxLevel = char.upgradeLevel >= GAME_CONSTANTS.MAX_UPGRADE_LEVEL;
                    const upgradeCost = getUpgradeCost(char.upgradeLevel);

                    if (isMaxLevel) {
                        upgradeButtonHtml = `
                            <button class="character-upgrade-btn" disabled
                                style="background: #666; color: #999; border: none; padding: 8px 16px; border-radius: 5px; cursor: not-allowed; font-size: 12px; font-family: 'DungGeunMo', Arial, sans-serif; margin-top: 10px; width: 100%;">
                                MAX 강화
                            </button>
                        `;
                    } else {
                        upgradeButtonHtml = `
                            <button class="character-upgrade-btn" data-char-id="${char.id}"
                                style="background: #4ecca3; color: #1a1a2e; border: none; padding: 8px 16px; border-radius: 5px; cursor: pointer; font-size: 12px; font-family: 'DungGeunMo', Arial, sans-serif; margin-top: 10px; width: 100%;">
                                강화 (${upgradeCost.toLocaleString()} 스크랩)
                            </button>
                        `;
                    }
                }

                card.innerHTML = `
                    <button class="character-info-btn" data-char-id="${char.id}">i</button>
                    ${iconHtml}
                    <div class="character-name">${char.name}</div>
                    <div class="character-stats">${statsText}</div>
                    ${ultimateText}
                    ${upgradeLevelText}
                    ${statusHtml}
                    ${upgradeButtonHtml}
                `;

                // info 버튼 이벤트 리스너
                const infoBtn = card.querySelector('.character-info-btn');
                if (infoBtn) {
                    infoBtn.addEventListener('click', function (e) {
                        e.preventDefault();
                        e.stopPropagation();
                        showCharacterLore(char);
                    });
                }

                // 카드 클릭 이벤트
                if (!char.unlocked) {
                    card.onclick = (e) => {
                        // info 버튼 클릭이면 무시
                        if (e.target.classList.contains('character-info-btn')) {
                            return;
                        }
                        showUnlockModal(char);
                    };
                } else {
                    card.style.cursor = 'pointer';
                    card.onclick = (e) => {
                        // info 버튼 또는 강화 버튼 클릭이면 무시
                        if (e.target.classList.contains('character-upgrade-btn') ||
                            e.target.classList.contains('character-info-btn')) {
                            return;
                        }
                        selectedCharacter = char.id;
                        renderCharacters();
                    };
                }

                // 강화 버튼 이벤트 리스너 추가 (해금된 캐릭터만)
                if (char.unlocked && char.upgradeLevel < 9) {
                    const upgradeBtn = card.querySelector('.character-upgrade-btn');
                    if (upgradeBtn) {
                        upgradeBtn.addEventListener('click', function (e) {
                            e.preventDefault();
                            e.stopPropagation();
                            const charId = this.getAttribute('data-char-id');
                            upgradeCharacter(charId);
                        });
                    }
                }

                grid.appendChild(card);
            });
        }

        // 캐릭터 선택 함수
        function selectCharacter(charId) {
            selectedCharacter = charId;
            renderCharacters();
        }

        // 해금 모달 관련 함수
        function showUnlockModal(char) {
            pendingUnlockCharacter = char;
            document.getElementById('unlockModalText').textContent =
                `${char.name}을(를) ${char.price.toLocaleString()} 스크랩에 해금하시겠습니까?`;
            document.getElementById('unlockModal').style.display = 'block';
        }

        function closeUnlockModal() {
            document.getElementById('unlockModal').style.display = 'none';
            pendingUnlockCharacter = null;
        }

        function confirmUnlock() {
            if (!pendingUnlockCharacter) return;

            const char = pendingUnlockCharacter;
            if (totalGold >= char.price) {
                totalGold -= char.price;
                char.unlocked = true;
                selectedCharacter = char.id;
                document.getElementById('shopGold').textContent = totalGold;
                renderCharacters();
                playSFX('levelup');

                // 게임 진행 상황 저장
                saveGameProgress();
            } else {
                showTossModal({
                    title: '스크랩 부족',
                    message: '스크랩이 부족합니다!\n게임을 플레이해서 스크랩을 모아보세요.',
                    buttons: [{ text: '확인', color: 'danger' }]
                });
            }
            closeUnlockModal();
        }

        // 필살기 시스템
        function useUltimate() {
            if (!ultimateReady || !gameRunning) return;

            // SP-01 Viper: 4초 스턴 파동
            if (selectedCharacter === 'default') {
                // 노란 파동 생성
                const ultimateWave = {
                    x: player.x,
                    y: player.y,
                    radius: 50,
                    maxRadius: 800,
                    damage: 0, // 데미지 없음
                    life: 1200,
                    hitEnemies: new Set(),
                    isUltimate: true,
                    isStun: true // 스턴 파동
                };

                // 모든 적 스턴 처리
                enemies.forEach(enemy => {
                    enemy.stunned = true;
                    enemy.stunTimer = GAME_CONSTANTS.VIPER_STUN_DURATION;
                    enemy.stunShakeTimer = 0;
                });

                empWaves.push(ultimateWave);

                // 필살기 효과음
                ultimateSound.currentTime = 0;
                ultimateSound.volume = masterVolume * sfxVolume;
                ultimateSound.play().catch(err => console.log('Ultimate sound error:', err));

                // 쿨타임 시작
                ultimateReady = false;
                ultimateTimer = ultimateCooldown;
                updateUltimateButton();

                // 진동 피드백
                if (navigator.vibrate) {
                    navigator.vibrate([100, 50, 100, 50, 100, 50, 100]);
                }
            }
            // SP-02 Falcon: 10초 무적 보호막
            else if (selectedCharacter === 'warrior') {
                invincible = true;
                invincibleTimer = invincibleDuration;

                // 필살기 효과음
                ultimateSound.currentTime = 0;
                ultimateSound.volume = masterVolume * sfxVolume;
                ultimateSound.play().catch(err => console.log('Ultimate sound error:', err));

                // 쿨타임 시작
                ultimateReady = false;
                ultimateTimer = ultimateCooldown;
                updateUltimateButton();

                // 진동 피드백
                if (navigator.vibrate) {
                    navigator.vibrate([100, 50, 100]);
                }
            }
            // SP-03 Crane: 7초 분신
            else if (selectedCharacter === 'mage') {
                hasClone = true;
                cloneTimer = cloneDuration;
                // 분신 위치 초기화 (플레이어 옆에 배치)
                cloneX = player.x + 100;
                cloneY = player.y;

                // 필살기 효과음
                ultimateSound.currentTime = 0;
                ultimateSound.volume = masterVolume * sfxVolume;
                ultimateSound.play().catch(err => console.log('Ultimate sound error:', err));

                // 쿨타임 시작
                ultimateReady = false;
                ultimateTimer = ultimateCooldown;
                updateUltimateButton();

                // 진동 피드백
                if (navigator.vibrate) {
                    navigator.vibrate([50, 30, 50, 30, 50]);
                }
            }
            // SP-04 Rhino: 360도 직선 공격 x3 waves
            else if (selectedCharacter === 'archer') {
                radialBlastActive = true;
                radialBlastWaveCount = 0;
                radialBlastWaveTimer = 0;
                radialBlastProjectiles = [];

                // 첫 번째 wave 즉시 발사
                fireRadialBlastWave();

                // 필살기 효과음
                ultimateSound.currentTime = 0;
                ultimateSound.volume = masterVolume * sfxVolume;
                ultimateSound.play().catch(err => console.log('Ultimate sound error:', err));

                // 쿨타임 시작
                ultimateReady = false;
                ultimateTimer = ultimateCooldown;
                updateUltimateButton();

                // 진동 피드백
                if (navigator.vibrate) {
                    navigator.vibrate([50, 20, 50, 20, 50, 20, 50, 20, 50]);
                }
            }
            // SP-05 Specter: 중력 붕괴 (3초 끌어당김 → 1초 압축 → 폭발)
            else if (selectedCharacter === 'tank') {
                gravityCollapseActive = true;
                gravityCollapsePhase = 1; // 1단계: 끌어당김
                gravityCollapseTimer = 0;
                // 중력장을 플레이어 앞쪽(위쪽) 300픽셀 거리에 발사
                gravityCollapseX = player.x;
                gravityCollapseY = player.y - 300;
                invincible = true; // 필살기 중 무적

                // 필살기 효과음
                ultimateSound.currentTime = 0;
                ultimateSound.volume = masterVolume * sfxVolume;
                ultimateSound.play().catch(err => console.log('Ultimate sound error:', err));

                // 쿨타임 시작
                ultimateReady = false;
                ultimateTimer = ultimateCooldown;
                updateUltimateButton();

                // 진동 피드백
                if (navigator.vibrate) {
                    navigator.vibrate([200, 100, 200]);
                }
            }
            // SP-06 Phantom: 쌍검 회전 레이저 (3초간 180도씩 회전)
            else if (selectedCharacter === 'ninja') {
                dualLaserActive = true;
                dualLaserTimer = dualLaserDuration;
                dualLaser1Angle = -Math.PI / 2; // 레이저1: 위쪽에서 시계방향
                dualLaser2Angle = -Math.PI / 2; // 레이저2: 위쪽에서 반시계방향
                dualLaserHitEnemies = new Set();

                // 필살기 효과음
                ultimateSound.currentTime = 0;
                ultimateSound.volume = masterVolume * sfxVolume;
                ultimateSound.play().catch(err => console.log('Ultimate sound error:', err));

                // 쿨타임 시작 (Phantom은 35초)
                ultimateReady = false;
                ultimateTimer = GAME_CONSTANTS.PHANTOM_COOLDOWN;
                updateUltimateButton();

                // 진동 피드백
                if (navigator.vibrate) {
                    navigator.vibrate([30, 20, 30, 20, 30, 20, 30, 20, 30]);
                }
            }
        }

        // Rhino 필살기: 360도 방사형 투사체 발사
        function fireRadialBlastWave() {
            const projectileCount = 20; // 360도를 20개 방향으로 분할
            const angleStep = (Math.PI * 2) / projectileCount;

            for (let i = 0; i < projectileCount; i++) {
                const angle = angleStep * i;
                radialBlastProjectiles.push({
                    x: player.x,
                    y: player.y,
                    vx: Math.cos(angle) * 3, // 느린 속도 (3)
                    vy: Math.sin(angle) * 3,
                    size: 12, // 크기
                    life: 5000 // 5초 생존
                });
            }

            radialBlastWaveCount++;
        }

        function updateUltimateButton() {
            const button = document.getElementById('ultimateButton');
            const cooldownText = document.getElementById('ultimateCooldown');

            if (ultimateReady) {
                button.classList.remove('cooldown');
                button.classList.add('ready');
                cooldownText.textContent = '';
            } else {
                button.classList.remove('ready');
                button.classList.add('cooldown');
                const seconds = Math.ceil(ultimateTimer / 1000);
                cooldownText.textContent = seconds;
            }
        }

        // 보스 사망 애니메이션 시작
        function startBossDeathAnimation(bossEnemy) {
            bossDeathAnimation = true;
            bossDeathTimer = 0;

            // 보스 스프라이트 가져오기
            const stageId = bossEnemy.stageId || selectedStage || 1;
            const bossKey = `stage${stageId}`;
            const bossSprite = bossSprites[bossKey];

            dyingBoss = {
                x: bossEnemy.x,
                y: bossEnemy.y,
                size: bossEnemy.size || 50,
                sprite: bossSprite
            };
            bossDeathFlashTimer = 0;
            gameRunning = false; // 게임 일시정지

            // 보스 처치 보상: 뽑기권 드롭 체크
            checkBossTicketDrop();

            // 강력한 진동 및 화면 흔들림
            triggerScreenShake(15);  // 매우 강한 흔들림 (15픽셀)
            if (navigator.vibrate) {
                navigator.vibrate([100, 50, 100, 50, 100, 50, 100, 50, 100, 50, 500]);
            }

            // 보스 사망 사운드 재생 (폴백 포함)
            // 1. 프로시저럴 사운드를 먼저 재생 (확실히 작동)
            playSFX('bossdeath');

            // 2. 레트로 폭발 사운드도 시도 (추가 효과)
            try {
                bossExplosionSound.currentTime = 0;
                bossExplosionSound.volume = masterVolume * sfxVolume;
                const playPromise = bossExplosionSound.play();
                if (playPromise !== undefined) {
                    playPromise
                        .then(() => {
                            console.log('Boss explosion sound played');
                        })
                        .catch(err => {
                            console.log('Boss explosion sound error:', err);
                        });
                }
            } catch (err) {
                console.log('Boss explosion sound exception:', err);
            }
        }

        function updateGoldUI() {
            document.getElementById('goldAmount').textContent = currentGold;
            const goldMenuEl = document.getElementById('currentGoldMenu');
            if (goldMenuEl) {
                goldMenuEl.textContent = totalGold;
            }
            const shopGoldEl = document.getElementById('shopGold');
            if (shopGoldEl) {
                shopGoldEl.textContent = totalGold;
            }
        }

        function restartGame() {
            document.getElementById('gameOver').style.display = 'none';
            document.getElementById('homeButton').style.display = 'flex';
            document.getElementById('ultimateButton').style.display = 'flex';

            // 키 입력 및 터치 초기화
            Object.keys(keys).forEach(key => keys[key] = false);
            touchActive = false;

            // 최고기록 업데이트
            document.getElementById('bestTimeDisplay').textContent = bestTime;
            document.getElementById('bestKillsDisplay').textContent = bestKills;

            const char = characters.find(c => c.id === selectedCharacter);
            const upgradedStats = getUpgradedStats(char.stats, char.upgradeLevel);
            player.maxHp = upgradedStats.hp;
            player.hp = upgradedStats.hp;
            player.speed = upgradedStats.speed;
            console.log('restartGame: player.speed set to', player.speed);

            player.x = window.innerWidth / 2;
            player.y = window.innerHeight / 2;
            player.xp = 0;
            player.level = 1;
            player.xpNeeded = 10;

            enemies.length = 0;
            projectiles.length = 0;
            missiles.length = 0;
            lightnings.length = 0;
            enemyProjectiles.length = 0;
            xpOrbs.length = 0;
            goldOrbs.length = 0;
            meleeWeapons.length = 0;

            kills = 0;
            gameTime = 0;
            shootTimer = 0;
            missileTimer = 0;
            currentGold = 0;

            weaponDamage = upgradedStats.damage;
            weaponSpeed = 350;
            projectileSpeed = 5;
            projectileCount = 1;
            projectilePiercing = 0;

            hasMissile = false;
            missileCount = 0;
            missileDamage = 25;
            missileSpeed = 4;
            missilePiercing = 0;

            // EMP 파장 초기화
            hasEMP = false;
            empDamage = 30;
            empTimer = 0;
            empCooldown = 2000;  // 3000 -> 2000 (50% 향상)
            empRadius = 200;  // 100 -> 200 (100% 향상)
            empWaves.length = 0;

            // 미니 드론 초기화
            miniDrones.length = 0;
            miniDroneRotation = 0;
            miniDroneShootTimer = 0;

            // 위성 지원 초기화
            hasSatellite = false;
            satelliteDamage = 40;
            satelliteTimer = 0;
            satelliteCooldown = 2500;

            meleeCount = 0;
            meleeDamage = 0;
            meleeOrbitRadius = 0;
            meleeRotation = 0;

            magnetRange = 100;

            isPlayerHit = false;
            hitFlashTime = 0;
            bossSpawned = false;
            boss = null;

            // 필살기 초기화
            ultimateReady = true;
            ultimateTimer = 0;
            updateUltimateButton();

            // Falcon & Crane 필살기 초기화
            invincible = false;
            invincibleTimer = 0;
            hasClone = false;
            cloneTimer = 0;

            updateGoldUI();
            gameRunning = true;
            lastTime = Date.now();
        }

        // 스테이지 1 시간대별 적 타입 비율 계산
        function getEnemyTypeForStage1() {
            const timeMinutes = gameTime / 60000; // 분 단위로 변환

            if (timeMinutes < 1) {
                // 0~1분: 기본 85%, 원거리 15%
                return { melee: 0.85, purple: 0.0, ranged: 0.15 };
            } else if (timeMinutes < 2) {
                // 1~2분: 기본 60%, 보라 25%, 원거리 15%
                return { melee: 0.6, purple: 0.25, ranged: 0.15 };
            } else {
                // 2~3분 (보스 전): 기본 50%, 보라 30%, 원거리 20%
                return { melee: 0.5, purple: 0.3, ranged: 0.2 };
            }
        }

        function spawnEnemy() {
            const side = Math.floor(Math.random() * 4);
            let x, y;

            switch (side) {
                case 0: x = Math.random() * window.innerWidth; y = -20; break;
                case 1: x = window.innerWidth + 20; y = Math.random() * window.innerHeight; break;
                case 2: x = Math.random() * window.innerWidth; y = window.innerHeight + 20; break;
                case 3: x = -20; y = Math.random() * window.innerHeight; break;
            }

            // 게임 모드에 따라 적 타입 확률 결정
            let enemyTypes;
            if (gameMode === 'story') {
                const stage = stages.find(s => s.id === selectedStage);
                // 스테이지 1은 시간대별 적 비율 적용
                enemyTypes = (selectedStage === 1) ? getEnemyTypeForStage1() : stage.enemyTypes;
            } else {
                // 무한 모드: 5분마다 스테이지 전환
                const timeInMinutes = gameTime / 60000;
                if (timeInMinutes < 5) {
                    // 0~5분: 스테이지 1 적
                    enemyTypes = stages[0].enemyTypes;
                } else if (timeInMinutes < 10) {
                    // 5~10분: 스테이지 2 적
                    enemyTypes = stages[1].enemyTypes;
                } else if (timeInMinutes < 15) {
                    // 10~15분: 스테이지 3 적
                    enemyTypes = stages[2].enemyTypes;
                } else {
                    // 15분 이후: 모든 적 혼합
                    enemyTypes = { melee: 0.33, purple: 0.33, ranged: 0.34 };
                }
            }

            let speedMultiplier = (1 + (gameTime / 300000)) * (isMobile ? 1.5 : 0.7);

            // 적 슬로우다운 효과 적용
            if (itemBonuses.enemySlowdown > 0) {
                speedMultiplier *= (1 - itemBonuses.enemySlowdown);
            }

            let hpMultiplier = 1 + (gameTime / 240000);

            // 스테이지별 체력 배수 추가
            if (gameMode === 'story' && selectedStage === 2) {
                hpMultiplier *= 1.5;  // 스테이지 2: 1.5배
            } else if (gameMode === 'story' && selectedStage === 3) {
                hpMultiplier *= 2;    // 스테이지 3: 2배
            }

            // 적 타입 확률
            const roll = Math.random();
            const meleeThreshold = enemyTypes.melee;
            const purpleThreshold = meleeThreshold + enemyTypes.purple;

            if (roll < meleeThreshold) {
                // 기본 적: 1x 체력 (60 HP = 2방)
                enemies.push({
                    x: x,
                    y: y,
                    size: 10 * sizeScale,  // 33% 축소 (15 → 10)
                    speed: (0.64 + Math.random() * 0.24) * speedMultiplier,
                    hp: 60 * hpMultiplier,
                    maxHp: 60 * hpMultiplier,
                    type: 'melee'
                });
            } else if (roll < purpleThreshold) {
                // 보라 적: 2x 체력 (120 HP = 4방)
                enemies.push({
                    x: x,
                    y: y,
                    size: 12 * sizeScale,  // 33% 축소 (18 → 12)
                    speed: (1.2 + Math.random() * 0.4) * speedMultiplier,
                    hp: 120 * hpMultiplier,
                    maxHp: 120 * hpMultiplier,
                    type: 'purple',
                    shape: 'square'
                });
            } else {
                // 원거리 적: 4x 체력 (240 HP = 8방)
                enemies.push({
                    x: x,
                    y: y,
                    size: 8 * sizeScale,  // 33% 축소 (12 → 8)
                    speed: (0.8 + Math.random() * 0.32) * speedMultiplier,
                    hp: 240 * hpMultiplier,
                    maxHp: 240 * hpMultiplier,
                    type: 'ranged',
                    shootTimer: 0,
                    shootCooldown: 3000
                });
            }
        }

        function spawnBoss(stageId = 1, difficultyMultiplier = 1) {
            if (bossSpawned || boss) return;

            bossSpawned = true;
            const centerX = window.innerWidth / 2;
            const centerY = -100;  // 화면 위에서 등장

            // 스테이지별 보스 설정
            let bossConfig = {};
            if (stageId === 1) {
                // Stage 1 보스: 기본 패턴 (8방향 방사형)
                bossConfig = {
                    hp: Math.floor(40000 * difficultyMultiplier),
                    maxHp: Math.floor(40000 * difficultyMultiplier),
                    speed: 1.2,
                    shootCooldown: Math.max(500, Math.floor(1500 / difficultyMultiplier)),
                    horizontalSpeed: 3,
                    pattern: 'radial',
                    stageId: 1
                };
            } else if (stageId === 2) {
                // Stage 2 보스: 빠른 공격 + 나선형 패턴
                bossConfig = {
                    hp: Math.floor(56000 * difficultyMultiplier),
                    maxHp: Math.floor(56000 * difficultyMultiplier),
                    speed: 1.5,
                    shootCooldown: Math.max(400, Math.floor(1000 / difficultyMultiplier)),
                    horizontalSpeed: 4,
                    pattern: 'spiral',
                    spiralAngle: 0,
                    stageId: 2
                };
            } else if (stageId === 3) {
                // Stage 3 보스: 높은 체력 + 복합 패턴 (방사형 + 플레이어 타겟)
                bossConfig = {
                    hp: Math.floor(80000 * difficultyMultiplier),
                    maxHp: Math.floor(80000 * difficultyMultiplier),
                    speed: 1.8,
                    shootCooldown: Math.max(300, Math.floor(800 / difficultyMultiplier)),
                    horizontalSpeed: 5,
                    pattern: 'mixed',
                    patternCounter: 0,
                    stageId: 3
                };
            }

            // 적 슬로우다운 효과를 보스에도 적용
            let bossSpeed = bossConfig.speed;
            if (itemBonuses.enemySlowdown > 0) {
                bossSpeed *= (1 - itemBonuses.enemySlowdown);
            }

            boss = {
                x: centerX,
                y: centerY,
                size: 60 * sizeScale,
                speed: bossSpeed,
                hp: bossConfig.hp,
                maxHp: bossConfig.maxHp,
                type: 'boss',
                shootTimer: 0,
                shootCooldown: bossConfig.shootCooldown,
                phaseTimer: 0,
                phase: 1,
                isBoss: true,
                moveDirection: 1,
                horizontalSpeed: bossConfig.horizontalSpeed,
                moveTimer: 0,
                moveDuration: 2000,
                idleDuration: 3000,
                isMoving: false,
                pattern: bossConfig.pattern,
                spiralAngle: bossConfig.spiralAngle || 0,
                patternCounter: bossConfig.patternCounter || 0,
                stageId: bossConfig.stageId,
                difficultyLevel: Math.max(1, Math.floor(difficultyMultiplier))  // 난이도 레벨 (1, 2, 3, ...)
            };

            enemies.push(boss);
        }

        function stageClear() {
            gameRunning = false;

            // 다음 스테이지 해금
            const nextStageId = selectedStage + 1;
            const nextStage = stages.find(s => s.id === nextStageId);
            if (nextStage) {
                nextStage.unlocked = true;
            }

            // 게임 진행 상황 저장 (스테이지 언락)
            saveGameProgress();

            // Toss 점수 저장 (스테이지 클리어)
            if (window.tossIntegration && window.tossIntegration.isAuthenticated) {
                window.tossIntegration.saveScore({
                    score: kills * 10 + Math.floor(gameTime / 1000),
                    kills: kills,
                    time: gameTime,
                    mode: gameMode,
                    stage: selectedStage,
                    cleared: true
                }).catch(err => console.error('Failed to save score to Toss:', err));
            }

            // 스테이지 클리어 화면 표시
            const clearDiv = document.createElement('div');
            clearDiv.id = 'stageClearScreen';
            clearDiv.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.9);
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                z-index: 1000;
                color: white;
                font-family: 'DungGeunMo', 'Arial', sans-serif;
            `;

            clearDiv.innerHTML = `
                <h1 style="font-size: clamp(2em, 8vw, 4em); margin-bottom: 20px; color: #4CAF50; white-space: nowrap;">스테이지 클리어!</h1>
                <p style="font-size: 1.5em; margin-bottom: 10px; white-space: nowrap;">처치: ${kills}</p>
                <p style="font-size: 1.5em; margin-bottom: 10px; white-space: nowrap;">생존 시간: ${Math.floor(gameTime / 1000)}초</p>
                <p style="font-size: 1.5em; margin-bottom: 30px; white-space: nowrap;">획득 스크랩: ${currentGold}</p>
                ${nextStage ? `<p style="font-size: clamp(0.9em, 3vw, 1.2em); margin-bottom: 30px; color: #FFD700; white-space: nowrap;">다음 스테이지가 해금되었습니다!</p>` : `<p style="font-size: clamp(0.9em, 3vw, 1.2em); margin-bottom: 30px; color: #FFD700; white-space: nowrap;">모든 스테이지를 클리어했습니다!</p>`}
                <div style="display: flex; gap: 20px;">
                    <button onclick="returnToMenu()" style="padding: 15px 40px; font-size: 1.2em; cursor: pointer; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none; border-radius: 10px;">메인 메뉴</button>
                    ${nextStage ? `<button onclick="nextStage()" style="padding: 15px 40px; font-size: 1.2em; cursor: pointer; background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); color: white; border: none; border-radius: 10px;">다음 스테이지</button>` : ''}
                </div>
            `;

            document.body.appendChild(clearDiv);

            // 1초 후 광고 표시
            setTimeout(() => {
                showStageClearAd();
            }, 1000);
        }

        function nextStage() {
            const clearScreen = document.getElementById('stageClearScreen');
            if (clearScreen) clearScreen.remove();

            selectedStage = selectedStage + 1;
            selectStage(selectedStage);
        }

        function returnToMenu() {
            const clearScreen = document.getElementById('stageClearScreen');
            if (clearScreen) clearScreen.remove();

            document.getElementById('homeButton').style.display = 'none';
            document.getElementById('mainMenu').style.display = 'flex';
        }

        function shootProjectiles() {
            if (enemies.length === 0) return;

            const nearest = findNearestEnemy();
            if (!nearest) return;

            const targetAngle = Math.atan2(nearest.y - player.y, nearest.x - player.x);
            const projectileData = [];

            if (projectileCount === 1) {
                // 1개: 중앙에서 정면으로
                projectileData.push({
                    angle: targetAngle,
                    offsetX: 0,
                    offsetY: 0
                });
            } else if (projectileCount === 2) {
                // 2개: 좌우로 나란히 평행하게
                const perpAngle = targetAngle + Math.PI / 2; // 90도 회전 (좌우 방향)
                const offset = 15; // 좌우 간격
                projectileData.push({
                    angle: targetAngle,
                    offsetX: Math.cos(perpAngle) * offset,
                    offsetY: Math.sin(perpAngle) * offset
                });
                projectileData.push({
                    angle: targetAngle,
                    offsetX: Math.cos(perpAngle) * -offset,
                    offsetY: Math.sin(perpAngle) * -offset
                });
            } else {
                // 3개 이상: 부채꼴로 퍼뜨림
                const spread = Math.PI / 6;
                const angleStep = (spread * 2) / (projectileCount - 1);
                for (let i = 0; i < projectileCount; i++) {
                    projectileData.push({
                        angle: targetAngle - spread + (i * angleStep),
                        offsetX: 0,
                        offsetY: 0
                    });
                }
            }

            projectileData.forEach(data => {
                if (projectiles.length < MAX_PROJECTILES) {
                    projectiles.push({
                        x: player.x + data.offsetX,
                        y: player.y + data.offsetY,
                        vx: Math.cos(data.angle) * projectileSpeed,
                        vy: Math.sin(data.angle) * projectileSpeed,
                        size: 2.5 * sizeScale,
                        damage: weaponDamage,
                        piercing: projectilePiercing,
                        hitCount: 0
                    });
                }
            });

            // SFX for shooting
            if (Math.random() < 0.3) {  // Only play 30% of the time to avoid spam
                playSFX('shoot');
            }

            // Crane 분신도 동일하게 발사
            if (hasClone) {
                projectileData.forEach(data => {
                    if (projectiles.length < MAX_PROJECTILES) {
                        projectiles.push({
                            x: cloneX + data.offsetX,
                            y: cloneY + data.offsetY,
                            vx: Math.cos(data.angle) * projectileSpeed,
                            vy: Math.sin(data.angle) * projectileSpeed,
                            size: 2.5 * sizeScale,
                            damage: weaponDamage,
                            piercing: projectilePiercing,
                            hitCount: 0
                        });
                    }
                });
            }
        }

        function shootMissiles() {
            if (enemies.length === 0 || missileCount === 0) return;

            for (let i = 0; i < missileCount; i++) {
                if (missiles.length >= MAX_MISSILES) break;
                const nearest = findNearestEnemy();
                if (nearest) {
                    const angle = Math.atan2(nearest.y - player.y, nearest.x - player.x);
                    missiles.push({
                        x: player.x,
                        y: player.y,
                        vx: Math.cos(angle) * missileSpeed,
                        vy: Math.sin(angle) * missileSpeed,
                        size: 3 * sizeScale,  // 크기 반으로 줄임 (6 → 3)
                        damage: missileDamage,
                        target: nearest,
                        hitCount: 0,  // 관통 카운터
                        hitEnemies: []  // 맞은 적 추적 (중복 방지)
                    });

                    // Crane 분신도 미사일 발사
                    if (hasClone && missiles.length < MAX_MISSILES) {
                        const cloneAngle = Math.atan2(nearest.y - cloneY, nearest.x - cloneX);
                        missiles.push({
                            x: cloneX,
                            y: cloneY,
                            vx: Math.cos(cloneAngle) * missileSpeed,
                            vy: Math.sin(cloneAngle) * missileSpeed,
                            size: 3 * sizeScale,
                            damage: missileDamage,
                            target: nearest,
                            hitCount: 0,  // 관통 카운터
                            hitEnemies: []  // 맞은 적 추적 (중복 방지)
                        });
                    }
                }
            }
        }

        // EMP 파장 공격 - 플레이어 주변에 파장 생성
        function empBlast() {
            if (!hasEMP) return;

            // EMP 파장 생성
            empWaves.push({
                x: player.x,
                y: player.y,
                radius: 0,
                maxRadius: empRadius,
                life: 800,  // 파장 지속 시간
                damage: empDamage,
                hitEnemies: new Set()  // 이미 피해를 준 적 추적
            });
        }

        // 위성 지원 공격 (기존 lightning)
        function satelliteStrike() {
            if (!hasSatellite || enemies.length === 0) return;

            const nearest = findNearestEnemy();
            if (nearest && lightnings.length < MAX_LIGHTNINGS) {
                lightnings.push({
                    x: nearest.x,
                    y: nearest.y,
                    target: nearest,
                    damage: satelliteDamage,
                    life: 500
                });

                nearest.hp -= satelliteDamage;
                if (nearest.hp <= 0) {
                    // 보스 처치 체크
                    if (nearest.isBoss) {
                        if (gameMode === 'story') {
                            // 스토리: 스크랩만 즉시 지급 (경험치 불필요)
                            currentGold += 1000;
                            totalGold += 1000;
                            updateGoldUI();
                        } else {
                            // 무한: 경험치 + 스크랩 드랍
                            dropXP(nearest.x, nearest.y, 200);
                            dropGold(nearest.x, nearest.y, 500);
                        }
                        const index = enemies.indexOf(nearest);
                        if (index > -1) {
                            kills++;
                            // 보스 사망 애니메이션 시작
                            startBossDeathAnimation(nearest);
                            enemies.splice(index, 1);
                        }
                    } else {
                        // XP 100% 드롭
                        dropXP(nearest.x, nearest.y, 5);
                        // 골드 드랍 확률 60%
                        if (Math.random() < 0.6) {
                            dropGold(nearest.x, nearest.y, Math.floor(Math.random() * 3) + 1);
                        }
                        const index = enemies.indexOf(nearest);
                        if (index > -1) {
                            enemies.splice(index, 1);
                            kills++;
                        }
                    }
                }
            }
        }

        function findNearestEnemy() {
            let nearest = null;
            let minDist = Infinity;

            // Spatial grid 사용 - 주변 셀만 검사
            const nearbyEnemies = enemyGrid.getNearby(player.x, player.y, 2);

            nearbyEnemies.forEach(enemy => {
                const dist = Math.hypot(enemy.x - player.x, enemy.y - player.y);
                if (dist < minDist) {
                    minDist = dist;
                    nearest = enemy;
                }
            });

            // 주변에 없으면 전체 검색 (fallback)
            if (!nearest && enemies.length > 0) {
                enemies.forEach(enemy => {
                    const dist = Math.hypot(enemy.x - player.x, enemy.y - player.y);
                    if (dist < minDist) {
                        minDist = dist;
                        nearest = enemy;
                    }
                });
            }

            return nearest;
        }

        function dropXP(x, y, amount) {
            if (xpOrbs.length >= MAX_XP_ORBS) {
                // 오래된 XP 제거
                xpOrbs.shift();
            }
            xpOrbs.push({
                x: x,
                y: y,
                size: 8 * sizeScale,
                value: amount,
                magnetized: false,
                // 둥둥 떠다니는 연출
                floatOffset: 0,
                floatSpeed: Math.random() * 0.002 + 0.001,
                floatTime: 0
            });
        }

        function dropGold(x, y, amount) {
            if (goldOrbs.length >= MAX_GOLD_ORBS) {
                // 오래된 골드 제거
                goldOrbs.shift();
            }
            goldOrbs.push({
                x: x,
                y: y,
                size: 7 * sizeScale,  // 30% 감소 (10 → 7)
                value: amount,
                magnetized: false,
                // 둥둥 떠다니는 연출
                floatOffset: 0,
                floatSpeed: Math.random() * 0.002 + 0.001, // 랜덤 속도
                floatTime: 0
            });
        }

        function levelUp() {
            player.level++;
            player.xp = 0;
            player.xpNeeded = Math.floor(player.xpNeeded * 2.0);  // 레벨업 속도 조정 (2.0배로 증가, 더 느리게)

            // SFX and haptic feedback for level up
            playSFX('levelup');
            if (navigator.vibrate) {
                navigator.vibrate([100, 50, 100]);
            }

            gameRunning = false;
            showUpgradeOptions();
        }

        function showUpgradeOptions() {
            const levelUpDiv = document.getElementById('levelUp');
            const optionsDiv = document.getElementById('upgradeOptions');
            optionsDiv.innerHTML = '';

            const rarityRoll = () => {
                const roll = Math.random();
                if (roll < 0.5) return 'common';
                if (roll < 0.75) return 'uncommon';
                if (roll < 0.90) return 'rare';
                if (roll < 0.97) return 'epic';
                return 'legend';
            };

            const rarityNames = {
                common: 'Common',
                uncommon: 'Uncommon',
                rare: 'Rare',
                epic: 'Epic',
                legend: 'Legend'
            };

            const rarityMultiplier = {
                common: 1,
                uncommon: 1.5,
                rare: 2,
                epic: 3,
                legend: 5
            };

            const upgrades = [
                {
                    name: '화력 강화',
                    baseDesc: '무기 데미지',
                    baseValue: 5,
                    apply: (rarity) => { weaponDamage += 5 * rarityMultiplier[rarity]; }
                },
                {
                    name: '연사 속도',
                    baseDesc: '발사 쿨다운',
                    baseValue: 50,
                    apply: (rarity) => { weaponSpeed = Math.max(100, weaponSpeed - (50 * rarityMultiplier[rarity])); }
                },
                {
                    name: '탄속 향상',
                    baseDesc: '투사체 속도',
                    baseValue: 1,
                    apply: (rarity) => { projectileSpeed += 1 * rarityMultiplier[rarity]; }
                },
                {
                    name: '다연장 시스템',
                    baseDesc: '발사 투사체',
                    baseValue: 1,
                    apply: (rarity) => { projectileCount += Math.ceil(1 * rarityMultiplier[rarity]); }
                },
                {
                    name: '관통탄',
                    baseDesc: '관통력',
                    baseValue: 1,
                    apply: (rarity) => { projectilePiercing += Math.ceil(1 * rarityMultiplier[rarity]); }
                },
                {
                    name: '유도 미사일',
                    baseDesc: hasMissile ? '미사일 수' : '미사일 시스템 가동',
                    baseValue: 1,
                    apply: (rarity) => { hasMissile = true; missileCount += Math.ceil(1 * rarityMultiplier[rarity]); }
                },
                {
                    name: 'EMP 파장',
                    baseDesc: hasEMP ? 'EMP 데미지' : 'EMP 시스템 가동',
                    baseValue: 20,
                    apply: (rarity) => { hasEMP = true; empDamage += 20 * rarityMultiplier[rarity]; }
                },
                {
                    name: 'EMP 충전',
                    baseDesc: 'EMP 쿨다운',
                    baseValue: 300,
                    condition: () => hasEMP,
                    apply: (rarity) => { empCooldown = Math.max(1000, empCooldown - (300 * rarityMultiplier[rarity])); }
                },
                {
                    name: 'EMP 범위',
                    baseDesc: 'EMP 파장 범위',
                    baseValue: 30,
                    condition: () => hasEMP,
                    apply: (rarity) => { empRadius += 30 * rarityMultiplier[rarity]; }
                },
                {
                    name: '위성 지원',
                    baseDesc: hasSatellite ? '위성 공격 데미지' : '위성 시스템 가동',
                    baseValue: 20,
                    apply: (rarity) => { hasSatellite = true; satelliteDamage += 20 * rarityMultiplier[rarity]; }
                },
                {
                    name: '위성 충전',
                    baseDesc: '위성 공격 쿨다운',
                    baseValue: 300,
                    condition: () => hasSatellite,
                    apply: (rarity) => { satelliteCooldown = Math.max(500, satelliteCooldown - (300 * rarityMultiplier[rarity])); }
                },
                {
                    name: '긴급 수리',
                    baseDesc: 'HP',
                    baseValue: 50,
                    apply: (rarity) => { player.hp = Math.min(player.maxHp, player.hp + (50 * rarityMultiplier[rarity])); }
                },
                {
                    name: '장갑 강화',
                    baseDesc: '최대 HP',
                    baseValue: 30,
                    apply: (rarity) => { const amount = 30 * rarityMultiplier[rarity]; player.maxHp += amount; player.hp += amount; }
                },
                {
                    name: '전리품 수집기',
                    baseDesc: 'XP 수집 범위',
                    baseValue: 50,
                    apply: (rarity) => { magnetRange += 50 * rarityMultiplier[rarity]; }
                }
            ];

            const available = upgrades.filter(u => !u.condition || u.condition());
            const selected = [];

            // 양자 프로세서 효과: 레벨업 선택지 증가 (기본 3개 + 아이템 효과)
            const upgradeChoiceCount = 3 + (itemBonuses.upgradeChoice || 0);

            while (selected.length < upgradeChoiceCount && available.length > 0) {
                const index = Math.floor(Math.random() * available.length);
                const upgrade = available[index];
                const rarity = rarityRoll();

                selected.push({
                    upgrade: upgrade,
                    finalRarity: rarity
                });
                available.splice(index, 1);
            }

            selected.forEach((item, idx) => {
                const multiplier = rarityMultiplier[item.finalRarity];
                const value = item.upgrade.baseValue * multiplier;
                const desc = item.upgrade.name === '연사 속도' || item.upgrade.name === 'EMP 충전' || item.upgrade.name === '위성 충전'
                    ? `${item.upgrade.baseDesc} -${(value / 1000).toFixed(1)}초`  // ms를 초 단위로 변환
                    : `+${Math.ceil(value)} ${item.upgrade.baseDesc}`;

                const div = document.createElement('div');
                div.className = `upgrade ${item.finalRarity}`;
                div.innerHTML = `
                    <div class="upgrade-rarity">${rarityNames[item.finalRarity]}</div>
                    <strong>${item.upgrade.name}</strong>
                    <div class="upgrade-desc">${desc}</div>
                `;

                let clicked = false;
                div.onclick = () => {
                    if (clicked) return;
                    clicked = true;
                    item.upgrade.apply(item.finalRarity);
                    levelUpDiv.style.display = 'none';
                    gameRunning = true;
                    lastTime = Date.now();
                    updateHeartDisplayVisibility();  // 에너지 UI 상태 업데이트
                };

                optionsDiv.appendChild(div);
            });

            levelUpDiv.style.display = 'block';
            updateHeartDisplayVisibility();  // 에너지 UI 숨김
        }

        function update(deltaTime) {
            // 화면 흔들림 업데이트 (게임 일시정지 중에도 작동)
            if (shakeIntensity > 0) {
                shakeX = (Math.random() - 0.5) * shakeIntensity * 2;
                shakeY = (Math.random() - 0.5) * shakeIntensity * 2;
                shakeIntensity *= 0.9; // 감쇠
                if (shakeIntensity < 0.1) {
                    shakeIntensity = 0;
                    shakeX = 0;
                    shakeY = 0;
                }
            }

            // 보스 사망 애니메이션 중이면 애니메이션만 업데이트
            if (bossDeathAnimation) {
                bossDeathTimer += deltaTime;
                bossDeathFlashTimer += deltaTime;

                // 애니메이션 종료
                if (bossDeathTimer >= bossDeathDuration) {
                    bossDeathAnimation = false;
                    dyingBoss = null;
                    boss = null;
                    bossSpawned = false;
                    gameRunning = true;

                    // 스토리 모드에서만 스테이지 클리어
                    if (gameMode === 'story') {
                        stageClear();
                    }
                }
                return;
            }

            if (!gameRunning) return;

            gameTime += deltaTime;

            // 필살기 쿨타임 업데이트
            if (!ultimateReady) {
                ultimateTimer -= deltaTime;
                if (ultimateTimer <= 0) {
                    ultimateReady = true;
                    ultimateTimer = 0;
                }
                updateUltimateButton();
            }

            // Falcon 무적 타이머
            if (invincible) {
                invincibleTimer -= deltaTime;
                if (invincibleTimer <= 0) {
                    invincible = false;
                    invincibleTimer = 0;
                }
            }

            // Crane 분신 타이머
            if (hasClone) {
                cloneTimer -= deltaTime;
                if (cloneTimer <= 0) {
                    hasClone = false;
                    cloneTimer = 0;
                }
                // 분신이 플레이어를 따라다님
                cloneX += (player.x + 100 - cloneX) * 0.1;
                cloneY += (player.y - cloneY) * 0.1;
            }

            // Rhino 360도 직선 공격 업데이트
            if (radialBlastActive) {
                radialBlastWaveTimer += deltaTime;

                // wave 딜레이 체크 및 다음 wave 발사
                if (radialBlastWaveCount < radialBlastMaxWaves && radialBlastWaveTimer >= radialBlastWaveDelay) {
                    fireRadialBlastWave();
                    radialBlastWaveTimer = 0;
                }

                // 투사체 업데이트
                for (let i = radialBlastProjectiles.length - 1; i >= 0; i--) {
                    const proj = radialBlastProjectiles[i];

                    // 일직선으로만 이동 (유도 없음)
                    proj.x += proj.vx;
                    proj.y += proj.vy;
                    proj.life -= deltaTime;

                    // 충돌 체크
                    for (let j = enemies.length - 1; j >= 0; j--) {
                        const enemy = enemies[j];
                        const dist = Math.hypot(enemy.x - proj.x, enemy.y - proj.y);
                        if (dist < enemy.size + proj.size) {
                            if (enemy.isBoss) {
                                // 보스는 큰 데미지
                                enemy.hp -= 1000;
                            } else {
                                // 일반 적은 즉사
                                enemy.hp = 0;

                                // XP와 골드 드롭
                                dropXP(enemy.x, enemy.y, 5);
                                if (Math.random() < 0.6) {
                                    dropGold(enemy.x, enemy.y, Math.floor(Math.random() * 3) + 1);
                                }

                                enemies.splice(j, 1);
                                kills++;
                                if (Math.random() < 0.5) playSFX('explosion');
                            }

                            // 투사체 제거 (관통 없음)
                            proj.life = 0;
                            break;
                        }
                    }

                    // 수명 다하거나 화면 벗어남
                    if (proj.life <= 0 || proj.x < -100 || proj.x > canvas.width + 100 || proj.y < -100 || proj.y > canvas.height + 100) {
                        radialBlastProjectiles.splice(i, 1);
                    }
                }

                // 모든 wave 발사 완료 및 투사체 소진 시 종료
                if (radialBlastWaveCount >= radialBlastMaxWaves && radialBlastProjectiles.length === 0) {
                    radialBlastActive = false;
                }
            }

            // Specter 중력 붕괴 업데이트
            if (gravityCollapseActive) {
                gravityCollapseTimer += deltaTime;

                // 1단계: 끌어당김 (3초)
                if (gravityCollapsePhase === 1) {
                    enemies.forEach(enemy => {
                        const dx = gravityCollapseX - enemy.x;
                        const dy = gravityCollapseY - enemy.y;
                        const dist = Math.hypot(dx, dy);

                        if (dist < gravityCollapseRadius) {
                            // 적을 중심으로 끌어당김
                            const pullStrength = 0.15;
                            enemy.x += dx * pullStrength;
                            enemy.y += dy * pullStrength;
                        }
                    });

                    if (gravityCollapseTimer >= gravityCollapsePullDuration) {
                        gravityCollapsePhase = 2; // 압축 단계로
                        gravityCollapseTimer = 0;
                    }
                }
                // 2단계: 압축 (1초)
                else if (gravityCollapsePhase === 2) {
                    enemies.forEach(enemy => {
                        const dx = gravityCollapseX - enemy.x;
                        const dy = gravityCollapseY - enemy.y;
                        const dist = Math.hypot(dx, dy);

                        if (dist < gravityCollapseRadius * 0.8) {
                            // 더 강하게 끌어당김
                            const pullStrength = 0.3;
                            enemy.x += dx * pullStrength;
                            enemy.y += dy * pullStrength;
                        }
                    });

                    if (gravityCollapseTimer >= gravityCollapseCompressDuration) {
                        gravityCollapsePhase = 3; // 폭발 단계로
                    }
                }
                // 3단계: 폭발 (즉시)
                else if (gravityCollapsePhase === 3) {
                    const explosionRadius = gravityCollapseRadius * 1.2;

                    // 폭발 데미지 처리
                    for (let i = enemies.length - 1; i >= 0; i--) {
                        const enemy = enemies[i];
                        const dist = Math.hypot(enemy.x - gravityCollapseX, enemy.y - gravityCollapseY);
                        if (dist < explosionRadius) {
                            const damage = enemy.isBoss ? 5000 : 3000;
                            enemy.hp -= damage;

                            if (enemy.hp <= 0 && !enemy.isBoss) {
                                // XP와 골드 드롭
                                dropXP(enemy.x, enemy.y, 5);
                                if (Math.random() < 0.6) {
                                    dropGold(enemy.x, enemy.y, Math.floor(Math.random() * 3) + 1);
                                }

                                enemies.splice(i, 1);
                                kills++;
                                if (Math.random() < 0.5) playSFX('explosion');
                            }
                        }
                    }

                    // 폭발 후 종료
                    gravityCollapseActive = false;
                    gravityCollapsePhase = 0;
                    gravityCollapseTimer = 0;
                    invincible = false; // 무적 해제

                    // 강력한 진동
                    if (navigator.vibrate) {
                        navigator.vibrate([200, 50, 200, 50, 200]);
                    }
                }
            }

            // Phantom 쌍검 회전 레이저 업데이트
            if (dualLaserActive) {
                dualLaserTimer -= deltaTime;
                if (dualLaserTimer <= 0) {
                    dualLaserActive = false;
                    dualLaserHitEnemies.clear();
                } else {
                    // 레이저 회전 (3초에 180도 = 60도/초)
                    const rotationSpeed = (Math.PI / 3000) * deltaTime; // 라디안/ms

                    // 레이저1: 시계방향 회전 (위 → 오른쪽 → 아래)
                    dualLaser1Angle += rotationSpeed;
                    // 레이저2: 반시계방향 회전 (위 → 왼쪽 → 아래)
                    dualLaser2Angle -= rotationSpeed;

                    const laser1Angle = dualLaser1Angle;
                    const laser2Angle = dualLaser2Angle;
                    const laserLength = 1500; // 레이저 길이

                    // 각 레이저의 끝점 계산
                    const laser1EndX = player.x + Math.cos(laser1Angle) * laserLength;
                    const laser1EndY = player.y + Math.sin(laser1Angle) * laserLength;
                    const laser2EndX = player.x + Math.cos(laser2Angle) * laserLength;
                    const laser2EndY = player.y + Math.sin(laser2Angle) * laserLength;

                    // 적 충돌 체크 (점-선분 거리)
                    enemies.forEach(enemy => {
                        // 프레임마다 한 번만 체크하기 위해 Set 사용
                        const enemyKey = `${enemy.x}_${enemy.y}_${Date.now()}`;

                        // 레이저 1 충돌
                        const dist1 = pointToLineDistance(enemy.x, enemy.y, player.x, player.y, laser1EndX, laser1EndY);
                        if (dist1 < enemy.size + 10) { // 레이저 두께 10
                            if (enemy.isBoss) {
                                enemy.hp -= 20; // 보스는 프레임당 20 데미지 (3초 = 약 3600 데미지)
                            } else {
                                // 일반 적은 즉사
                                enemy.hp = 0;
                            }
                        }

                        // 레이저 2 충돌
                        const dist2 = pointToLineDistance(enemy.x, enemy.y, player.x, player.y, laser2EndX, laser2EndY);
                        if (dist2 < enemy.size + 10) {
                            if (enemy.isBoss) {
                                enemy.hp -= 20;
                            } else {
                                enemy.hp = 0;
                            }
                        }

                        // 죽은 적 처리
                        if (enemy.hp <= 0 && !enemy.isBoss) {
                            // XP와 골드 드롭
                            dropXP(enemy.x, enemy.y, 5);
                            if (Math.random() < 0.6) {
                                dropGold(enemy.x, enemy.y, Math.floor(Math.random() * 3) + 1);
                            }
                            kills++;
                        }
                    });

                    // 죽은 적 제거
                    for (let i = enemies.length - 1; i >= 0; i--) {
                        if (enemies[i].hp <= 0 && !enemies[i].isBoss) {
                            enemies.splice(i, 1);
                            if (Math.random() < 0.5) playSFX('explosion');
                        }
                    }
                }
            }

            // Spatial grid 초기화 (매 프레임)
            enemyGrid.clear();
            enemies.forEach(enemy => enemyGrid.insert(enemy));

            // 배경 스크롤 업데이트
            if (backgroundSpriteLoaded) {
                const bgHeight = window.innerHeight;
                const bgAspect = backgroundSprite.width / backgroundSprite.height;
                const screenAspect = window.innerWidth / bgHeight;

                let drawHeight = bgHeight;
                if (screenAspect > bgAspect) {
                    drawHeight = window.innerWidth / bgAspect;
                }

                // 배경을 아래로 스크롤 (플레이어가 위로 이동하는 것처럼)
                backgroundY1 += backgroundScrollSpeed;
                backgroundY2 += backgroundScrollSpeed;

                // 배경이 화면 아래로 벗어나면 위로 재배치
                if (backgroundY1 >= bgHeight) {
                    backgroundY1 = backgroundY2 - drawHeight;
                }
                if (backgroundY2 >= bgHeight) {
                    backgroundY2 = backgroundY1 - drawHeight;
                }
            }

            // 드론 애니메이션 프레임 업데이트 (30FPS)
            animationTimer += deltaTime;
            if (animationTimer >= animationSpeed) {
                animationFrame = (animationFrame + 1) % animationFrameCount;
                animationTimer = 0;
            }

            if (isPlayerHit) {
                hitFlashTime += deltaTime;
                // 화면 흔들림 효과 (랜덤 오프셋)
                shakeOffsetX = (Math.random() - 0.5) * 8;
                shakeOffsetY = (Math.random() - 0.5) * 8;

                if (hitFlashTime >= 200) {
                    isPlayerHit = false;
                    hitFlashTime = 0;
                    shakeOffsetX = 0;
                    shakeOffsetY = 0;
                }
            }

            if (!touchActive) {
                const oldX = player.x;
                const oldY = player.y;

                if (keys['w'] || keys['arrowup']) player.y -= player.speed;
                if (keys['s'] || keys['arrowdown']) player.y += player.speed;
                if (keys['a'] || keys['arrowleft']) player.x -= player.speed;
                if (keys['d'] || keys['arrowright']) player.x += player.speed;

                // 이동 디버깅 (프레임당 한 번만)
                if ((oldX !== player.x || oldY !== player.y) && Math.random() < 0.01) {
                    console.log('Player speed:', player.speed, 'Moved:', Math.hypot(player.x - oldX, player.y - oldY));
                }

                player.x = Math.max(player.size, Math.min(window.innerWidth - player.size, player.x));
                player.y = Math.max(player.size, Math.min(window.innerHeight - player.size, player.y));
            }

            shootTimer += deltaTime;
            if (shootTimer >= weaponSpeed) {
                shootProjectiles();
                shootTimer = 0;
            }

            missileTimer += deltaTime;
            if (missileTimer >= missileCooldown && hasMissile) {
                shootMissiles();
                missileTimer = 0;
            }

            // EMP 파장 공격
            empTimer += deltaTime;
            if (empTimer >= empCooldown && hasEMP) {
                empBlast();
                empTimer = 0;
            }

            // EMP 파장 업데이트
            empWaves.forEach((wave, wIndex) => {
                wave.life -= deltaTime;
                wave.radius += (wave.maxRadius / 800) * deltaTime;  // 800ms 동안 확장

                if (wave.life <= 0) {
                    empWaves.splice(wIndex, 1);
                    return;
                }

                // 파장에 닿은 적에게 피해
                enemies.forEach((enemy, eIndex) => {
                    // 이미 피해를 준 적은 건너뛰기
                    if (wave.hitEnemies.has(enemy)) return;

                    const dist = Math.hypot(enemy.x - wave.x, enemy.y - wave.y);
                    // 파장의 링 두께 체크 (반지름 ±30 범위)
                    if (Math.abs(dist - wave.radius) < 30) {
                        wave.hitEnemies.add(enemy);
                        enemy.hp -= wave.damage;

                        if (enemy.hp <= 0) {
                            // 보스 처치 체크
                            if (enemy.isBoss) {
                                if (gameMode === 'story') {
                                    // 스토리: 스크랩만 즉시 지급 (경험치 불필요)
                                    currentGold += 1000;
                                    totalGold += 1000;
                                    updateGoldUI();
                                } else {
                                    // 무한: 경험치 + 스크랩 드랍
                                    dropXP(enemy.x, enemy.y, 200);
                                    dropGold(enemy.x, enemy.y, 500);
                                }
                                kills++;
                                // 보스 사망 애니메이션 시작
                                startBossDeathAnimation(enemy);
                                enemies.splice(eIndex, 1);
                            } else {
                                // SFX for regular enemy death
                                if (Math.random() < 0.5) {  // 50% 확률로 재생
                                    playSFX('explosion');
                                }
                                // XP 100% 드롭
                                dropXP(enemy.x, enemy.y, 5);
                                // 골드 드랍 확률 60%
                                if (Math.random() < 0.6) {
                                    dropGold(enemy.x, enemy.y, Math.floor(Math.random() * 3) + 1);
                                }
                                enemies.splice(eIndex, 1);
                                kills++;
                            }
                        }
                    }
                });
            });

            // 위성 지원 공격
            satelliteTimer += deltaTime;
            if (satelliteTimer >= satelliteCooldown && hasSatellite) {
                satelliteStrike();
                satelliteTimer = 0;
            }

            // 미니 드론 시스템 업데이트
            if (miniDrones.length > 0) {
                miniDroneRotation += miniDroneRotationSpeed;
                miniDroneShootTimer += deltaTime;

                if (miniDroneShootTimer >= miniDroneShootCooldown) {
                    // 각 미니 드론에서 가장 가까운 적 공격
                    miniDrones.forEach(drone => {
                        const droneAngle = miniDroneRotation + drone.angleOffset;
                        const droneX = player.x + Math.cos(droneAngle) * miniDroneOrbitRadius;
                        const droneY = player.y + Math.sin(droneAngle) * miniDroneOrbitRadius;

                        // 가장 가까운 적 찾기
                        let closestEnemy = null;
                        let closestDist = Infinity;
                        enemies.forEach(enemy => {
                            const dist = Math.hypot(droneX - enemy.x, droneY - enemy.y);
                            if (dist < closestDist) {
                                closestDist = dist;
                                closestEnemy = enemy;
                            }
                        });

                        // 보스도 타겟으로 추가
                        if (boss) {
                            const distToBoss = Math.hypot(droneX - boss.x, droneY - boss.y);
                            if (distToBoss < closestDist) {
                                closestDist = distToBoss;
                                closestEnemy = boss;
                            }
                        }

                        // 적이 있으면 투사체 발사
                        if (closestEnemy) {
                            const angle = Math.atan2(closestEnemy.y - droneY, closestEnemy.x - droneX);
                            projectiles.push({
                                x: droneX,
                                y: droneY,
                                vx: Math.cos(angle) * 8,
                                vy: Math.sin(angle) * 8,
                                size: 4,
                                damage: miniDroneDamage,
                                hitCount: 0,
                                isMiniDrone: true
                            });
                        }
                    });
                    miniDroneShootTimer = 0;
                }
            }

            // 게임 모드별 적 출현 및 보스 로직
            if (gameMode === 'story') {
                const stage = stages.find(s => s.id === selectedStage);

                // 보스 출현 체크 (스토리 모드에만)
                if (gameTime >= stage.bossTime && !bossSpawned) {
                    spawnBoss(selectedStage);
                }

                // 스테이지별 적 출현율 (시간에 따른 증가량 10배 상향)
                if (Math.random() < stage.spawnRate + (gameTime / 1000000)) {
                    spawnEnemy();
                }
            } else {
                // 무한 모드 - 5분마다 보스 출현 (순차적으로 1→2→3 반복, 사이클마다 강화)
                const currentBossInterval = Math.floor(gameTime / 300000); // 5분 = 300000ms

                // 새로운 5분 구간에 진입했고 보스가 없을 때 (첫 보스는 5분부터)
                if (currentBossInterval > 0 && currentBossInterval > lastBossSpawnTime && !bossSpawned && !boss) {
                    // 보스 스테이지를 1→2→3 순환
                    const bossStage = ((currentBossInterval - 1) % 3) + 1;

                    // 사이클 계산 (3번마다 1사이클 = 15분마다)
                    const cycle = Math.floor((currentBossInterval - 1) / 3);

                    // 난이도 배율: 사이클마다 50% 증가 (1.0 → 1.5 → 2.0 → 2.5 ...)
                    const difficultyMultiplier = 1 + (cycle * 0.5);

                    spawnBoss(bossStage, difficultyMultiplier);
                    lastBossSpawnTime = currentBossInterval;
                }

                // 적 출현 (난이도 시간에 따라 가파르게 증가)
                const timeInMinutes = gameTime / 60000;  // 분 단위로 변환
                const difficultyMultiplier = 1 + Math.pow(timeInMinutes / 2, 1.5);  // 지수적 증가 (2분마다 가속)
                if (Math.random() < endlessMode.spawnRate * difficultyMultiplier) {
                    spawnEnemy();
                }
            }

            enemies.forEach((enemy, eIndex) => {
                // 스턴 처리
                if (enemy.stunned) {
                    enemy.stunTimer -= deltaTime;
                    if (enemy.stunTimer <= 0) {
                        enemy.stunned = false;
                        enemy.stunTimer = 0;
                    } else {
                        // 흔들림 효과
                        enemy.stunShakeTimer = (enemy.stunShakeTimer || 0) + deltaTime;
                        const shakeFrequency = 50; // ms
                        if (enemy.stunShakeTimer >= shakeFrequency) {
                            enemy.stunShakeTimer = 0;
                        }
                        // 스턴 상태일 때는 움직임/공격 스킵
                        return;
                    }
                }

                if (enemy.type === 'boss') {
                    // 보스 AI
                    const dist = Math.hypot(player.x - enemy.x, player.y - enemy.y);

                    // 화면 중앙으로 이동 (등장 연출)
                    if (enemy.y < window.innerHeight / 3) {
                        enemy.y += enemy.speed;
                    } else {
                        // 5초 주기로 이동 (2초 이동, 3초 대기)
                        enemy.moveTimer += deltaTime;

                        if (enemy.isMoving) {
                            // 이동 중
                            enemy.x += enemy.horizontalSpeed * enemy.moveDirection;

                            // 화면 끝에 닿으면 방향 전환
                            if (enemy.x >= window.innerWidth - enemy.size) {
                                enemy.x = window.innerWidth - enemy.size;
                                enemy.moveDirection = -1;  // 왼쪽으로
                            } else if (enemy.x <= enemy.size) {
                                enemy.x = enemy.size;
                                enemy.moveDirection = 1;  // 오른쪽으로
                            }

                            // 2초 이동 후 대기
                            if (enemy.moveTimer >= enemy.moveDuration) {
                                enemy.isMoving = false;
                                enemy.moveTimer = 0;
                            }
                        } else {
                            // 대기 중
                            if (enemy.moveTimer >= enemy.idleDuration) {
                                enemy.isMoving = true;
                                enemy.moveTimer = 0;
                            }
                        }
                    }

                    // 보스 공격 패턴 (스테이지별)
                    enemy.shootTimer += deltaTime;
                    if (enemy.shootTimer >= enemy.shootCooldown) {
                        if (enemy.pattern === 'radial') {
                            // Stage 1: 8방향 방사형 탄막
                            for (let i = 0; i < 8; i++) {
                                if (enemyProjectiles.length >= MAX_ENEMY_PROJECTILES) break;
                                const angle = (Math.PI * 2 / 8) * i;
                                enemyProjectiles.push({
                                    x: enemy.x,
                                    y: enemy.y,
                                    vx: Math.cos(angle) * 4,
                                    vy: Math.sin(angle) * 4,
                                    size: 5 * sizeScale,  // 38% 축소 (8 → 5)
                                    damage: 15
                                });
                            }
                        } else if (enemy.pattern === 'spiral') {
                            // Stage 2: 나선형 패턴 (12방향, 회전)
                            for (let i = 0; i < 12; i++) {
                                if (enemyProjectiles.length >= MAX_ENEMY_PROJECTILES) break;
                                const angle = (Math.PI * 2 / 12) * i + enemy.spiralAngle;
                                enemyProjectiles.push({
                                    x: enemy.x,
                                    y: enemy.y,
                                    vx: Math.cos(angle) * 5,
                                    vy: Math.sin(angle) * 5,
                                    size: 5 * sizeScale,  // 38% 축소 (8 → 5)
                                    damage: 20
                                });
                            }
                            enemy.spiralAngle += 0.2; // 나선 회전
                        } else if (enemy.pattern === 'mixed') {
                            // Stage 3: 혼합 패턴 (방사형 + 플레이어 타겟)
                            enemy.patternCounter++;

                            if (enemy.patternCounter % 2 === 0) {
                                // 16방향 방사형
                                for (let i = 0; i < 16; i++) {
                                    if (enemyProjectiles.length >= MAX_ENEMY_PROJECTILES) break;
                                    const angle = (Math.PI * 2 / 16) * i;
                                    enemyProjectiles.push({
                                        x: enemy.x,
                                        y: enemy.y,
                                        vx: Math.cos(angle) * 6,
                                        vy: Math.sin(angle) * 6,
                                        size: 5 * sizeScale,  // 38% 축소 (8 → 5)
                                        damage: 25
                                    });
                                }
                            } else {
                                // 플레이어 방향으로 3발 산탄
                                const angleToPlayer = Math.atan2(player.y - enemy.y, player.x - enemy.x);
                                for (let i = -1; i <= 1; i++) {
                                    if (enemyProjectiles.length >= MAX_ENEMY_PROJECTILES) break;
                                    const spreadAngle = angleToPlayer + (i * 0.3);
                                    enemyProjectiles.push({
                                        x: enemy.x,
                                        y: enemy.y,
                                        vx: Math.cos(spreadAngle) * 7,
                                        vy: Math.sin(spreadAngle) * 7,
                                        size: 6 * sizeScale,  // 40% 축소 (10 → 6)
                                        damage: 25
                                    });
                                }
                            }
                        }
                        enemy.shootTimer = 0;
                    }
                } else if (enemy.type === 'ranged') {
                    const dist = Math.hypot(player.x - enemy.x, player.y - enemy.y);

                    if (dist > 550) {  // 550픽셀보다 멀면 접근
                        const angle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
                        enemy.x += Math.cos(angle) * enemy.speed;
                        enemy.y += Math.sin(angle) * enemy.speed;
                    } else if (dist < 450) {  // 450픽셀보다 가까우면 후퇴
                        const angle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
                        enemy.x -= Math.cos(angle) * enemy.speed * 0.5;
                        enemy.y -= Math.sin(angle) * enemy.speed * 0.5;
                    }

                    enemy.shootTimer += deltaTime;
                    if (enemy.shootTimer >= enemy.shootCooldown && dist < 1000) {  // 1000픽셀 이내에서 공격 (이전 값으로 복원)
                        if (enemyProjectiles.length < MAX_ENEMY_PROJECTILES) {
                            const angle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
                            enemyProjectiles.push({
                                x: enemy.x,
                                y: enemy.y,
                                vx: Math.cos(angle) * 3,
                                vy: Math.sin(angle) * 3,
                                size: 4 * sizeScale,  // 33% 축소 (6 → 4)
                                damage: 10
                            });
                        }
                        enemy.shootTimer = 0;
                    }
                } else {
                    const angle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
                    enemy.x += Math.cos(angle) * enemy.speed;
                    enemy.y += Math.sin(angle) * enemy.speed;
                }

                const dist = Math.hypot(player.x - enemy.x, player.y - enemy.y);
                if (dist < player.size + enemy.size) {
                    // 무적 상태가 아닐 때만 데미지
                    if (!invincible) {
                        // 회피 체크 (적과의 충돌은 연속이므로 프레임당 체크)
                        if (itemBonuses.dodgeChance > 0 && Math.random() < itemBonuses.dodgeChance * 0.1) {
                            // 충돌은 연속적이므로 회피 확률을 10%로 감소
                            return;
                        }

                        // 데미지 감소 적용
                        let damage = 0.08;
                        if (itemBonuses.damageReduction > 0) {
                            damage *= (1 - itemBonuses.damageReduction);
                        }

                        player.hp -= damage;
                        if (!isPlayerHit) {
                            isPlayerHit = true;
                            hitFlashTime = 0;
                            playSFX('hit');
                            triggerScreenShake(3);  // 약한 흔들림 (3픽셀)
                            if (navigator.vibrate) {
                                navigator.vibrate(50);
                            }
                        }
                        if (player.hp <= 0) {
                            if (!tryAutoRevive()) {
                                gameOver();
                            }
                        }
                    }
                }
            });

            projectiles.forEach((proj, pIndex) => {
                proj.x += proj.vx;
                proj.y += proj.vy;

                if (proj.x < -50 || proj.x > window.innerWidth + 50 || proj.y < -50 || proj.y > window.innerHeight + 50) {
                    projectiles.splice(pIndex, 1);
                    return;
                }

                enemies.forEach((enemy, eIndex) => {
                    const dist = Math.hypot(proj.x - enemy.x, proj.y - enemy.y);
                    if (dist < proj.size + enemy.size) {
                        // 크리티컬 데미지 계산
                        let damage = proj.damage;
                        if (itemBonuses.critChance > 0 && Math.random() < itemBonuses.critChance) {
                            damage *= (1 + (itemBonuses.critDamage || 0.5)); // 기본 크리티컬 데미지 50%
                            // 크리티컬 이펙트 (나중에 추가 가능)
                        }
                        enemy.hp -= damage;
                        proj.hitCount++;

                        if (proj.hitCount > proj.piercing) {
                            projectiles.splice(pIndex, 1);
                        }

                        if (enemy.hp <= 0) {
                            // 보스 처치 체크
                            if (enemy.isBoss) {
                                if (gameMode === 'story') {
                                    // 스토리: 스크랩만 즉시 지급 (경험치 불필요)
                                    currentGold += 1000;
                                    totalGold += 1000;
                                    updateGoldUI();
                                } else {
                                    // 무한: 경험치 + 스크랩 드랍
                                    dropXP(enemy.x, enemy.y, 200);
                                    dropGold(enemy.x, enemy.y, 500);
                                }
                                kills++;
                                // 보스 사망 애니메이션 시작
                                startBossDeathAnimation(enemy);
                                enemies.splice(eIndex, 1);
                            } else {
                                // SFX for regular enemy death
                                if (Math.random() < 0.5) {  // 50% 확률로 재생
                                    playSFX('explosion');
                                }
                                // XP 100% 드롭
                                dropXP(enemy.x, enemy.y, 5);
                                // 골드 드랍 확률 60%
                                if (Math.random() < 0.6) {
                                    dropGold(enemy.x, enemy.y, Math.floor(Math.random() * 3) + 1);
                                }
                                enemies.splice(eIndex, 1);
                                kills++;
                            }
                        }
                    }
                });
            });

            missiles.forEach((missile, mIndex) => {
                const target = findNearestEnemy();
                if (target) {
                    const angle = Math.atan2(target.y - missile.y, target.x - missile.x);
                    // 미사일 회전속도 (기본값 고정)
                    const turnSpeed = 0.05;
                    const currentAngle = Math.atan2(missile.vy, missile.vx);
                    let angleDiff = angle - currentAngle;

                    while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                    while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;

                    const newAngle = currentAngle + Math.sign(angleDiff) * Math.min(Math.abs(angleDiff), turnSpeed);
                    missile.vx = Math.cos(newAngle) * missileSpeed;
                    missile.vy = Math.sin(newAngle) * missileSpeed;
                }

                missile.x += missile.vx;
                missile.y += missile.vy;

                if (missile.x < -50 || missile.x > window.innerWidth + 50 || missile.y < -50 || missile.y > window.innerHeight + 50) {
                    missiles.splice(mIndex, 1);
                    return;
                }

                enemies.forEach((enemy, eIndex) => {
                    // 이미 맞은 적은 스킵
                    if (missile.hitEnemies && missile.hitEnemies.includes(enemy)) {
                        return;
                    }

                    const dist = Math.hypot(missile.x - enemy.x, missile.y - enemy.y);
                    if (dist < missile.size + enemy.size) {
                        // 크리티컬 데미지 계산
                        let damage = missile.damage;
                        if (itemBonuses.critChance > 0 && Math.random() < itemBonuses.critChance) {
                            damage *= (1 + (itemBonuses.critDamage || 0.5));
                        }
                        enemy.hp -= damage;
                        missile.hitCount++;
                        missile.hitEnemies.push(enemy);  // 맞은 적 기록

                        // 관통 체크: hitCount가 piercing+1보다 크면 제거
                        if (missile.hitCount > missilePiercing) {
                            missiles.splice(mIndex, 1);
                        }

                        if (enemy.hp <= 0) {
                            // 보스 처치 체크
                            if (enemy.isBoss) {
                                if (gameMode === 'story') {
                                    // 스토리: 스크랩만 즉시 지급 (경험치 불필요)
                                    currentGold += 1000;
                                    totalGold += 1000;
                                    updateGoldUI();
                                } else {
                                    // 무한: 경험치 + 스크랩 드랍
                                    dropXP(enemy.x, enemy.y, 200);
                                    dropGold(enemy.x, enemy.y, 500);
                                }
                                kills++;
                                // 보스 사망 애니메이션 시작
                                startBossDeathAnimation(enemy);
                                enemies.splice(eIndex, 1);
                            } else {
                                // SFX for regular enemy death
                                if (Math.random() < 0.5) {  // 50% 확률로 재생
                                    playSFX('explosion');
                                }
                                // XP 100% 드롭
                                dropXP(enemy.x, enemy.y, 5);
                                // 골드 드랍 확률 60%
                                if (Math.random() < 0.6) {
                                    dropGold(enemy.x, enemy.y, Math.floor(Math.random() * 3) + 1);
                                }
                                enemies.splice(eIndex, 1);
                                kills++;
                            }
                        }
                    }
                });
            });

            enemyProjectiles.forEach((proj, pIndex) => {
                proj.x += proj.vx;
                proj.y += proj.vy;

                if (proj.x < -50 || proj.x > window.innerWidth + 50 || proj.y < -50 || proj.y > window.innerHeight + 50) {
                    enemyProjectiles.splice(pIndex, 1);
                    return;
                }

                const dist = Math.hypot(proj.x - player.x, proj.y - player.y);
                if (dist < proj.size + player.size) {
                    // 무적 상태가 아닐 때만 데미지
                    if (!invincible) {
                        // 회피 체크
                        if (itemBonuses.dodgeChance > 0 && Math.random() < itemBonuses.dodgeChance) {
                            // 회피 성공! 데미지 무시
                            enemyProjectiles.splice(pIndex, 1);
                            return;
                        }

                        // 데미지 감소 적용
                        let damage = proj.damage;
                        if (itemBonuses.damageReduction > 0) {
                            damage *= (1 - itemBonuses.damageReduction);
                        }

                        player.hp -= damage;
                        if (!isPlayerHit) {
                            isPlayerHit = true;
                            hitFlashTime = 0;
                            playSFX('hit');
                            triggerScreenShake(3);  // 약한 흔들림 (3픽셀)
                            if (navigator.vibrate) {
                                navigator.vibrate(50);
                            }
                        }
                    }
                    enemyProjectiles.splice(pIndex, 1);
                    if (player.hp <= 0) {
                        if (!tryAutoRevive()) {
                            gameOver();
                        }
                    }
                }
            });

            lightnings.forEach((lightning, lIndex) => {
                lightning.life -= deltaTime;
                if (lightning.life <= 0) {
                    lightnings.splice(lIndex, 1);
                }
            });

            xpOrbs.forEach((orb, index) => {
                // 둥둥 떠다니는 애니메이션
                if (!orb.magnetized) {
                    orb.floatTime += deltaTime;
                    orb.floatOffset = Math.sin(orb.floatTime * orb.floatSpeed) * 8;

                    // 아이템이 플레이어 방향으로 아주 천천히 끌림 (이동 방향 감각 제공)
                    const angle = Math.atan2(player.y - orb.y, player.x - orb.x);
                    orb.x += Math.cos(angle) * 0.3;  // 매우 느린 속도
                    orb.y += Math.sin(angle) * 0.3;
                }

                const dist = Math.hypot(player.x - orb.x, player.y - orb.y);

                if (dist < magnetRange) {
                    orb.magnetized = true;
                }

                if (orb.magnetized) {
                    const angle = Math.atan2(player.y - orb.y, player.x - orb.x);
                    const speed = Math.min(dist * 0.2, 8);
                    orb.x += Math.cos(angle) * speed;
                    orb.y += Math.sin(angle) * speed;
                }

                if (dist < player.size + orb.size + 20) {
                    // XP 획득량 보너스 적용
                    let xpValue = orb.value;
                    if (itemBonuses.xpGain > 0) {
                        xpValue *= (1 + itemBonuses.xpGain);
                    }
                    player.xp += xpValue;

                    // XP 획득 시 체력 회복
                    if (itemBonuses.healOnXp > 0 && player.hp < player.maxHp) {
                        const healAmount = player.maxHp * itemBonuses.healOnXp;
                        player.hp = Math.min(player.maxHp, player.hp + healAmount);
                    }

                    xpOrbs.splice(index, 1);

                    if (player.xp >= player.xpNeeded) {
                        levelUp();
                    }
                }
            });

            goldOrbs.forEach((orb, index) => {
                // 둥둥 떠다니는 애니메이션
                if (!orb.magnetized) {
                    orb.floatTime += deltaTime;
                    orb.floatOffset = Math.sin(orb.floatTime * orb.floatSpeed) * 8; // 8px 위아래로 움직임

                    // 아이템이 플레이어 방향으로 아주 천천히 끌림 (이동 방향 감각 제공)
                    const angle = Math.atan2(player.y - orb.y, player.x - orb.x);
                    orb.x += Math.cos(angle) * 0.3;  // 매우 느린 속도
                    orb.y += Math.sin(angle) * 0.3;
                }

                const dist = Math.hypot(player.x - orb.x, player.y - orb.y);

                if (dist < magnetRange) {
                    orb.magnetized = true;
                }

                if (orb.magnetized) {
                    const angle = Math.atan2(player.y - orb.y, player.x - orb.x);
                    const speed = Math.min(dist * 0.2, 8);
                    orb.x += Math.cos(angle) * speed;
                    orb.y += Math.sin(angle) * speed;
                }

                if (dist < player.size + orb.size + 20) {
                    // 골드 획득량 보너스 적용
                    let goldValue = orb.value;
                    if (itemBonuses.goldGain > 0) {
                        goldValue *= (1 + itemBonuses.goldGain);
                        goldValue = Math.round(goldValue);
                    }
                    currentGold += goldValue;
                    totalGold += goldValue;
                    goldOrbs.splice(index, 1);
                    updateGoldUI();
                }
            });

            // HP 재생 (초당)
            if (itemBonuses.hpRegen > 0 && player.hp < player.maxHp) {
                const regenAmount = (itemBonuses.hpRegen * deltaTime) / 1000;
                player.hp = Math.min(player.maxHp, player.hp + regenAmount);
            }

            // 주기적 HP 회복 (5초마다)
            if (itemBonuses.periodicHeal > 0 && player.hp < player.maxHp) {
                if (gameTime - lastPeriodicHealTime >= 5000) {
                    const healAmount = itemBonuses.periodicHeal * 2; // 기본값 2, 등급에 따라 증가
                    player.hp = Math.min(player.maxHp, player.hp + healAmount);
                    lastPeriodicHealTime = gameTime;
                }
            }

            updateUI();
        }

        // 둥근 모서리 사각형 그리기 헬퍼 함수
        function fillRoundedRect(x, y, width, height, radius) {
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + width - radius, y);
            ctx.arcTo(x + width, y, x + width, y + radius, radius);
            ctx.lineTo(x + width, y + height - radius);
            ctx.arcTo(x + width, y + height, x + width - radius, y + height, radius);
            ctx.lineTo(x + radius, y + height);
            ctx.arcTo(x, y + height, x, y + height - radius, radius);
            ctx.lineTo(x, y + radius);
            ctx.arcTo(x, y, x + radius, y, radius);
            ctx.closePath();
            ctx.fill();
        }

        function draw() {
            // 화면 흔들림 적용 (iOS에서도 작동)
            ctx.save();
            ctx.translate(shakeX, shakeY);

            // 배경 그리기 (스크롤) - 스테이지별 배경 선택
            const currentBackground = (gameMode === 'story' && backgroundSprites[selectedStage])
                ? backgroundSprites[selectedStage]
                : backgroundSprites[1];

            if (currentBackground && currentBackground.complete) {
                const bgWidth = window.innerWidth;
                const bgHeight = window.innerHeight;

                // 배경 이미지의 비율에 맞춰 크기 조정
                const bgAspect = currentBackground.width / currentBackground.height;
                const screenAspect = bgWidth / bgHeight;

                let drawWidth = bgWidth;
                let drawHeight = bgHeight;

                // 화면을 가득 채우도록 비율 조정
                if (screenAspect > bgAspect) {
                    drawHeight = drawWidth / bgAspect;
                } else {
                    drawWidth = drawHeight * bgAspect;
                }

                const x = (bgWidth - drawWidth) / 2;

                // 두 개의 배경을 이어서 그려 무한 스크롤 효과
                ctx.imageSmoothingEnabled = false;

                // 배경을 어둡게 하고 채도 낮춤 (캐릭터가 더 잘 보이도록)
                ctx.save();
                ctx.filter = 'brightness(0.6) saturate(0.6) contrast(0.85)';
                ctx.drawImage(currentBackground, x, backgroundY1, drawWidth, drawHeight);
                ctx.drawImage(currentBackground, x, backgroundY2, drawWidth, drawHeight);
                ctx.restore();

                // 추가 어두운 오버레이 (모바일 호환성 개선)
                ctx.fillStyle = 'rgba(0, 0, 0, 0.35)';  // 0.15 -> 0.35로 증가
                ctx.fillRect(0, 0, window.innerWidth, window.innerHeight);

                // 채도 낮추기 오버레이 (회색빛)
                ctx.fillStyle = 'rgba(50, 50, 70, 0.15)';
                ctx.fillRect(0, 0, window.innerWidth, window.innerHeight);
            } else {
                // 배경 로딩 전 기본 색상
                ctx.fillStyle = '#0f3460';
                ctx.fillRect(0, 0, window.innerWidth, window.innerHeight);
            }

            // 미니 드론 그리기
            if (miniDrones.length > 0 && miniDroneSprite && miniDroneSprite.complete) {
                miniDrones.forEach(drone => {
                    const angle = miniDroneRotation + drone.angleOffset;
                    const x = player.x + Math.cos(angle) * miniDroneOrbitRadius;
                    const y = player.y + Math.sin(angle) * miniDroneOrbitRadius;

                    ctx.save();
                    ctx.imageSmoothingEnabled = false;

                    // 드론 크기
                    const droneSize = 24;

                    // 미니 드론 그리기
                    ctx.drawImage(
                        miniDroneSprite,
                        x - droneSize / 2,
                        y - droneSize / 2,
                        droneSize,
                        droneSize
                    );

                    ctx.restore();
                });
            }

            // 플레이어 드론 애니메이션 그리기
            const currentDroneSprite = droneSprites[selectedCharacter] || droneSprite;
            if (currentDroneSprite && currentDroneSprite.complete) {
                // 기본 캐릭터만 애니메이션, 나머지는 정적 이미지
                const isAnimated = selectedCharacter === 'default';

                let spriteX = 0;
                let spriteWidth = frameWidth;
                let spriteHeight = frameHeight;

                if (isAnimated) {
                    // 기본 캐릭터: 4프레임 애니메이션
                    spriteX = animationFrame * frameWidth;
                } else {
                    // SP-02~SP-06: 전체 이미지 사용
                    spriteWidth = currentDroneSprite.width;
                    spriteHeight = currentDroneSprite.height;
                }

                const scale = (player.visualSize * 2 * 1.5) / spriteWidth; // 시각적 크기 사용
                const drawWidth = spriteWidth * scale;
                const drawHeight = spriteHeight * scale;

                ctx.save();

                // 플레이어 후광 효과 (배경에서 눈에 띄게)
                const glowRadius = player.visualSize * 1.5 * 1.5; // 시각적 크기에 맞춰 후광 조정
                const gradient = ctx.createRadialGradient(
                    player.x + shakeOffsetX, player.y + shakeOffsetY, 0,
                    player.x + shakeOffsetX, player.y + shakeOffsetY, glowRadius
                );
                gradient.addColorStop(0, 'rgba(78, 204, 163, 0.4)');
                gradient.addColorStop(0.5, 'rgba(78, 204, 163, 0.2)');
                gradient.addColorStop(1, 'rgba(78, 204, 163, 0)');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(player.x + shakeOffsetX, player.y + shakeOffsetY, glowRadius, 0, Math.PI * 2);
                ctx.fill();

                // 피격 시 깜빡임 효과
                if (isPlayerHit && Math.floor(hitFlashTime / 50) % 2 === 0) {
                    ctx.globalAlpha = 0.5;
                    ctx.filter = 'brightness(2) saturate(0) sepia(1) hue-rotate(-50deg)';
                }

                // 픽셀 아트 렌더링
                ctx.imageSmoothingEnabled = false;

                // 그림자 효과 (깊이감)
                ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                ctx.shadowBlur = 15;
                ctx.shadowOffsetX = 3;
                ctx.shadowOffsetY = 3;

                ctx.drawImage(
                    currentDroneSprite,
                    spriteX, 0,  // 소스 x, y
                    spriteWidth, spriteHeight,  // 소스 너비, 높이
                    player.x - drawWidth / 2 + shakeOffsetX, player.y - drawHeight / 2 + shakeOffsetY,  // 대상 x, y (중앙 정렬 + 흔들림)
                    drawWidth, drawHeight  // 대상 너비, 높이
                );

                // 그림자 리셋
                ctx.shadowColor = 'transparent';
                ctx.shadowBlur = 0;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;

                ctx.restore();
            } else {
                // 스프라이트 로드 전에는 원으로 표시 (폴백)
                ctx.fillStyle = '#4ecca3';
                ctx.beginPath();
                ctx.arc(player.x + shakeOffsetX, player.y + shakeOffsetY, player.visualSize * 1.5, 0, Math.PI * 2); // 시각적 크기 사용
                ctx.fill();

                if (isPlayerHit && Math.floor(hitFlashTime / 50) % 2 === 0) {
                    ctx.fillStyle = 'rgba(255, 0, 0, 0.5)';
                    ctx.beginPath();
                    ctx.arc(player.x + shakeOffsetX, player.y + shakeOffsetY, player.visualSize * 1.5 + 3, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Falcon 무적 보호막 렌더링
            if (invincible) {
                const shieldRadius = player.visualSize * 1.5 * 1.5; // 시각적 크기에 맞춰 보호막 조정
                const shieldAlpha = 0.3 + Math.sin(Date.now() / 200) * 0.15; // 펄스 효과

                // 외부 보호막
                ctx.strokeStyle = `rgba(0, 150, 255, ${shieldAlpha + 0.3})`;
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.arc(player.x, player.y, shieldRadius, 0, Math.PI * 2);
                ctx.stroke();

                // 내부 글로우
                ctx.strokeStyle = `rgba(100, 200, 255, ${shieldAlpha})`;
                ctx.lineWidth = 8;
                ctx.beginPath();
                ctx.arc(player.x, player.y, shieldRadius, 0, Math.PI * 2);
                ctx.stroke();
            }

            // Crane 분신 렌더링
            if (hasClone) {
                const currentDroneSprite = droneSprites[selectedCharacter] || droneSprite;
                if (currentDroneSprite && currentDroneSprite.complete) {
                    const isAnimated = selectedCharacter === 'default';
                    let spriteX = 0;
                    let spriteWidth = frameWidth;
                    let spriteHeight = frameHeight;

                    if (isAnimated) {
                        spriteX = animationFrame * frameWidth;
                    } else {
                        spriteWidth = currentDroneSprite.width;
                        spriteHeight = currentDroneSprite.height;
                    }

                    const scale = (player.visualSize * 2) / spriteWidth;
                    const drawWidth = spriteWidth * scale;
                    const drawHeight = spriteHeight * scale;

                    ctx.save();
                    ctx.globalAlpha = 0.6; // 분신은 반투명
                    ctx.imageSmoothingEnabled = false;

                    ctx.drawImage(
                        currentDroneSprite,
                        spriteX, 0,
                        spriteWidth, spriteHeight,
                        cloneX - drawWidth / 2, cloneY - drawHeight / 2,
                        drawWidth, drawHeight
                    );

                    ctx.restore();
                }
            }

            // EMP 파장 효과 그리기
            empWaves.forEach(wave => {
                const alpha = wave.life / (wave.isUltimate ? 1200 : 800);  // 시간에 따라 페이드아웃

                if (wave.isUltimate) {
                    // 필살기 파동: 노란색
                    ctx.strokeStyle = `rgba(255, 215, 0, ${alpha * 0.9})`;
                    ctx.lineWidth = 5;
                    ctx.beginPath();
                    ctx.arc(wave.x, wave.y, wave.radius, 0, Math.PI * 2);
                    ctx.stroke();

                    // 내부 글로우 효과 (노란색)
                    ctx.strokeStyle = `rgba(255, 193, 7, ${alpha * 0.5})`;
                    ctx.lineWidth = 12;
                    ctx.beginPath();
                    ctx.arc(wave.x, wave.y, wave.radius, 0, Math.PI * 2);
                    ctx.stroke();
                } else {
                    // EMP 파동: 청록색
                    ctx.strokeStyle = `rgba(0, 255, 255, ${alpha * 0.8})`;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(wave.x, wave.y, wave.radius, 0, Math.PI * 2);
                    ctx.stroke();

                    // 내부 글로우 효과
                    ctx.strokeStyle = `rgba(0, 200, 255, ${alpha * 0.4})`;
                    ctx.lineWidth = 8;
                    ctx.beginPath();
                    ctx.arc(wave.x, wave.y, wave.radius, 0, Math.PI * 2);
                    ctx.stroke();
                }
            });

            // Rhino 360도 직선 공격 렌더링
            if (radialBlastActive) {
                radialBlastProjectiles.forEach(proj => {
                    // 투사체 외부 글로우
                    const gradient = ctx.createRadialGradient(
                        proj.x, proj.y, 0,
                        proj.x, proj.y, proj.size * 1.5
                    );
                    gradient.addColorStop(0, 'rgba(255, 50, 50, 0.8)');
                    gradient.addColorStop(0.5, 'rgba(255, 100, 0, 0.6)');
                    gradient.addColorStop(1, 'rgba(255, 150, 0, 0)');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(proj.x, proj.y, proj.size * 1.5, 0, Math.PI * 2);
                    ctx.fill();

                    // 투사체 코어
                    ctx.fillStyle = '#ffff00';
                    ctx.strokeStyle = '#ff3300';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(proj.x, proj.y, proj.size, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                });
            }

            // Specter 중력 붕괴 렌더링
            if (gravityCollapseActive) {
                const pulseSize = Math.sin(Date.now() / 100) * 20;

                if (gravityCollapsePhase === 1) {
                    // 1단계: 끌어당김 - 보라색 중력장
                    const alpha = 0.3 + Math.sin(Date.now() / 200) * 0.15;

                    // 외부 원
                    ctx.strokeStyle = `rgba(138, 43, 226, ${alpha})`;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(gravityCollapseX, gravityCollapseY, gravityCollapseRadius + pulseSize, 0, Math.PI * 2);
                    ctx.stroke();

                    // 중간 원
                    ctx.strokeStyle = `rgba(138, 43, 226, ${alpha + 0.2})`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(gravityCollapseX, gravityCollapseY, gravityCollapseRadius * 0.7 + pulseSize / 2, 0, Math.PI * 2);
                    ctx.stroke();

                    // 중심 글로우
                    const gradient = ctx.createRadialGradient(
                        gravityCollapseX, gravityCollapseY, 0,
                        gravityCollapseX, gravityCollapseY, gravityCollapseRadius * 0.4
                    );
                    gradient.addColorStop(0, 'rgba(138, 43, 226, 0.4)');
                    gradient.addColorStop(1, 'rgba(138, 43, 226, 0)');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(gravityCollapseX, gravityCollapseY, gravityCollapseRadius * 0.4, 0, Math.PI * 2);
                    ctx.fill();
                } else if (gravityCollapsePhase === 2) {
                    // 2단계: 압축 - 빨간색으로 변함
                    const alpha = 0.5 + Math.sin(Date.now() / 100) * 0.2;

                    ctx.strokeStyle = `rgba(220, 20, 60, ${alpha})`;
                    ctx.lineWidth = 5;
                    ctx.beginPath();
                    ctx.arc(gravityCollapseX, gravityCollapseY, gravityCollapseRadius * 0.6 - pulseSize, 0, Math.PI * 2);
                    ctx.stroke();

                    // 강한 중심 글로우
                    const gradient = ctx.createRadialGradient(
                        gravityCollapseX, gravityCollapseY, 0,
                        gravityCollapseX, gravityCollapseY, gravityCollapseRadius * 0.5
                    );
                    gradient.addColorStop(0, 'rgba(255, 0, 0, 0.6)');
                    gradient.addColorStop(1, 'rgba(255, 0, 0, 0)');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(gravityCollapseX, gravityCollapseY, gravityCollapseRadius * 0.5, 0, Math.PI * 2);
                    ctx.fill();
                } else if (gravityCollapsePhase === 3) {
                    // 3단계: 폭발 - 순간적인 플래시
                    const explosionRadius = gravityCollapseRadius * 1.5;

                    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                    ctx.beginPath();
                    ctx.arc(gravityCollapseX, gravityCollapseY, explosionRadius, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.strokeStyle = 'rgba(255, 50, 50, 0.9)';
                    ctx.lineWidth = 8;
                    ctx.beginPath();
                    ctx.arc(gravityCollapseX, gravityCollapseY, explosionRadius * 0.8, 0, Math.PI * 2);
                    ctx.stroke();
                }
            }

            // Phantom 쌍검 회전 레이저 렌더링
            if (dualLaserActive) {
                const laser1Angle = dualLaser1Angle;
                const laser2Angle = dualLaser2Angle;
                const laserLength = 1500;

                // 레이저 1 (시계방향) - 파란색
                ctx.strokeStyle = 'rgba(0, 150, 255, 0.8)';
                ctx.lineWidth = 6;
                ctx.shadowBlur = 20;
                ctx.shadowColor = 'rgba(0, 150, 255, 1)';
                ctx.beginPath();
                ctx.moveTo(player.x, player.y);
                ctx.lineTo(player.x + Math.cos(laser1Angle) * laserLength, player.y + Math.sin(laser1Angle) * laserLength);
                ctx.stroke();

                // 레이저 1 내부 글로우
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(player.x, player.y);
                ctx.lineTo(player.x + Math.cos(laser1Angle) * laserLength, player.y + Math.sin(laser1Angle) * laserLength);
                ctx.stroke();

                // 레이저 2 (반시계방향) - 파란색
                ctx.strokeStyle = 'rgba(0, 150, 255, 0.8)';
                ctx.lineWidth = 6;
                ctx.shadowBlur = 20;
                ctx.shadowColor = 'rgba(0, 150, 255, 1)';
                ctx.beginPath();
                ctx.moveTo(player.x, player.y);
                ctx.lineTo(player.x + Math.cos(laser2Angle) * laserLength, player.y + Math.sin(laser2Angle) * laserLength);
                ctx.stroke();

                // 레이저 2 내부 글로우
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(player.x, player.y);
                ctx.lineTo(player.x + Math.cos(laser2Angle) * laserLength, player.y + Math.sin(laser2Angle) * laserLength);
                ctx.stroke();

                // 중심 에너지 구체 - 파란색
                ctx.shadowBlur = 30;
                ctx.shadowColor = 'rgba(0, 150, 255, 1)';
                ctx.fillStyle = 'rgba(100, 200, 255, 0.9)';
                ctx.beginPath();
                ctx.arc(player.x, player.y, 15 + Math.sin(Date.now() / 50) * 5, 0, Math.PI * 2);
                ctx.fill();

                ctx.shadowBlur = 0; // 그림자 효과 리셋
            }

            meleeWeapons.forEach(weapon => {
                const weaponX = player.x + Math.cos(weapon.angle + meleeRotation) * meleeOrbitRadius;
                const weaponY = player.y + Math.sin(weapon.angle + meleeRotation) * meleeOrbitRadius;

                ctx.fillStyle = '#ff6b6b';
                ctx.strokeStyle = '#ff0000';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(weaponX, weaponY, weapon.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
            });

            enemies.forEach(enemy => {
                // 적 후광 효과 (빨간색)
                const glowRadius = enemy.size * 1.3;
                const gradient = ctx.createRadialGradient(
                    enemy.x, enemy.y, 0,
                    enemy.x, enemy.y, glowRadius
                );
                gradient.addColorStop(0, 'rgba(255, 50, 50, 0.4)');
                gradient.addColorStop(0.5, 'rgba(255, 50, 50, 0.2)');
                gradient.addColorStop(1, 'rgba(255, 50, 50, 0)');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(enemy.x, enemy.y, glowRadius, 0, Math.PI * 2);
                ctx.fill();

                // 스턴 흔들림 효과
                let shakeX = 0;
                let shakeY = 0;
                if (enemy.stunned) {
                    const shakeAmount = 3;
                    shakeX = (Math.random() - 0.5) * shakeAmount;
                    shakeY = (Math.random() - 0.5) * shakeAmount;
                }

                // 현재 스테이지 결정
                let currentStage = 1;
                if (gameMode === 'story') {
                    currentStage = selectedStage;
                } else {
                    // 무한 모드: 5분마다 스테이지 전환
                    const timeInMinutes = gameTime / 60000;
                    if (timeInMinutes < 5) currentStage = 1;
                    else if (timeInMinutes < 10) currentStage = 2;
                    else currentStage = 3;
                }

                // 보스는 자신의 stageId 사용
                if (enemy.type === 'boss' && enemy.stageId) {
                    currentStage = enemy.stageId;
                }

                if (enemy.type === 'boss') {
                    // 보스 스프라이트 렌더링 (스테이지별)
                    const bossKey = `stage${currentStage}`;
                    const currentBossSprite = bossSprites[bossKey];
                    const isBossLoaded = bossSpriteLoaded[bossKey];

                    if (isBossLoaded && currentBossSprite) {
                        const drawSize = enemy.size * 2;
                        ctx.imageSmoothingEnabled = false;
                        ctx.drawImage(
                            currentBossSprite,
                            enemy.x + shakeX - drawSize / 2,
                            enemy.y + shakeY - drawSize / 2,
                            drawSize,
                            drawSize
                        );
                    } else {
                        // 폴백 렌더링
                        ctx.fillStyle = '#ff0000';
                        ctx.strokeStyle = '#ffff00';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.arc(enemy.x + shakeX, enemy.y + shakeY, enemy.size, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.stroke();
                    }

                    // 보스 HP 바 (더 크게, 둥근 모서리)
                    const barWidth = enemy.size * 2.5;
                    const barHeight = 8;
                    const barRadius = 3;
                    ctx.fillStyle = '#000000';
                    fillRoundedRect(enemy.x - barWidth / 2, enemy.y - enemy.size - 20, barWidth, barHeight, barRadius);
                    ctx.fillStyle = '#ff0000';
                    fillRoundedRect(enemy.x - barWidth / 2 + 2, enemy.y - enemy.size - 18, barWidth - 4, barHeight - 4, barRadius - 1);
                    ctx.fillStyle = '#ffff00';
                    fillRoundedRect(enemy.x - barWidth / 2 + 2, enemy.y - enemy.size - 18, (enemy.hp / enemy.maxHp) * (barWidth - 4), barHeight - 4, barRadius - 1);

                    // 보스 이름 표시 (난이도 레벨 포함)
                    ctx.fillStyle = '#ffff00';
                    ctx.font = 'bold 16px Arial';
                    ctx.textAlign = 'center';
                    const bossLabel = enemy.difficultyLevel > 1 ? `BOSS [Lv.${enemy.difficultyLevel}]` : 'BOSS';
                    ctx.fillText(bossLabel, enemy.x, enemy.y - enemy.size - 30);
                } else if (enemy.type === 'purple') {
                    // 보라 적 - StageXEnemy2.png 사용 + 회전 (반대 방향)
                    const enemyKey = `stage${currentStage}_enemy2`;
                    const currentEnemySprite = enemySprites[enemyKey];
                    const isEnemyLoaded = enemySpriteLoaded[enemyKey];

                    if (isEnemyLoaded && currentEnemySprite) {
                        const drawSize = enemy.size * 2;
                        // 플레이어를 향하는 각도 계산 (반대 방향으로 180도 회전)
                        const angle = Math.atan2(player.y - enemy.y, player.x - enemy.x);

                        ctx.save();
                        ctx.translate(enemy.x + shakeX, enemy.y + shakeY);
                        ctx.rotate(angle + Math.PI / 2 + Math.PI); // 반대 방향으로 180도 추가
                        ctx.imageSmoothingEnabled = false;
                        ctx.drawImage(
                            currentEnemySprite,
                            -drawSize / 2,
                            -drawSize / 2,
                            drawSize,
                            drawSize
                        );
                        ctx.restore();
                    } else {
                        // 폴백: 사각형 유지
                        ctx.fillStyle = '#a855f7';
                        ctx.fillRect(enemy.x + shakeX - enemy.size / 2, enemy.y + shakeY - enemy.size / 2, enemy.size, enemy.size);
                    }

                    const barWidth = enemy.size * 2;
                    const barHeight = 4;
                    const barRadius = 2;
                    ctx.fillStyle = '#ff0000';
                    fillRoundedRect(enemy.x - enemy.size, enemy.y - enemy.size - 8, barWidth, barHeight, barRadius);
                    ctx.fillStyle = '#00ff00';
                    fillRoundedRect(enemy.x - enemy.size, enemy.y - enemy.size - 8, (enemy.hp / enemy.maxHp) * barWidth, barHeight, barRadius);
                } else if (enemy.type === 'ranged') {
                    // 원거리 적 - StageXEnemy3.png 사용 + 회전 (반대 방향)
                    const enemyKey = `stage${currentStage}_enemy3`;
                    const currentEnemySprite = enemySprites[enemyKey];
                    const isEnemyLoaded = enemySpriteLoaded[enemyKey];

                    if (isEnemyLoaded && currentEnemySprite) {
                        const drawSize = enemy.size * 2;
                        // 플레이어를 향하는 각도 계산 (반대 방향으로 180도 회전)
                        const angle = Math.atan2(player.y - enemy.y, player.x - enemy.x);

                        ctx.save();
                        ctx.translate(enemy.x + shakeX, enemy.y + shakeY);
                        ctx.rotate(angle + Math.PI / 2 + Math.PI); // 반대 방향으로 180도 추가
                        ctx.imageSmoothingEnabled = false;
                        ctx.drawImage(
                            currentEnemySprite,
                            -drawSize / 2,
                            -drawSize / 2,
                            drawSize,
                            drawSize
                        );
                        ctx.restore();
                    } else {
                        ctx.fillStyle = '#ff6b35';
                        ctx.beginPath();
                        ctx.arc(enemy.x + shakeX, enemy.y + shakeY, enemy.size, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    const barWidth = enemy.size * 2;
                    const barHeight = 4;
                    const barRadius = 2;
                    ctx.fillStyle = '#ff0000';
                    fillRoundedRect(enemy.x - enemy.size, enemy.y - enemy.size - 8, barWidth, barHeight, barRadius);
                    ctx.fillStyle = '#00ff00';
                    fillRoundedRect(enemy.x - enemy.size, enemy.y - enemy.size - 8, (enemy.hp / enemy.maxHp) * barWidth, barHeight, barRadius);
                } else {
                    // 기본 적 - StageXEnemy1.png 사용 + 회전 (반대 방향)
                    const enemyKey = `stage${currentStage}_enemy1`;
                    const currentEnemySprite = enemySprites[enemyKey];
                    const isEnemyLoaded = enemySpriteLoaded[enemyKey];

                    if (isEnemyLoaded && currentEnemySprite) {
                        const drawSize = enemy.size * 2;
                        // 플레이어를 향하는 각도 계산 (반대 방향으로 180도 회전)
                        const angle = Math.atan2(player.y - enemy.y, player.x - enemy.x);

                        ctx.save();
                        ctx.translate(enemy.x + shakeX, enemy.y + shakeY);
                        ctx.rotate(angle + Math.PI / 2 + Math.PI); // 반대 방향으로 180도 추가
                        ctx.imageSmoothingEnabled = false;
                        ctx.drawImage(
                            currentEnemySprite,
                            -drawSize / 2,
                            -drawSize / 2,
                            drawSize,
                            drawSize
                        );
                        ctx.restore();
                    } else {
                        ctx.fillStyle = '#e94560';
                        ctx.beginPath();
                        ctx.arc(enemy.x, enemy.y, enemy.size, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    const barWidth = enemy.size * 2;
                    const barHeight = 4;
                    const barRadius = 2;
                    ctx.fillStyle = '#ff0000';
                    fillRoundedRect(enemy.x - enemy.size, enemy.y - enemy.size - 8, barWidth, barHeight, barRadius);
                    ctx.fillStyle = '#00ff00';
                    fillRoundedRect(enemy.x - enemy.size, enemy.y - enemy.size - 8, (enemy.hp / enemy.maxHp) * barWidth, barHeight, barRadius);
                }
            });

            ctx.fillStyle = '#ffd700';
            projectiles.forEach(proj => {
                if (bulletSpriteLoaded) {
                    const drawSize = proj.size * 11.7;  // 원래 크기와 거의 비슷 (12 -> 11.7)
                    // 투사체가 날아가는 방향 계산 (반대 방향으로 180도 회전)
                    const angle = Math.atan2(proj.vy, proj.vx);

                    ctx.save();
                    ctx.translate(proj.x, proj.y);
                    ctx.rotate(angle + Math.PI / 2 + Math.PI); // 스프라이트 아래가 앞이므로 +90도, 그리고 반대방향 +180도
                    ctx.imageSmoothingEnabled = false;
                    ctx.drawImage(
                        bulletSprite,
                        -drawSize / 2,
                        -drawSize / 2,
                        drawSize,
                        drawSize
                    );
                    ctx.restore();
                } else {
                    // 폴백: 원으로 표시
                    ctx.beginPath();
                    ctx.arc(proj.x, proj.y, proj.size * 3.9, 0, Math.PI * 2);  // 원래 크기와 거의 비슷 (4 -> 3.9)
                    ctx.fill();
                }
            });

            missiles.forEach(missile => {
                if (guidedMissileSpriteLoaded) {
                    const drawSize = missile.size * 8;
                    // 미사일이 날아가는 방향 계산
                    const angle = Math.atan2(missile.vy, missile.vx);

                    ctx.save();
                    ctx.translate(missile.x, missile.y);
                    ctx.rotate(angle + Math.PI / 2); // 스프라이트 아래가 앞이므로 +90도
                    ctx.imageSmoothingEnabled = false;
                    ctx.drawImage(
                        guidedMissileSprite,
                        -drawSize / 2,
                        -drawSize / 2,
                        drawSize,
                        drawSize
                    );
                    ctx.restore();
                } else {
                    // 폴백: 보라색 원과 트레일
                    ctx.fillStyle = '#ff00ff';
                    ctx.beginPath();
                    ctx.arc(missile.x, missile.y, missile.size, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.strokeStyle = '#ff00ff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(missile.x, missile.y);
                    ctx.lineTo(missile.x - missile.vx * 2, missile.y - missile.vy * 2);
                    ctx.stroke();
                }
            });

            enemyProjectiles.forEach(proj => {
                if (enemyBallSpriteLoaded) {
                    const drawSize = proj.size * 4;
                    ctx.imageSmoothingEnabled = false;
                    ctx.drawImage(
                        enemyBallSprite,
                        proj.x - drawSize / 2,
                        proj.y - drawSize / 2,
                        drawSize,
                        drawSize
                    );
                } else {
                    // 폴백: 빨간 원
                    ctx.fillStyle = '#ff4444';
                    ctx.beginPath();
                    ctx.arc(proj.x, proj.y, proj.size, 0, Math.PI * 2);
                    ctx.fill();
                }
            });

            xpOrbs.forEach(orb => {
                // 둥둥 떠다니는 위치 계산
                const renderY = orb.y + (orb.floatOffset || 0);

                // 청록색 아우라 효과
                const glowRadius = orb.size * 2;
                const gradient = ctx.createRadialGradient(
                    orb.x, renderY, 0,
                    orb.x, renderY, glowRadius
                );
                gradient.addColorStop(0, 'rgba(78, 204, 163, 0.5)');  // 청록색
                gradient.addColorStop(0.5, 'rgba(78, 204, 163, 0.3)');
                gradient.addColorStop(1, 'rgba(78, 204, 163, 0)');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(orb.x, renderY, glowRadius, 0, Math.PI * 2);
                ctx.fill();

                if (xpSpriteLoaded) {
                    const drawSize = orb.size * 2.5;
                    ctx.imageSmoothingEnabled = false;
                    ctx.drawImage(
                        xpSprite,
                        orb.x - drawSize / 2,
                        renderY - drawSize / 2,
                        drawSize,
                        drawSize
                    );
                } else {
                    // 폴백: 원으로 표시
                    ctx.fillStyle = '#00ffff';
                    ctx.beginPath();
                    ctx.arc(orb.x, renderY, orb.size, 0, Math.PI * 2);
                    ctx.fill();
                }
            });

            goldOrbs.forEach(orb => {
                // 둥둥 떠다니는 위치 계산
                const renderY = orb.y + (orb.floatOffset || 0);

                // 금빛 아우라 효과
                const glowRadius = orb.size * 2;
                const gradient = ctx.createRadialGradient(
                    orb.x, renderY, 0,
                    orb.x, renderY, glowRadius
                );
                gradient.addColorStop(0, 'rgba(255, 215, 0, 0.5)');  // 금색
                gradient.addColorStop(0.5, 'rgba(255, 215, 0, 0.3)');
                gradient.addColorStop(1, 'rgba(255, 215, 0, 0)');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(orb.x, renderY, glowRadius, 0, Math.PI * 2);
                ctx.fill();

                if (gearSpriteLoaded) {
                    const drawSize = orb.size * 2.5;
                    ctx.imageSmoothingEnabled = false;
                    ctx.drawImage(
                        gearSprite,
                        orb.x - drawSize / 2,
                        renderY - drawSize / 2,
                        drawSize,
                        drawSize
                    );
                } else {
                    // 폴백: 원으로 표시
                    ctx.fillStyle = '#ffd700';
                    ctx.beginPath();
                    ctx.arc(orb.x, renderY, orb.size, 0, Math.PI * 2);
                    ctx.fill();
                }
            });

            lightnings.forEach(lightning => {
                const opacity = lightning.life / 500;
                ctx.strokeStyle = `rgba(100, 150, 255, ${opacity})`;  // 파란색
                ctx.lineWidth = 4;
                ctx.beginPath();

                // 번개 모양 (지그재그)
                const startY = -50;
                const endY = lightning.y;
                const segments = 8; // 번개 세그먼트 수
                const offsetRange = 20; // 좌우 흔들림 범위

                ctx.moveTo(lightning.x, startY);

                for (let i = 1; i <= segments; i++) {
                    const progress = i / segments;
                    const y = startY + (endY - startY) * progress;
                    const offset = (Math.random() - 0.5) * offsetRange * 2;
                    ctx.lineTo(lightning.x + offset, y);
                }

                ctx.stroke();

                // 착탄 지점 발광 효과
                ctx.fillStyle = `rgba(150, 180, 255, ${opacity})`;  // 연한 파란색
                ctx.beginPath();
                ctx.arc(lightning.x, lightning.y, 20, 0, Math.PI * 2);
                ctx.fill();

                // 외곽 후광
                ctx.fillStyle = `rgba(100, 150, 255, ${opacity * 0.3})`;
                ctx.beginPath();
                ctx.arc(lightning.x, lightning.y, 30, 0, Math.PI * 2);
                ctx.fill();
            });

            // 보스 사망 애니메이션 렌더링
            if (bossDeathAnimation && dyingBoss) {
                // 화면 플래시 효과 (80ms마다 깜빡임)
                if (Math.floor(bossDeathFlashTimer / 80) % 2 === 0) {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                }

                // 화면 흔들림 효과
                const shake = 8;
                const shakeX = (Math.random() - 0.5) * shake;
                const shakeY = (Math.random() - 0.5) * shake;
                ctx.save();
                ctx.translate(shakeX, shakeY);

                // 보스 깜빡이며 그리기 (75ms마다)
                if (Math.floor(bossDeathTimer / 75) % 2 === 0) {
                    // 보스 스프라이트 표시
                    if (dyingBoss.sprite) {
                        const drawSize = dyingBoss.size * 2;
                        ctx.imageSmoothingEnabled = false;
                        ctx.drawImage(
                            dyingBoss.sprite,
                            dyingBoss.x - drawSize / 2,
                            dyingBoss.y - drawSize / 2,
                            drawSize,
                            drawSize
                        );
                    } else {
                        ctx.fillStyle = '#ff0000';
                        ctx.beginPath();
                        ctx.arc(dyingBoss.x, dyingBoss.y, dyingBoss.size, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }

                ctx.restore();
            }

            // 화면 흔들림 복원
            ctx.restore();
        }

        function updateUI() {
            document.getElementById('hp').textContent = Math.max(0, Math.floor(player.hp));
            document.getElementById('maxHp').textContent = player.maxHp;
            document.getElementById('level').textContent = player.level;
            document.getElementById('xp').textContent = Math.floor(player.xp);
            document.getElementById('xpNeeded').textContent = player.xpNeeded;
            document.getElementById('time').textContent = Math.floor(gameTime / 1000);

            const hpPercent = (player.hp / player.maxHp) * 100;
            document.getElementById('hpBar').style.width = hpPercent + '%';

            const xpPercent = (player.xp / player.xpNeeded) * 100;
            document.getElementById('xpBar').style.width = xpPercent + '%';
        }

        let canRevive = true;  // 게임당 1회만 부활 가능

        function gameOver() {
            gameRunning = false;
            document.getElementById('homeButton').style.display = 'none';

            const finalTime = Math.floor(gameTime / 1000);
            const finalKills = kills;

            // 최고기록 업데이트
            if (finalTime > bestTime) bestTime = finalTime;
            if (finalKills > bestKills) bestKills = finalKills;

            document.getElementById('finalTime').textContent = finalTime;
            document.getElementById('finalKills').textContent = finalKills;
            document.getElementById('finalGold').textContent = currentGold;

            // 부활 버튼 표시 여부 (1회만 가능)
            const reviveBtn = document.getElementById('reviveButton');
            if (canRevive) {
                reviveBtn.style.display = 'block';
            } else {
                reviveBtn.style.display = 'none';
            }

            // 게임 종료 시 1초 후 광고 표시 (게임 오버 화면 표시 전)
            setTimeout(() => {
                showGameOverAd().finally(() => {
                    // 광고 종료 후 게임 오버 화면 표시
                    document.getElementById('gameOver').style.display = 'block';
                    // 게임 오버 화면과 함께 상단 UI 숨기기
                    const heartDisplay = document.getElementById('heartDisplay');
                    if (heartDisplay) heartDisplay.style.display = 'none';
                });
            }, 1000); // 1초 지연

            // 게임 진행 상황 저장 (totalGold는 게임 중에 이미 업데이트됨)
            saveGameProgress();

            // Toss Game Center 점수 제출
            if (window.tossIntegration) {
                // 점수 계산: kills * 100 + time(초)
                // 예: 50 kills, 180초 = 5180점
                const gameScore = finalKills * 100 + finalTime;

                window.tossIntegration.submitGameCenterScore(gameScore)
                    .then(success => {
                        if (success) {
                            console.log('✅ Game Center 점수 제출 완료:', gameScore);
                            // 성공 시 게임 오버 화면에 작은 알림 표시 (선택사항)
                        } else {
                            console.warn('⚠️ Game Center 점수 제출 실패');
                            // 실패해도 게임은 계속 진행
                        }
                    })
                    .catch(err => {
                        console.error('❌ 점수 제출 에러:', err);
                        // 에러 발생해도 게임은 계속
                    });
            }
        }

        // 긴급 탈출 장치 자동 부활 처리
        function tryAutoRevive() {
            if (itemBonuses.revive > 0) {
                player.hp = Math.floor(player.maxHp * 0.5); // 최대 HP의 50%로 부활
                itemBonuses.revive--;
                playSFX('levelup'); // 부활 효과음
                if (navigator.vibrate) {
                    navigator.vibrate([200, 100, 200]);
                }
                console.log('✨ 긴급 탈출 장치 발동! 부활 횟수 남음:', itemBonuses.revive);
                return true;
            }
            return false;
        }

        // 스테이지 클리어 시 광고 표시
        async function showStageClearAd() {
            if (!window.tossIntegration || !window.tossIntegration.isAdAvailable()) {
                console.log('⚠️ 광고 SDK 없음 - 스테이지 클리어 광고 스킵');
                return Promise.resolve();
            }

            try {
                const stageClearAdId = 'ait.live.2b98ee996c124825';
                console.log('📺 스테이지 클리어 광고 표시 시도');

                await window.tossIntegration.showRewardedAd(stageClearAdId, () => {
                    console.log('📺 스테이지 클리어 광고 시청 완료');
                });
            } catch (error) {
                console.error('❌ 스테이지 클리어 광고 표시 실패:', error);
            }
        }

        // 게임 종료 시 광고 표시
        async function showGameOverAd() {
            if (!window.tossIntegration || !window.tossIntegration.isAdAvailable()) {
                console.log('⚠️ 광고 SDK 없음 - 게임 오버 광고 스킬');
                updateHeartDisplayVisibility();
                return Promise.resolve();
            }

            try {
                const gameOverAdId = 'ait.live.2b98ee996c124825';
                console.log('📺 게임 종료 궅고 표시 시도');

                await window.tossIntegration.showRewardedAd(gameOverAdId, () => {
                    console.log('📺 게임 종료 궅고 시청 완료');
                });

                updateHeartDisplayVisibility();
            } catch (error) {
                console.error('❌ 게임 종료 궅고 표시 실패:', error);
                updateHeartDisplayVisibility();
            }
        }
        // 광고 보고 부활하기
        async function watchAdToRevive() {
            if (!window.tossIntegration) {
                showTossModal({
                    title: 'Toss 연동 필요',
                    message: 'Toss 앱에서 실행 시\n광고 시청 부활 기능을 사용할 수 있습니다.',
                    buttons: [{ text: '확인', color: 'secondary' }]
                });
                return;
            }

            // SDK 가용성 체크
            if (!window.tossIntegration.isAdAvailable()) {
                const envInfo = window.tossIntegration.getEnvironmentInfo();
                console.warn('⚠️ 광고 SDK 없음:', envInfo);
                showTossModal({
                    title: '광고를 사용할 수 없습니다',
                    message: 'Toss 앱 버전이 낮거나\nSDK가 로드되지 않았습니다.\n\n환경: ' + envInfo.env + '\n버전: ' + envInfo.tossVersion,
                    buttons: [{ text: '확인', color: 'secondary' }]
                });
                return;
            }

            if (!canRevive) {
                showTossModal({
                    title: '부활 불가',
                    message: '이미 부활을 사용했습니다.\n한 게임당 1회만 사용 가능합니다.',
                    buttons: [{ text: '확인', color: 'secondary' }]
                });
                return;
            }

            // 광고 표시 및 보상 처리 (부활용 광고 ID)
            const success = await window.tossIntegration.showRewardedAd('ait.live.a1e634d55d5046db', (reward) => {
                console.log('✅ 부활 보상 획득:', reward);

                // 부활 처리
                player.hp = player.maxHp * 0.5;  // HP 50% 회복
                canRevive = false;  // 부활 사용 완료
                gameRunning = true;

                // 게임 오버 화면 닫기
                document.getElementById('gameOver').style.display = 'none';
                document.getElementById('homeButton').style.display = 'block';

                // 무적 시간 5초 부여
                invincible = true;
                invincibleTimer = 5000;

                // 효과음 및 화면 흔들림
                playSFX('levelup');
                triggerScreenShake(10);

                // UI 업데이트
                updateUI();

                console.log('🎮 부활 완료! 무적 5초 부여');
            });

            if (!success) {
                console.error('광고 표시 실패');
            }
        }

        function goToMainMenu() {
            document.getElementById('gameOver').style.display = 'none';
            document.getElementById('mainMenu').style.display = 'flex';
            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('homeButton').style.display = 'none';
            document.getElementById('ultimateButton').style.display = 'none';
            gameStarted = false;
            gameRunning = false;  // 게임 정지

            // 키 입력 및 터치 초기화
            Object.keys(keys).forEach(key => keys[key] = false);
            touchActive = false;

            // 에너지 UI 표시 (메인 메뉴)
            updateHeartDisplayVisibility();

            // 게임 진행 상황 저장 (게임 중 나가기)
            saveGameProgress();

            // 골드 UI 업데이트
            updateGoldUI();

            // 메인 BGM 재생
            playBgm(mainBgm);

            // 게임 상태 완전 초기화 (캐릭터 언락 상태와 골드는 유지)
            const char = characters.find(c => c.id === selectedCharacter);

            player.x = window.innerWidth / 2;
            player.y = window.innerHeight / 2;
            player.speed = 4.5;
            console.log('goToMainMenu: player.speed set to', player.speed);
            player.maxHp = char ? char.stats.hp : 100;
            player.hp = char ? char.stats.hp : 100;
            player.xp = 0;
            player.level = 1;
            player.xpNeeded = 10;

            enemies.length = 0;
            projectiles.length = 0;
            missiles.length = 0;
            lightnings.length = 0;
            enemyProjectiles.length = 0;
            xpOrbs.length = 0;
            goldOrbs.length = 0;
            meleeWeapons.length = 0;

            kills = 0;
            gameTime = 0;
            shootTimer = 0;
            missileTimer = 0;
            currentGold = 0;

            weaponDamage = char ? char.stats.damage : 30;
            weaponSpeed = 350;
            projectileSpeed = 5;
            projectileCount = 1;
            projectilePiercing = 0;

            hasMissile = false;
            missileCount = 0;
            missileDamage = 25;
            missileSpeed = 4;
            missilePiercing = 0;

            // EMP 파장 초기화
            hasEMP = false;
            empDamage = 30;
            empTimer = 0;
            empCooldown = 2000;  // 3000 -> 2000 (50% 향상)
            empRadius = 200;  // 100 -> 200 (100% 향상)
            empWaves.length = 0;

            // 미니 드론 초기화
            miniDrones.length = 0;
            miniDroneRotation = 0;
            miniDroneShootTimer = 0;

            // 위성 지원 초기화
            hasSatellite = false;
            satelliteDamage = 40;
            satelliteTimer = 0;
            satelliteCooldown = 2500;

            meleeCount = 0;
            meleeDamage = 0;
            meleeOrbitRadius = 0;
            meleeRotation = 0;
            meleeRotationSpeed = 0.008;

            magnetRange = 100;

            isPlayerHit = false;
            hitFlashTime = 0;
            bossSpawned = false;
            boss = null;

            updateGoldUI();
        }

        // 에셋 프리로더
        let assetsLoaded = 0;
        let totalAssets = 0;
        const assetsToLoad = [];

        // 모든 이미지 에셋 수집
        function collectAssets() {
            console.log('=== Collecting assets ===');
            // 플레이어 스프라이트
            assetsToLoad.push(droneSprites['default']);
            console.log('Added player sprite');

            // 적 스프라이트 (3 스테이지 x 3 적 = 9개)
            for (let i = 1; i <= 3; i++) {
                for (let j = 1; j <= 3; j++) {
                    assetsToLoad.push(enemySprites[`stage${i}_enemy${j}`]);
                }
            }

            // 보스 스프라이트 (3개)
            for (let i = 1; i <= 3; i++) {
                assetsToLoad.push(bossSprites[`stage${i}`]);
            }

            // 배경 (3개)
            assetsToLoad.push(backgroundSprites[1], backgroundSprites[2], backgroundSprites[3]);

            // UI 스프라이트
            assetsToLoad.push(xpSprite, gearSprite, bulletSprite, guidedMissileSprite, enemyBallSprite);

            totalAssets = assetsToLoad.length;
            console.log('Total assets to load:', totalAssets);
        }

        function updateLoadingProgress() {
            assetsLoaded++;
            const progress = Math.floor((assetsLoaded / totalAssets) * 100);
            const loadingBar = document.getElementById('loadingBar');
            const loadingProgress = document.getElementById('loadingProgress');

            console.log(`Loading progress: ${assetsLoaded}/${totalAssets} (${progress}%)`);

            if (loadingBar) loadingBar.style.width = progress + '%';
            if (loadingProgress) loadingProgress.textContent = progress + '%';

            if (assetsLoaded >= totalAssets) {
                console.log('All assets loaded! Showing main menu...');
                setTimeout(() => {
                    document.getElementById('loadingScreen').style.display = 'none';
                    document.getElementById('mainMenu').style.display = 'flex';
                    // 로딩 완료 후 메인 메뉴 BGM 자동 재생 시도
                    playBgm(mainBgm);
                }, 500);
            }
        }

        // 모든 이미지에 로드 리스너 추가
        function setupAssetLoaders() {
            collectAssets();

            assetsToLoad.forEach(asset => {
                if (asset.complete) {
                    updateLoadingProgress();
                } else {
                    asset.addEventListener('load', updateLoadingProgress);
                    asset.addEventListener('error', () => {
                        console.warn('Asset failed to load:', asset.src);
                        updateLoadingProgress(); // 실패해도 진행
                    });
                }
            });
        }

        // 전역 에러 핸들러
        window.addEventListener('error', (e) => {
            console.error('Game Error:', e.error);
            // 게임 중 에러 발생 시 계속 진행
            if (gameRunning) {
                console.warn('Error during gameplay - attempting to continue');
            }
        });

        window.addEventListener('unhandledrejection', (e) => {
            console.error('Unhandled Promise Rejection:', e.reason);
        });

        // 에너지 시스템 초기화 및 UI 업데이트 리스너
        window.addEventListener('heartsUpdated', (event) => {
            updateHeartUI();
        });

        // Toss Integration에서 유저 키 받은 후 에너지 시스템 초기화 (전역 함수)
        window.initializeHeartSystem = async function () {
            try {
                // toss-integration.js에서 이미 getUserKeyForGame() 호출함
                // 약간의 딜레이를 주어 tossIntegration 초기화 완료 대기
                await new Promise(resolve => setTimeout(resolve, 100));

                // Toss Integration에서 받은 userKey 사용
                const userKey = window.tossIntegration?.userKey;

                if (userKey) {
                    heartSystem = new HeartSystem(userKey);
                    // userKey로 STORAGE_KEYS 업데이트
                    STORAGE_KEYS = getStorageKeys(userKey);
                    console.log('✅ 에너지 시스템 초기화 완료:', userKey);
                } else {
                    // fallback: localStorage에서 고정된 테스트 키 가져오기
                    let testKey = localStorage.getItem('test_user_key');
                    if (!testKey) {
                        testKey = 'local_' + Math.random().toString(36).substring(2, 15);
                        localStorage.setItem('test_user_key', testKey);
                    }
                    heartSystem = new HeartSystem(testKey);
                    // testKey로 STORAGE_KEYS 업데이트
                    STORAGE_KEYS = getStorageKeys(testKey);
                    console.log('⚠️ 테스트 모드로 에너지 시스템 초기화:', testKey);
                }

                // STORAGE_KEYS 업데이트 후 게임 데이터 로드
                loadItemData();      // 아이템/보급권 로드
                loadGameProgress();  // 스크랩/캐릭터/스테이지 로드
                updateGoldUI();
                updateHeartUI();
            } catch (error) {
                console.error('❌ 에너지 시스템 초기화 실패:', error);
            }
        }

        // 페이지 로드 시 실행
        window.addEventListener('load', () => {
            setupAssetLoaders();

            // 아이템/게임 진행 상황 로드는 initializeHeartSystem()에서 처리됨 (userKey 설정 후)

            // 초기 볼륨 설정 (Web Audio API - 모바일 iOS 대응)
            // mainBgm만 볼륨 설정, 나머지는 0으로
            mainBgmGain.gain.value = masterVolume * musicVolume;
            stage1BgmGain.gain.value = 0;
            stage2BgmGain.gain.value = 0;
            stage3BgmGain.gain.value = 0;

            console.log('Initial BGM volumes set - mainBgm:', mainBgmGain.gain.value);

            // 사용자 인터랙션 후 BGM 재생
            document.addEventListener('click', function initBgm() {
                playBgm(mainBgm);
                document.removeEventListener('click', initBgm);
            }, { once: true });

            // 에너지 시스템 초기화는 toss-integration.js의 DOMContentLoaded에서 처리됨
            // (userKey 설정 완료 후 자동 호출)
        });

        // 백그라운드 전환 시 자동 일시정지 (모바일 최적화)
        // Toss 앱 게임 심사 기준: AOS 백그라운드 전환 시 게임 사운드 중지
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                // 페이지가 백그라운드로 전환되면 모든 오디오 정지 (메뉴/게임 모두)
                pauseAllAudio();
                console.log('🔇 Background: All audio paused');

                // 게임 중이면 게임도 일시정지
                if (gameRunning) {
                    gameRunning = false;
                    console.log('⏸️ Background: Game paused');
                }
            } else {
                // 페이지가 포그라운드로 전환되면 오디오 재개
                resumeAllAudio();
                console.log('🔊 Foreground: All audio resumed');

                // 게임이 시작된 상태였으면 게임 재개
                if (gameStarted && !gameRunning) {
                    gameRunning = true;
                    lastTime = Date.now();  // 시간 동기화
                    console.log('▶️ Foreground: Game resumed');
                }
            }
        });

        // FPS 카운터
        let fpsFrames = 0;
        let fpsLastTime = Date.now();
        let showFPS = false;

        function updateFPS() {
            fpsFrames++;
            const now = Date.now();
            if (now - fpsLastTime >= 1000) {
                if (showFPS) {
                    document.getElementById('fpsValue').textContent = fpsFrames;
                }
                fpsFrames = 0;
                fpsLastTime = now;
            }
        }

        // 치트키: 'F' 키로 FPS 토글
        window.addEventListener('keydown', (e) => {
            if (e.key.toLowerCase() === 'f' && gameRunning) {
                showFPS = !showFPS;
                document.getElementById('fpsCounter').style.display = showFPS ? 'block' : 'none';
            }
        });

        // FPS 제한 (모바일 배터리 절약)
        const targetFPS = 60;
        const frameDelay = 1000 / targetFPS;
        let lastFrameTime = Date.now();

        function gameLoop(loopId) {
            // 이 루프가 현재 활성 루프가 아니면 중단
            if (loopId !== gameLoopId) {
                console.log('Stopping old game loop', loopId);
                return;
            }

            const currentTime = Date.now();
            const timeSinceLastFrame = currentTime - lastFrameTime;

            // 60fps 제한
            if (timeSinceLastFrame < frameDelay) {
                requestAnimationFrame(() => gameLoop(loopId));
                return;
            }

            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;
            lastFrameTime = currentTime - (timeSinceLastFrame % frameDelay);

            updateFPS();
            update(deltaTime);
            draw();

            requestAnimationFrame(() => gameLoop(loopId));
        }

        // ==================== 아이템 시스템 함수 ====================

        // 로컬스토리지 저장/로드
        function saveItemData() {
            try {
                const keys = getCurrentStorageKeys();
                localStorage.setItem(keys.inventory, JSON.stringify(inventory));
                localStorage.setItem(keys.equipped, JSON.stringify(equippedItems.map(item => item ? item.id : null)));
                localStorage.setItem(keys.tickets, gachaTickets);
                console.log('💾 아이템 데이터 저장 완료 (userKey:', getCurrentUserKey(), ')');
            } catch (e) {
                console.error('Failed to save item data:', e);
            }
        }

        function loadItemData() {
            try {
                const keys = getCurrentStorageKeys();

                // 인벤토리 로드
                const savedInv = localStorage.getItem(keys.inventory);
                if (savedInv) {
                    inventory = JSON.parse(savedInv);
                }

                // 장착 아이템 로드
                const savedEquipped = localStorage.getItem(keys.equipped);
                if (savedEquipped) {
                    const equippedIds = JSON.parse(savedEquipped);
                    equippedItems = equippedIds.map(id => id ? inventory.find(item => item.id === id) : null);
                    // 3개 슬롯 보장
                    while (equippedItems.length < 3) {
                        equippedItems.push(null);
                    }
                    equippedItems.forEach(item => {
                        if (item) item.equipped = true;
                    });
                } else {
                    // 저장된 데이터가 없으면 3개 슬롯 초기화
                    equippedItems = [null, null, null];
                }

                // 보급권 로드
                const savedTickets = localStorage.getItem(keys.tickets);
                if (savedTickets) {
                    gachaTickets = parseInt(savedTickets) || 0;
                } else {
                    gachaTickets = 0;
                }

                // 첫 플레이 보상 (보급권 1장)
                const firstPlay = localStorage.getItem(keys.firstPlay);
                if (!firstPlay) {
                    gachaTickets = 1;
                    localStorage.setItem(keys.firstPlay, 'true');
                    console.log('첫 플레이 보상: 보급권 1장 지급');
                }

                // 연속 접속 보상 체크
                checkLoginStreak();

                updateMenuTicketDisplay();
                console.log('📂 아이템 데이터 로드 완료 (userKey:', getCurrentUserKey(), ')');
            } catch (e) {
                console.error('Failed to load item data:', e);
                inventory = [];
                equippedItems = [null, null, null];
                gachaTickets = 0;
            }
        }

        // 연속 접속 체크 (3일 연속 접속 시 보급권 1장)
        function checkLoginStreak() {
            const keys = getCurrentStorageKeys();
            const today = new Date().toDateString();
            const lastLogin = localStorage.getItem(keys.lastLogin);
            const loginStreak = parseInt(localStorage.getItem(keys.loginStreak) || '0');

            if (lastLogin !== today) {
                const yesterday = new Date();
                yesterday.setDate(yesterday.getDate() - 1);
                const yesterdayStr = yesterday.toDateString();

                let newStreak = 1;
                if (lastLogin === yesterdayStr) {
                    // 연속 접속
                    newStreak = loginStreak + 1;
                }

                if (newStreak >= 3) {
                    gachaTickets++;
                    console.log('3일 연속 접속 보상: 보급권 1장 지급');
                    showTossModal({
                        title: '3일 연속 접속 보상!',
                        message: '🎉 보급권 1장을 받았습니다!\n계속 접속해서 더 많은 보상을 받으세요!',
                        buttons: [{ text: '확인', color: 'primary' }]
                    });
                    newStreak = 0;  // 리셋
                }

                localStorage.setItem(keys.lastLogin, today);
                localStorage.setItem(keys.loginStreak, newStreak);
            }
        }

        // 메뉴 화면의 보급권 개수 업데이트 (사용 안 함)
        function updateMenuTicketDisplay() {
            updateSupplyTicketDisplay();
        }

        // 보급권 표시 업데이트 (왼쪽 상단)
        function updateSupplyTicketDisplay() {
            const supplyTicketDisplay = document.getElementById('supplyTicketDisplay');
            if (supplyTicketDisplay) {
                supplyTicketDisplay.textContent = `보급권: ${gachaTickets}장`;
            }
        }

        // 게임 진행 상황 저장 (캐릭터, 골드, 스테이지)
        function saveGameProgress() {
            try {
                const keys = getCurrentStorageKeys();
                const userKey = getCurrentUserKey();

                console.log('💾 saveGameProgress 호출됨');
                console.log('   - currentUserKey:', userKey);
                console.log('   - keys.totalGold:', keys.totalGold);
                console.log('   - totalGold 값:', totalGold);

                // 총 골드 저장
                localStorage.setItem(keys.totalGold, totalGold.toString());

                // 캐릭터 언락/업그레이드 정보 저장
                const characterData = characters.map(char => ({
                    id: char.id,
                    unlocked: char.unlocked,
                    upgradeLevel: char.upgradeLevel || 0
                }));
                localStorage.setItem(keys.characters, JSON.stringify(characterData));
                console.log('   - 캐릭터 데이터 저장:', characterData);

                // 스테이지 언락 정보 저장
                const stageData = stages.map(stage => ({
                    id: stage.id,
                    unlocked: stage.unlocked
                }));
                localStorage.setItem(keys.stages, JSON.stringify(stageData));
                console.log('   - 스테이지 데이터 저장:', stageData);

                console.log('✅ 게임 진행 상황 저장 완료 (골드:', totalGold, ')');
            } catch (e) {
                console.error('❌ 게임 진행 상황 저장 실패:', e);
            }
        }

        // 게임 진행 상황 로드
        function loadGameProgress() {
            try {
                const keys = getCurrentStorageKeys();
                const userKey = getCurrentUserKey();

                console.log('📂 loadGameProgress 호출됨');
                console.log('   - currentUserKey:', userKey);
                console.log('   - keys.totalGold:', keys.totalGold);

                // 총 골드 로드
                const savedGold = localStorage.getItem(keys.totalGold);
                console.log('   - savedGold:', savedGold);
                if (savedGold) {
                    totalGold = parseInt(savedGold) || 0;
                    console.log('✅ 골드 로드:', totalGold);
                } else {
                    console.log('⚠️ 저장된 골드 없음');
                }

                // 캐릭터 정보 로드
                const savedCharacters = localStorage.getItem(keys.characters);
                console.log('   - savedCharacters:', savedCharacters);
                if (savedCharacters) {
                    const characterData = JSON.parse(savedCharacters);
                    characterData.forEach(saved => {
                        const char = characters.find(c => c.id === saved.id);
                        if (char) {
                            char.unlocked = saved.unlocked;
                            char.upgradeLevel = saved.upgradeLevel || 0;
                        }
                    });
                    console.log('✅ 캐릭터 정보 로드 완료:', characterData);
                } else {
                    console.log('⚠️ 저장된 캐릭터 정보 없음');
                }

                // 스테이지 정보 로드
                const savedStages = localStorage.getItem(keys.stages);
                console.log('   - savedStages:', savedStages);
                if (savedStages) {
                    const stageData = JSON.parse(savedStages);
                    stageData.forEach(saved => {
                        const stage = stages.find(s => s.id === saved.id);
                        if (stage) {
                            stage.unlocked = saved.unlocked;
                        }
                    });
                    console.log('✅ 스테이지 정보 로드 완료:', stageData);
                } else {
                    console.log('⚠️ 저장된 스테이지 정보 없음');
                }

                // UI 업데이트
                updateGoldUI();
            } catch (e) {
                console.error('❌ 게임 진행 상황 로드 실패:', e);
            }
        }

        // 등급 추첨 함수
        function rollRarity() {
            const rand = Math.random();
            let cumulative = 0;

            for (const [key, data] of Object.entries(ITEM_RARITY)) {
                cumulative += data.chance;
                if (rand < cumulative) {
                    return key;
                }
            }
            return 'common';
        }

        // 보급 실행 (정비소 화면에서)
        function performGachaInInventory() {
            if (gachaTickets <= 0) {
                showTossModal({
                    title: '보급권 부족',
                    message: '보급권이 부족합니다!\n3일 연속 접속 시 보급권을 받을 수 있습니다.',
                    buttons: [{ text: '확인', color: 'danger' }]
                });
                return;
            }

            if (inventory.length >= 50) {
                showTossModal({
                    title: '인벤토리 가득참',
                    message: '인벤토리가 가득 찼습니다!\n아이템을 판매하고 다시 시도해주세요.',
                    buttons: [{ text: '확인', color: 'danger' }]
                });
                return;
            }

            // 보급권 사용 확인
            showTossModal({
                title: '보급 확인',
                message: `보급권 1장을 소모하여 보급을 받으시겠습니까?\n\n보유: ${gachaTickets}장`,
                buttons: [
                    { text: '취소', color: 'secondary' },
                    {
                        text: '확인', color: 'primary', onClick: () => {
                            gachaTickets--;

                            // 랜덤 아이템 선택
                            const randomItem = ITEMS_DATABASE[Math.floor(Math.random() * ITEMS_DATABASE.length)];
                            const rarity = rollRarity();
                            const newItem = createItemInstance(randomItem.id, rarity);

                            inventory.push(newItem);
                            saveItemData();
                            updateMenuTicketDisplay();

                            // 애니메이션 표시 (정비소 화면 내)
                            showGachaAnimationInInventory(newItem);
                        }
                    }
                ]
            });
        }

        // 보급 실행 (구버전 - 사용 안 함)
        function performGacha() {
            performGachaInInventory();
        }

        // 보급 애니메이션 (정비소 화면 내) - 새 팝업창
        function showGachaAnimationInInventory(item) {
            const modal = document.getElementById('gachaResultModal');
            const card = document.getElementById('gachaResultCard');

            // 등급별 후광 색상
            const glowColors = {
                common: 'rgba(156, 163, 175, 0.3)',
                uncommon: 'rgba(16, 185, 129, 0.4)',
                rare: 'rgba(59, 130, 246, 0.5)',
                epic: 'rgba(168, 85, 247, 0.6)',
                legend: 'rgba(245, 158, 11, 0.7)'
            };

            const glowColor = glowColors[item.rarity] || 'rgba(168, 85, 247, 0.3)';

            // 카드 내용 생성
            card.className = `gacha-result-card ${item.rarity}`;
            card.style.border = `3px solid ${item.rarityColor}`;
            card.style.boxShadow = `0 0 40px ${glowColor}, 0 0 80px ${glowColor}`;

            card.innerHTML = `
                <h2 style="color: #4ecca3; margin-bottom: 30px; font-size: 28px;">보급 획득!</h2>
                <div style="margin: 30px 0;">${renderItemIcon(item.icon, '100px')}</div>
                <div style="font-size: 16px; color: ${item.rarityColor}; font-weight: bold; margin-bottom: 15px; text-transform: uppercase;">${item.rarityName}</div>
                <div style="font-size: 26px; font-weight: bold; color: #e8d5f2; margin-bottom: 20px;">${item.name}</div>
                <div style="font-size: 16px; color: #aaa; line-height: 1.6; margin-bottom: 30px;">${getItemEffectDescription(item)}</div>
                <button onclick="closeGachaResultModal()" style="padding: 15px 40px; background: #4ecca3; color: #1a1a2e; border: none; border-radius: 10px; cursor: pointer; font-weight: bold; font-size: 18px; transition: all 0.3s;">
                    확인
                </button>
            `;

            modal.style.display = 'flex';
            modal.style.animation = 'modalFadeIn 0.3s ease-out';
        }

        function closeGachaResultModal() {
            const modal = document.getElementById('gachaResultModal');
            modal.style.display = 'none';
            renderInventory();  // 인벤토리 다시 렌더링 (새 아이템 표시)
        }

        function closeGachaResultInventory() {
            closeGachaResultModal();
        }

        // 보급 애니메이션 (구버전 - 사용 안 함)
        function showGachaAnimation(item) {
            showGachaAnimationInInventory(item);
        }

        function closeGachaResult() {
            closeGachaResultInventory();
        }

        // 아이템 효과 설명 생성
        function getItemEffectDescription(item) {
            const effects = [];
            for (const [key, value] of Object.entries(item.baseEffect)) {
                let displayValue = value * item.multiplier;

                // 백분율로 표시할 효과들
                if (key.includes('Damage') || key.includes('Speed') || key.includes('Range') ||
                    key.includes('Gain') || key.includes('Reduction') || key === 'allDamage' ||
                    key === 'maxHp' || key === 'moveSpeed' || key === 'accuracy' || key === 'dodgeChance' ||
                    key === 'damageReduction' || key === 'healOnXp' || key === 'knockbackResist' ||
                    key === 'enemyRange' || key === 'xpGain' || key === 'goldGain' || key === 'cooldownReduction' ||
                    key === 'enemySlowdown' || key === 'attackSpeed' || key === 'critChance') {
                    displayValue = Math.round(displayValue * 100);
                    effects.push(item.desc.replace('{value}', displayValue));
                } else {
                    effects.push(item.desc.replace('{value}', Math.round(displayValue)));
                }
            }
            return effects.join(', ');
        }

        // 정비소 화면 열기/닫기
        function openInventoryFromMenu() {
            document.getElementById('mainMenu').style.display = 'none';
            document.getElementById('inventoryScreen').style.display = 'flex';
            document.getElementById('gachaResultInventory').style.display = 'none';  // 보급 결과 숨김
            updateGoldUI();  // 골드 UI 업데이트
            renderInventory();
        }

        function closeInventory() {
            document.getElementById('inventoryScreen').style.display = 'none';
            document.getElementById('mainMenu').style.display = 'flex';
            updateGoldUI();  // 골드 UI 업데이트
        }

        // 보급 화면 열기/닫기 (구버전 - 사용 안 함)
        function openGachaFromMenu() {
            openInventoryFromMenu();
        }

        function closeGacha() {
            closeInventory();
        }

        // 인벤토리 렌더링
        function renderInventory() {
            const equippedSlotsEl = document.getElementById('equippedSlots');
            const inventoryGridEl = document.getElementById('inventoryGrid');
            const inventoryCountEl = document.getElementById('inventoryCount');

            // 장착 슬롯 렌더링 (3개)
            equippedSlotsEl.innerHTML = '';
            for (let i = 0; i < 3; i++) {
                const item = equippedItems[i];
                const slotDiv = document.createElement('div');

                if (item) {
                    slotDiv.className = `equipped-slot filled item-card ${item.rarity}`;
                    slotDiv.innerHTML = `
                        <button class="unequip-btn" onclick="unequipItem(${i})">✕</button>
                        <div class="item-icon">${renderItemIcon(item.icon)}</div>
                        <div class="item-rarity ${item.rarity}">${item.rarityName}</div>
                        <div class="item-name">${item.name}</div>
                        <div class="item-effect">${getItemEffectDescription(item)}</div>
                    `;
                } else {
                    slotDiv.className = 'equipped-slot';
                    slotDiv.textContent = `슬롯 ${i + 1}`;
                }

                equippedSlotsEl.appendChild(slotDiv);
            }

            // 인벤토리 렌더링
            inventoryGridEl.innerHTML = '';
            const unequippedItems = inventory.filter(item => !item.equipped);

            unequippedItems.forEach(item => {
                const itemDiv = document.createElement('div');
                itemDiv.className = `item-card ${item.rarity}`;

                // 등급별 판매 가격
                const sellPrices = {
                    common: 50,
                    uncommon: 100,
                    rare: 250,
                    epic: 500,
                    legend: 1000
                };
                const sellPrice = sellPrices[item.rarity] || 50;

                itemDiv.innerHTML = `
                    <div class="item-icon">${renderItemIcon(item.icon)}</div>
                    <div class="item-rarity ${item.rarity}">${item.rarityName}</div>
                    <div class="item-name">${item.name}</div>
                    <div class="item-effect">${getItemEffectDescription(item)}</div>
                    <button class="sell-btn" onclick="event.stopPropagation(); sellItem('${item.id}')">
                        <img src="assets/Gear.png" style="width: 14px; height: 14px; vertical-align: middle; margin-right: 3px; image-rendering: pixelated;" />
                        ${sellPrice}
                    </button>
                `;
                itemDiv.onclick = () => equipItem(item);
                inventoryGridEl.appendChild(itemDiv);
            });

            inventoryCountEl.textContent = inventory.length;
        }

        // 아이템 장착
        function equipItem(item) {
            // 이미 장착 중인지 확인
            if (item.equipped) {
                showTossModal({
                    title: '장착 불가',
                    message: '이미 장착된 아이템입니다!',
                    buttons: [{ text: '확인', color: 'secondary' }]
                });
                return;
            }

            // 빈 슬롯 찾기
            const emptySlotIndex = equippedItems.findIndex(slot => !slot);
            if (emptySlotIndex === -1) {
                showTossModal({
                    title: '슬롯 가득참',
                    message: '장착 슬롯이 가득 찼습니다!\n기존 아이템을 해제하고 다시 시도해주세요.',
                    buttons: [{ text: '확인', color: 'danger' }]
                });
                return;
            }

            // 장착
            item.equipped = true;
            equippedItems[emptySlotIndex] = item;
            saveItemData();
            applyEquipmentEffects();
            renderInventory();
        }

        // 아이템 해제
        function unequipItem(slotIndex) {
            const item = equippedItems[slotIndex];
            if (!item) return;

            item.equipped = false;
            equippedItems[slotIndex] = null;
            saveItemData();
            applyEquipmentEffects();
            renderInventory();
        }

        // 아이템 판매
        function sellItem(itemId) {
            const item = inventory.find(i => i.id === itemId && !i.equipped);
            if (!item) {
                showTossModal({
                    title: '아이템 없음',
                    message: '아이템을 찾을 수 없습니다.\n이미 판매되었거나 장착 중일 수 있습니다.',
                    buttons: [{ text: '확인', color: 'secondary' }]
                });
                return;
            }

            // 등급별 판매 가격
            const sellPrices = {
                common: 50,
                uncommon: 100,
                rare: 250,
                epic: 500,
                legend: 1000
            };
            const sellPrice = sellPrices[item.rarity] || 50;

            if (confirm(`${item.name} (${item.rarityName})을(를) ${sellPrice} 스크랩에 판매하시겠습니까?`)) {
                // 인벤토리에서 제거
                const index = inventory.indexOf(item);
                if (index > -1) {
                    inventory.splice(index, 1);
                }

                // 스크랩 추가
                totalGold += sellPrice;
                currentGold += sellPrice;

                // 저장 및 UI 업데이트
                saveItemData();
                updateGoldUI();
                renderInventory();

                console.log(`✅ ${item.name} 판매 완료: +${sellPrice} 스크랩`);
            }
        }

        // 장착된 아이템의 총 효과 계산
        function calculateEquipmentBonuses() {
            const bonuses = {
                // 공격 효과
                projectileDamage: 0,
                missileDamage: 0,
                empDamage: 0,
                empRange: 0,
                satelliteDamage: 0,
                lightningDamage: 0,
                allDamage: 0,
                attackSpeed: 0,
                critChance: 0,
                critDamage: 0,
                projectileSpeed: 0,
                projectileRange: 0,
                projectilePiercing: 0,
                projectileCount: 0,
                missileSpeed: 0,
                missileHoming: 0,
                missilePiercing: 0,

                // 방어 효과
                maxHp: 0,
                damageReduction: 0,
                dodgeChance: 0,
                healOnXp: 0,
                hpRegen: 0,
                periodicHeal: 0,
                shieldRegen: 0,
                knockbackResist: 0,

                // 이동 효과
                moveSpeed: 0,

                // 특수 효과
                xpGain: 0,
                goldGain: 0,
                xpRange: 0,
                magnetRange: 0,
                cooldownReduction: 0,
                enemySlowdown: 0,
                revive: 0,
                reviveChance: 0,
                upgradeChoice: 0,
                miniDrone: 0,
                enemyRange: 0
            };

            // 장착된 아이템의 효과를 합산
            equippedItems.forEach(item => {
                if (!item) return;

                for (const [effectType, baseValue] of Object.entries(item.baseEffect)) {
                    const finalValue = baseValue * item.multiplier;
                    if (bonuses.hasOwnProperty(effectType)) {
                        bonuses[effectType] += finalValue;
                    }
                }
            });

            return bonuses;
        }

        // 장착된 아이템 효과 적용
        function applyEquipmentEffects() {
            // 게임 시작 전에는 적용하지 않음 (게임 시작 시 적용)
            if (!gameStarted) return;

            const bonuses = calculateEquipmentBonuses();

            // 캐릭터 기본 스탯 가져오기
            const char = characters.find(c => c.id === selectedCharacter);
            const upgradedStats = getUpgradedStats(char.stats, char.upgradeLevel);

            // HP 관련 (최대 HP 증가, 현재 HP 비율 유지)
            if (bonuses.maxHp > 0) {
                const hpRatio = player.hp / player.maxHp;
                player.maxHp = Math.round(upgradedStats.hp * (1 + bonuses.maxHp));
                player.hp = Math.round(player.maxHp * hpRatio);
            } else {
                player.maxHp = upgradedStats.hp;
            }

            // 이동 속도
            player.speed = upgradedStats.speed * (1 + bonuses.moveSpeed);

            // 투사체 데미지 (기본 데미지 + 보너스)
            weaponDamage = upgradedStats.damage * (1 + bonuses.projectileDamage + bonuses.allDamage);

            // 투사체 속도
            if (bonuses.projectileSpeed > 0) {
                projectileSpeed = 5 * (1 + bonuses.projectileSpeed);
            }

            // 공격 속도 (weaponSpeed는 쿨다운이므로 속도 증가 = 쿨다운 감소)
            if (bonuses.attackSpeed > 0) {
                weaponSpeed = 350 * (1 - bonuses.attackSpeed);
            }

            // 미사일 데미지
            if (hasMissile) {
                missileDamage = 25 * (1 + bonuses.missileDamage + bonuses.allDamage);
            }

            // 미사일 속도
            if (bonuses.missileSpeed > 0) {
                missileSpeed = 4 * (1 + bonuses.missileSpeed);
            }

            // 투사체 관통 (업그레이드 시스템에 이미 있는 piercing에 추가)
            if (bonuses.projectilePiercing > 0) {
                piercing = (piercing || 0) + Math.floor(bonuses.projectilePiercing);
            }

            // 투사체 개수 (업그레이드 시스템에 이미 있는 projectileCount에 추가)
            if (bonuses.projectileCount > 0) {
                projectileCount = (projectileCount || 1) + Math.floor(bonuses.projectileCount);
            }

            // EMP 데미지
            if (hasEMP) {
                empDamage = 30 * (1 + bonuses.empDamage + bonuses.allDamage);
            }

            // EMP 범위
            if (bonuses.empRange > 0) {
                empRange = 150 * (1 + bonuses.empRange);
            }

            // 미사일 관통
            if (bonuses.missilePiercing > 0) {
                missilePiercing = Math.floor(bonuses.missilePiercing);
            }

            // 위성 공격 데미지
            if (hasSatellite) {
                satelliteDamage = 40 * (1 + bonuses.satelliteDamage + bonuses.lightningDamage + bonuses.allDamage);
            }

            // 쿨다운 감소
            if (bonuses.cooldownReduction > 0) {
                empCooldown = 2000 * (1 - bonuses.cooldownReduction);
                satelliteCooldown = 2500 * (1 - bonuses.cooldownReduction);
            }

            // 자석 범위 (xpRange도 magnetRange로 적용)
            if (bonuses.magnetRange > 0 || bonuses.xpRange > 0) {
                magnetRange = 100 * (1 + bonuses.magnetRange + bonuses.xpRange);
            }

            // 특수 효과 저장 (전투 중 사용)
            itemBonuses.critChance = bonuses.critChance;
            itemBonuses.critDamage = bonuses.critDamage;
            itemBonuses.dodgeChance = bonuses.dodgeChance;
            itemBonuses.damageReduction = bonuses.damageReduction;
            itemBonuses.xpGain = bonuses.xpGain;
            itemBonuses.goldGain = bonuses.goldGain;
            itemBonuses.healOnXp = bonuses.healOnXp;
            itemBonuses.hpRegen = bonuses.hpRegen;
            itemBonuses.periodicHeal = bonuses.periodicHeal;
            itemBonuses.revive = Math.floor(bonuses.revive);
            itemBonuses.upgradeChoice = Math.floor(bonuses.upgradeChoice);
            itemBonuses.miniDrone = Math.floor(bonuses.miniDrone);
            itemBonuses.enemySlowdown = bonuses.enemySlowdown;

            // 미니 드론 업데이트 (개수 맞추기)
            const targetDroneCount = itemBonuses.miniDrone;
            while (miniDrones.length < targetDroneCount) {
                miniDrones.push({
                    angleOffset: (Math.PI * 2 / targetDroneCount) * miniDrones.length
                });
            }
            while (miniDrones.length > targetDroneCount) {
                miniDrones.pop();
            }

            console.log('✅ 장착 아이템 효과 적용됨:', bonuses);
        }

        // 보스 처치 시 보급권 드롭 (25% 확률)
        function checkBossTicketDrop() {
            const dropChance = 0.25;  // 25% 확률
            if (Math.random() < dropChance) {
                gachaTickets++;
                saveItemData();
                updateMenuTicketDisplay();

                // 보스 처치 보상 로그
                console.log('보스 처치 보상: 보급권 1장 획득!');
            }
        }

        // ==================== Toss Game Center 리더보드 ====================

        // Toss Game Center 리더보드 열기
        async function openTossLeaderboard() {
            if (!window.tossIntegration) {
                console.warn('⚠️ Toss Integration not ready');
                showTossModal({
                    title: '알림',
                    message: 'Toss 앱에서 실행 시\n리더보드를 볼 수 있습니다.',
                    buttons: [{ text: '확인', color: 'primary' }]
                });
                return;
            }

            // SDK 가용성 체크
            if (!window.tossIntegration.isLeaderboardAvailable()) {
                const envInfo = window.tossIntegration.getEnvironmentInfo();
                console.warn('⚠️ 리더보드 SDK 없음:', envInfo);
                showTossModal({
                    title: '리더보드를 열 수 없습니다',
                    message: 'Toss 앱 버전이 낮거나\nSDK가 로드되지 않았습니다.\n\n환경: ' + envInfo.env + '\n버전: ' + envInfo.tossVersion,
                    buttons: [{ text: '확인', color: 'primary' }]
                });
                return;
            }

            // SDK가 있으면 리더보드 열기
            const result = await window.tossIntegration.openGameCenterLeaderboard();

            if (!result.success) {
                // 실패 시에만 에러 메시지 표시 (Toss 스타일 모달 사용)
                if (result.reason === 'version') {
                    showTossModal({
                        title: '리더보드를 열 수 없습니다',
                        message: 'Toss 앱 버전이 낮습니다.\nv5.221.0 이상이 필요합니다.',
                        buttons: [{ text: '확인', color: 'primary' }]
                    });
                } else if (result.reason === 'no_sdk') {
                    showTossModal({
                        title: '알림',
                        message: 'Toss 앱에서 실행 시\n리더보드를 볼 수 있습니다.',
                        buttons: [{ text: '확인', color: 'primary' }]
                    });
                } else {
                    showTossModal({
                        title: '리더보드를 열 수 없습니다',
                        message: '가능한 원인:\n1. 게임 카테고리 미설정\n2. 네트워크 연결 오류\n3. 시스템 오류',
                        buttons: [{ text: '확인', color: 'primary' }]
                    });
                }
            }
            // 성공 시(result.success === true)는 리더보드가 열리므로 아무것도 안 함
        }

        // ==================== 디버그 패널 (개발자용) ====================

        let titleTapCount = 0;
        let titleTapTimer = null;

        // 타이틀 5번 탭으로 디버그 패널 열기
        function handleTitleTap() {
            titleTapCount++;

            // 타이머 초기화
            if (titleTapTimer) {
                clearTimeout(titleTapTimer);
            }

            // 2초 내에 5번 탭하면 디버그 패널 열기
            if (titleTapCount >= 5) {
                titleTapCount = 0;
                openDebugPanel();
            } else {
                // 2초 후 카운트 리셋
                titleTapTimer = setTimeout(() => {
                    titleTapCount = 0;
                }, 2000);
            }
        }

        // 디버그 패널 열기
        function openDebugPanel() {
            refreshDebugInfo();
            document.getElementById('debugPanel').style.display = 'block';
        }

        // 디버그 패널 닫기
        function closeDebugPanel() {
            document.getElementById('debugPanel').style.display = 'none';
        }

        // 디버그 정보 새로고침
        function refreshDebugInfo() {
            const envDiv = document.getElementById('debugEnv');
            const sdkDiv = document.getElementById('debugSDK');
            const detailsDiv = document.getElementById('debugDetails');

            // 환경 정보
            const env = window.getOperationalEnvironment ? window.getOperationalEnvironment() : '알 수 없음';
            const tossVersion = window.getTossAppVersion ? window.getTossAppVersion() : '알 수 없음';
            const platform = window.getPlatformOS ? window.getPlatformOS() : '알 수 없음';

            envDiv.innerHTML = `
                환경: <span style="color: ${env === 'production' ? '#4ecca3' : '#ffa502'}">${env}</span><br>
                Toss 버전: <span style="color: #fff">${tossVersion}</span><br>
                플랫폼: <span style="color: #fff">${platform}</span><br>
                User Agent: <span style="color: #aaa; font-size: 10px;">${navigator.userAgent.substring(0, 50)}...</span>
            `;

            // SDK 가용성
            if (window.tossIntegration) {
                const leaderboard = window.tossIntegration.isLeaderboardAvailable();
                const ad = window.tossIntegration.isAdAvailable();
                const invite = window.tossIntegration.isInviteFriendsAvailable();

                sdkDiv.innerHTML = `
                    리더보드: ${leaderboard ? '<span style="color: #4ecca3">✅ 사용 가능</span>' : '<span style="color: #ff6b6b">❌ 사용 불가</span>'}<br>
                    광고: ${ad ? '<span style="color: #4ecca3">✅ 사용 가능</span>' : '<span style="color: #ff6b6b">❌ 사용 불가</span>'}<br>
                    친구 초대: ${invite ? '<span style="color: #4ecca3">✅ 사용 가능</span>' : '<span style="color: #ff6b6b">❌ 사용 불가</span>'}
                `;

                // 상세 정보
                detailsDiv.innerHTML = `
                    window.openGameCenterLeaderboard: ${typeof window.openGameCenterLeaderboard}<br>
                    window.submitGameCenterLeaderBoardScore: ${typeof window.submitGameCenterLeaderBoardScore}<br>
                    window.GoogleAdMob: ${typeof window.GoogleAdMob}<br>
                    ${window.GoogleAdMob ? `&nbsp;&nbsp;- loadAppsInTossAdMob: ${typeof window.GoogleAdMob.loadAppsInTossAdMob}<br>` : ''}
                    ${window.GoogleAdMob ? `&nbsp;&nbsp;- showAppsInTossAdMob: ${typeof window.GoogleAdMob.showAppsInTossAdMob}<br>` : ''}
                    window.contactsViral: ${typeof window.contactsViral}<br>
                    window.getUserKeyForGame: ${typeof window.getUserKeyForGame}<br>
                    <br>
                    userKey: ${window.tossIntegration.userKey ? '✅ 있음' : '❌ 없음'}<br>
                    isAdReady: ${window.tossIntegration.isAdReady ? '✅ 준비됨' : '❌ 미준비'}
                `;
            } else {
                sdkDiv.innerHTML = '<span style="color: #ff6b6b">❌ Toss Integration 없음</span>';
                detailsDiv.innerHTML = 'window.tossIntegration 객체가 존재하지 않습니다.';
            }
        }
    </script>
</body>

</html>